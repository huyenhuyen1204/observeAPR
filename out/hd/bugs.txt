null-------------
@@ -891,6 +891,7 @@
      *     <li>Parameters</li>
      *     <li>Cookies</li>
      *     <li>Headers</li>
+     *     <li>Filters</li>
      * </ul>
      * @param specification The specification to add
      * @return The request specification builder
---------------
-------------
@@ -1,12 +1,12 @@
 package org.esa.beam.binning.support;
-lue
+
 import org.esa.beam.binning.PlanetaryGrid;
 
 /**
  * Thin wrapper around a {@code PlanetaryGrid} used to convert from BEAM row and bin indexes to the ones
  * used in SeaDAS. BEAM row and bin indexes are 0-based and increase from North to South (top down), while the
- * SeaDAS ones are 1-based and from South to North (bottom up). In both grids, columns indexes increase from East
- * to West (left to right).
+ * SeaDAS ones are 1-based and increase from South to North (bottom up). In both grids, columns indexes increase from West
+ * to East (left to right).
  *
  * @author Norman Fomferra
  */
@@ -14,8 +14,7 @@
 
     public static final int MAX_NUM_BINS = Integer.MAX_VALUE - 1;
     private final PlanetaryGrid baseGrid;
-:q
-	:q
+
     public SeadasGrid(PlanetaryGrid baseGrid) {
 
         if (!isCompatibleBaseGrid(baseGrid)) {
---------------
-------------
@@ -28,7 +28,7 @@
     private static final String DEFAULT_FILE_EXTENSION = ".hdf";
     private static final String DEFAULT_FILE_EXTENSION_L2_LAC = ".L2_LAC";
     private static final String DEFAULT_FILE_EXTENSION_L2_LAC_OC = DEFAULT_FILE_EXTENSION_L2_LAC + "_OC";
-    private static final String DEFAULT_FILE_EXTENSION_L2_LAC_SST = DEFAULT_FILE_EXTENSION_L2_LAC + "SST";
+    private static final String DEFAULT_FILE_EXTENSION_L2_LAC_SST = DEFAULT_FILE_EXTENSION_L2_LAC + "_SST";
     private static final String DEFAULT_FILE_EXTENSION_L2_LAC_SST4 = DEFAULT_FILE_EXTENSION_L2_LAC + "_SST4";
     private static final String DEFAULT_FILE_EXTENSION_L2_MLAC = ".L2_MLAC";
     public static final String READER_DESCRIPTION = "NASA Ocean Color (OBPG) Products";
---------------
-------------
@@ -28,5 +28,5 @@
     static final String[] LON_NAMES = new String[]{"lon", "long", "longitude", "easting"};
     static final String[] TIME_NAMES = new String[]{"time", "date", "date_time", "dateTime"};
     static final String[] LOCATION_NAMES = new String[]{"name", "station", "label"};
-    static final String TIME_PATTERN = "yyyy-MM-dd'T'hh:mm:ss";
+    static final String TIME_PATTERN = "yyyy-MM-dd'T'HH:mm:ss";
 }
---------------
-------------
@@ -352,7 +352,7 @@
         }
 
         public Rectangle getPixelRegion() {
-            return new Rectangle(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
+            return new Rectangle(x1, y1, x2 - x1, y2 - y1);
         }
     }
 }
---------------
-------------
@@ -230,7 +230,7 @@
     @Override
     public void initialize() throws OperatorException {
         targetProduct = sourceProduct;
-        if(targetProduct.getFileLocation().exists()) {
+        if(targetProduct.getFileLocation() != null && targetProduct.getFileLocation().exists()) {
             deleteOutputOnFailure = false;
         }
         productWriter = ProductIO.getProductWriter(formatName);
---------------
-------------
@@ -48,7 +48,7 @@
                 } else if (Datum.WGS_72.equals(datum)) {
                     result = WGS72;
                 }
-            } else if (projection instanceof UTMProjection) {
+            } else if (projection instanceof UTMProjection && !Datum.ITRF_97.equals(datum)) {
                 // 2. UTM map projections
                 final UTMProjection utmProjection = (UTMProjection) projection;
                 final int zone = utmProjection.getZone();
---------------
-------------
@@ -126,7 +126,7 @@
     /**
      * Y-offset of AATSR tie-points corresponds to the lower bound of a pixel.
      */
-    float AATSR_TIE_POINT_OFFSET_Y = 1.0F;
+    float AATSR_TIE_POINT_OFFSET_Y = 0.0F;
 
     /**
      * Number of localisation tie points in across track direction for the ASAR grid.
---------------
-------------
@@ -112,7 +112,7 @@
     int AATSR_LOC_TIE_POINT_SUBSAMPLING_X = 25;
     int AATSR_LOC_TIE_POINT_SUBSAMPLING_Y = 32;
     int AATSR_LOC_TIE_POINT_RASTER_WIDTH = (AATSR_LOC_TIE_POINT_GRID_WIDTH - 1) * AATSR_LOC_TIE_POINT_SUBSAMPLING_X;
-    float AATSR_LOC_TIE_POINT_OFFSET_X = 0.5F * AATSR_SCENE_RASTER_WIDTH - 0.5F * AATSR_LOC_TIE_POINT_RASTER_WIDTH;
+    float AATSR_LOC_TIE_POINT_OFFSET_X = 0.5F * AATSR_SCENE_RASTER_WIDTH - 0.5F * AATSR_LOC_TIE_POINT_RASTER_WIDTH + 1.0F;
 
     /**
      * Number of solar angle tie points in across track direction for the AATSR grid.
---------------
-------------
@@ -116,7 +116,7 @@
 		return this;
 	}
 
-	public Url urlSuffix(String urlSuffix) {
+	public Url suffix(String urlSuffix) {
 		this.urlSuffix = urlSuffix;
 		return this;
 	}
---------------
-------------
@@ -54,7 +54,7 @@
         super();
         final String[] cols = line.split(" ");
         if (cols.length < 4) {
-            Tools.appError("cannot parse: " + line);
+            Tools.appWarning("cannot parse: " + line);
         }
         String iface = "unknown";
         if (cols.length > 0) {
---------------
-------------
@@ -27,7 +27,7 @@
 
 public class ConceptSearchResultJsonParser extends AbstractJsonResultParser {
 
-    private static final String ROOT_EXPRESSION = "$.success.data[0].contents.searchResultList";
+    private static final String ROOT_EXPRESSION = "$.success.data[0].page.contents.searchResultList.searchBean";
 
     public ConceptSearchResultJsonParser(JsonParser jsonParser) {
         super(jsonParser);
---------------
-------------
@@ -357,7 +357,7 @@
 		// and also <!--<![endif]-->"
 		if (tagText.equals("![endif]--"))
 		{
-			lastType = HttpTagType.CONDITIONAL_COMMENT;
+			lastType = HttpTagType.CONDITIONAL_COMMENT_ENDIF;
 			input.setPosition(closeBracketIndex + 1);
 			return;
 		}
---------------
-------------
@@ -20,19 +20,7 @@
  * A marker interface that represents a model that serves as a wrapper for
  * another. Typically these models are produced by the following methods:
  * {@link IComponentAssignedModel#wrapOnAssignment(wicket.Component)} and
- * {@link IInheritanceAware#wrapOnInheritance(wicket.Component)}
- * 
- * <b>Nested Models </b>- IModels can be nested and the innermost model is also
- * known as the "root" model since it is the model on which the outer models
- * rely. The getNestedModel() method on IModel gets any nested model within the
- * given model. This allows Component.sameInnermostModel() to compare two models
- * to see if they both have the same innermost model (the same most nested
- * model).
- * <p>
- * For example, a Form might have a Person model and then a TextField might have
- * a PropertyModel which is the "name" property of the Person model. In this
- * case, PropertyModel will implement getNestedModel(), returning the Person
- * model which is the nested model of the property model.
+ * {@link IComponentInheritedModel#wrapOnInheritance(wicket.Component)}
  * 
  * @author jcompagner
  * @author Igor Vaynberg (ivaynberg)
---------------
-------------
@@ -346,6 +346,7 @@
 		}
 
 		// flag markup as non-existent
+		markupKeyCache.put(cacheKey, cacheKey);
 		return putIntoCache(cacheKey, Markup.NO_MARKUP);
 	}
 
---------------
-------------
@@ -334,7 +334,7 @@
 			}
 		}
 
-		for (int i = 0; i < commonPrefix.getSegments().size(); i++)
+		for (int i = 0; i < commonPrefix.getSegments().size() && !segments.isEmpty(); i++)
 		{
 			segments.remove(0);
 		}
---------------
-------------
@@ -313,7 +313,7 @@
 			{
 				renderJavascriptReference(WicketEventReference.INSTANCE);
 				JavascriptUtils.writeJavascript(getResponse(), "Wicket.Event.add(" + target +
-					", \"" + event + "\", function() { " + javascript + ";});");
+					", \"" + event + "\", function(event) { " + javascript + ";});");
 				markRendered(token);
 			}
 		}
---------------
-------------
@@ -65,6 +65,6 @@
 
 		// Validate the document
 		String document = application.getServletResponse().getDocument();
-		assertTrue(DiffUtil.validatePage(document, this.getClass(), filename));
+		assertTrue(DiffUtil.validatePage(document, this.getClass(), filename, false));
 	}
 }
---------------
-------------
@@ -50,7 +50,7 @@
 	 */
 	protected EmailAddressPatternValidator()
 	{
-		super("^[_a-z0-9-]+(\\.[_a-z0-9-]+)*@[a-z0-9-]+(\\.[a-z0-9-]+)*(\\.[a-z]{2,3})$", Pattern.CASE_INSENSITIVE);
+		super("^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\\.[A-Za-z0-9-]+)*((\\.[A-Za-z]{2,}){1}$)", Pattern.CASE_INSENSITIVE);
 	}
 
 	/**
---------------
-------------
@@ -20,7 +20,6 @@
 
 import java.util.List;
 
-import wicket.PageParameters;
 import wicket.examples.displaytag.list.SortableListViewHeader;
 import wicket.examples.displaytag.list.SortableListViewHeaders;
 import wicket.examples.displaytag.utils.ListObject;
---------------
-------------
@@ -259,6 +259,7 @@
      * will read-ahead at max. the very first line of the markup.
      * 
      * @param in The markup file
+     * @param readAheadSize look ahead
      * @return null, if &lt;?xml ..?&gt; has been found; else all characters read ahead
      * @throws IOException
      */
---------------
-------------
@@ -385,7 +385,7 @@
 		{
 			if (terabytes() >= 1.0)
 			{
-				return unitString(gigabytes(), "T", locale);
+				return unitString(terabytes(), "T", locale);
 			}
 
 			if (gigabytes() >= 1.0)
---------------
-------------
@@ -36,7 +36,7 @@
 	private Server server;
 	private String contextPath;
 	private String webappLocation;
-
+	
 	/**
 	 * @param test
 	 */
---------------
-------------
@@ -51,7 +51,7 @@
 		server.setConnectors(new Connector[] { connector });
 
 		WebAppContext web = new WebAppContext();
-		web.setContextPath("/org.apache.wicket-examples");
+		web.setContextPath("/wicket-examples");
 
 		String basedir = System.getProperty("basedir");
 		String path = "";
---------------
-------------
@@ -241,7 +241,8 @@
 				truncated = _text.endsWith("…") || _text.endsWith("...");
 			}
 			String rtStart = null;
-			if (truncated && original!=null && _text.startsWith("RT ")) {
+			// We should get entities from the original in ALL cases, or else there's a risk of getting truncated entites.
+			if (original!=null && _text.startsWith("RT ")) {
 				rtStart = "RT @"+original.getUser()+": ";
 				_text = rtStart+original.getText();				
 			} else {
---------------
-------------
@@ -15,7 +15,7 @@
 	
 	/**
 	 * Deslocamento do centro da imagem ao centro ao 
-	 * centro l�gico do objeto
+	 * centro logico do objeto
 	 */
 	public float dx = 0;
 	public float dy = 0;
---------------
-------------
@@ -177,6 +177,7 @@
                                  final Resource... contexts) throws SailException {
         cacheConnection.removeStatements(subj, pred, obj, contexts);
         baseSailConnection.removeStatements(subj, pred, obj, contexts);
+        uncommittedChanges = true;
     }
 
     // No rollback ability for now.
---------------
-------------
@@ -17,7 +17,6 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
-import java.util.LinkedList;
 import java.util.List;
 
 
---------------
-------------
@@ -51,7 +51,7 @@
         this.input.setAutoclose( false );
         env.put( RubyString.newString( ruby, "rack.input" ), input );
 
-        this.errors = new RubyIO( ruby, STDIO.ERR );
+        this.errors = new RubyIO( ruby, ruby.getErr() );
         this.errors.setAutoclose( false );
         env.put( RubyString.newString( ruby, "rack.errors" ), errors );
 
---------------
-------------
@@ -135,6 +135,7 @@
                 byteBuffer.limit((int) bytesRemaining);
             }
             bytesRead = inputChannel.read(byteBuffer);
+            totalBytesRead += bytesRead;
             if (bytesRead > 0) {
                 bytes = byteBufferToBytes(byteBuffer, bytesRead);
                 stringBuffer.cat(bytes);
---------------
-------------
@@ -262,7 +262,7 @@
                     String[] version = cmd("git --version").split(" ");
                     assertEquals("Wrong output value " + version, "git", version[0]);
                     assertEquals("Wrong output value " + version, "version", version[1]);
-                    assertTrue("Wrong version value " + version[2], version[2].startsWith("1"));
+                    assertTrue("Wrong version value " + version[2], version[2].startsWith("1") || version[2].startsWith("2"));
                     gitVersion = version[2].trim();
                 } else {
                     gitVersion = "";
---------------
-------------
@@ -41,7 +41,7 @@
     private final BlockEvent handle;
 
     public PoreBlockPistonExtendEvent(BlockEvent handle) {
-        super(null, null, null);
+        super(null, -1, null);
         this.handle = checkNotNull(handle, "handle");
     }
 
---------------
-------------
@@ -127,7 +127,7 @@
     /**
      * Pattern for capturing variables. Either $xyz or ${xyz}, while ignoring "$$"
       */
-    private static final Pattern VARIABLE = Pattern.compile("\\$([A-Za-z0-9_\\.]+|\\{[A-Za-z0-9_\\.]+\\}|\\$)");
+    private static final Pattern VARIABLE = Pattern.compile("\\$([A-Za-z0-9_]+|\\{[A-Za-z0-9_\\.+]+\\}|\\$)");
 
     /**
      * Replaces the occurrence of '$key' by <tt>properties.get('key')</tt>.
---------------
-------------
@@ -127,7 +127,7 @@
     /**
      * Pattern for capturing variables. Either $xyz or ${xyz}, while ignoring "$$"
       */
-    private static final Pattern VARIABLE = Pattern.compile("\\$([A-Za-z0-9_\\.]+|\\{[A-Za-z0-9_\\.]+\\}|\\$)");
+    private static final Pattern VARIABLE = Pattern.compile("\\$([A-Za-z0-9_]+|\\{[A-Za-z0-9_\\.+]+\\}|\\$)");
 
     /**
      * Replaces the occurrence of '$key' by <tt>properties.get('key')</tt>.
---------------
-------------
@@ -311,7 +311,7 @@
     	assertEquals(2, g.getModule().getSymbolCount());
     }
     @Test
-    public void testIncsDecs() throws Exception  {
+    public void testInXtcsDecs() throws Exception  {
     	dumpLLVMGen = true;
     	IAstModule mod = doFrontend("maker1 = code(u,v:Int) { u++ * ++v }; " +
     			"maker2 = code(u,v:Int) { u-- * --v }; " +
---------------
-------------
@@ -454,7 +454,7 @@
       PsiType type2 = params2[Math.min(i, params2.length - 1)].getType();
       if (applicabilityLevel == MethodCandidateInfo.ApplicabilityLevel.VARARGS) {
         if (type1 instanceof PsiEllipsisType && type2 instanceof PsiEllipsisType && 
-            (((PsiArrayType)type1).getComponentType().equalsToText(CommonClassNames.JAVA_LANG_OBJECT) || ((PsiArrayType)type2).getComponentType().equalsToText(CommonClassNames.JAVA_LANG_OBJECT))) {
+            (!JavaVersionService.getInstance().isAtLeast(class1, JavaSdkVersion.JDK_1_8) || ((PsiArrayType)type1).getComponentType().equalsToText(CommonClassNames.JAVA_LANG_OBJECT) || ((PsiArrayType)type2).getComponentType().equalsToText(CommonClassNames.JAVA_LANG_OBJECT))) {
           type1 = ((PsiEllipsisType)type1).toArrayType();
           type2 = ((PsiEllipsisType)type2).toArrayType();
         }
---------------
-------------
@@ -45,7 +45,7 @@
         myRootToModuleMap.put(root, descriptor);
         moduleRoots.add(descriptor);
       }
-      for (String r : module.getExcludes()) {
+      for (String r : module.getOwnExcludes()) {
         final File root = new File(FileUtil.toCanonicalPath(r));
         myExcludedRoots.add(root);
       }
---------------
-------------
@@ -537,7 +537,7 @@
 
     boolean removed = false;
     for (Library each : unusedLibraries) {
-      if (!MavenRootModelAdapter.isChangedByUser(each)) {
+      if (MavenRootModelAdapter.isMavenLibrary(each) && !MavenRootModelAdapter.isChangedByUser(each)) {
         myModelsProvider.removeLibrary(each);
         removed = true;
       }
---------------
-------------
@@ -133,7 +133,7 @@
   }
 
   public String getPresentableText() {
-    return myPropertyName + ":" + myPropertyType.getPresentableText();
+    return myPropertyName + ": " + myPropertyType.getPresentableText();
   }
 
   public String toString() {
---------------
-------------
@@ -113,6 +113,7 @@
       MavenProject depProject = myMavenTree.findProject(artifact.getMavenId());
 
       if (depProject != null) {
+        if (depProject == myMavenProject) continue;
         myRootModelAdapter.addModuleDependency(myMavenProjectToModuleName.get(depProject), scope);
       }
       else {
---------------
-------------
@@ -32,4 +32,6 @@
   AndroidAttributeValue<ResourceValue> getDrawable();
 
   List<BitmapOrNinePatchElement> getBitmaps();
+
+  List<Shape> getShapes();
 }
---------------
-------------
@@ -24,7 +24,7 @@
 import java.util.Set;
 
 public class PackagePatternProvider extends PatternDialectProvider {
-  @NonNls private static final String PACKAGES = "package";
+  @NonNls public static final String PACKAGES = "package";
   private static final Logger LOG = Logger.getInstance("#" + PackagePatternProvider.class.getName());
    public static final Icon ICON = IconLoader.getIcon("/general/packagesTab.png");
 
---------------
-------------
@@ -311,7 +311,7 @@
   private void doImportProjects(List<VirtualFile> files, String... profiles) throws MavenException {
     myProfilesList = Arrays.asList(profiles);
 
-    myMavenProjectsManager.doInitComponent(true);
+    myMavenProjectsManager.doInitComponent(false);
     myMavenProjectsManager.setManagedFiles(files);
     myMavenProjectsManager.setActiveProfiles(myProfilesList);
     myMavenProjectsManager.reimport();
---------------
-------------
@@ -206,7 +206,7 @@
   }
 
   public int getContentType() {
-    throw new UnsupportedOperationException("Method getContentType not implemented in " + getClass());
+    return CONTENT_TYPE_ANY;
   }
 
   public void init(final PsiElement element) {
---------------
-------------
@@ -3670,6 +3670,8 @@
 
       if (myRequestedExpand != null && !myRequestedExpand.equals(path)) return;
 
+      //myRequestedExpand = null;
+
       final DefaultMutableTreeNode node = (DefaultMutableTreeNode)path.getLastPathComponent();
 
       if (!myUnbuiltNodes.contains(node)) {
---------------
-------------
@@ -71,7 +71,7 @@
     throw new UnsupportedOperationException("Can't get binding for: " + type);
   }
 
-  private static Binding _getClassBinding(Class<?> aClass, Type originalType, final Accessor accessor) {
+  private static synchronized Binding _getClassBinding(Class<?> aClass, Type originalType, final Accessor accessor) {
     final Pair<Type, Accessor> p = new Pair<Type, Accessor>(originalType, accessor);
 
     Map<Pair<Type, Accessor>, Binding> map = getBindingCacheMap();
---------------
-------------
@@ -48,6 +48,8 @@
   public SingleRootFileViewProvider createCopy(final LightVirtualFile copy) {
     final CompositeLanguageFileViewProvider viewProvider = cloneInner(copy);
     final PsiFileImpl psiFile = (PsiFileImpl)viewProvider.getPsi(getBaseLanguage());
+    assert psiFile != null;
+    psiFile.setOriginalFile(getPsi(getBaseLanguage()));
 
     // copying main tree
     final FileElement treeClone = (FileElement)psiFile.calcTreeElement().clone(); // base language tree clone
---------------
-------------
@@ -211,7 +211,7 @@
     }
 
     if (patternIndex + i >= myPattern.length) {
-      return i >= minFragment ? FList.<TextRange>emptyList().prepend(TextRange.from(nameIndex, i)) : null;
+      return FList.<TextRange>emptyList().prepend(TextRange.from(nameIndex, i));
     }
     while (i >= minFragment) {
       int nextWordStart;
---------------
-------------
@@ -290,6 +290,7 @@
       if (replacement != null) {
         if (statement instanceof PsiLocalVariable) {
           final PsiLocalVariable variable = (PsiLocalVariable)statement;
+          variable.normalizeDeclaration();
           final PsiExpression initializer = variable.getInitializer();
           LOG.assertTrue(initializer != null);
           final PsiStatement assignmentStatement = myElementFactory.createStatementFromText(var2FieldNames.get(variable.getName()) + " = " + initializer.getText() + ";", statement);
---------------
-------------
@@ -161,6 +161,7 @@
     final ActionCallback selectionDone = new ActionCallback();
 
     getFilteredStructure().refilter();
+    getUi().updateSubtree(getRootNode(), false);
     final Runnable selectionRunnable = new Runnable() {
       public void run() {
         revalidateTree();
---------------
-------------
@@ -33,7 +33,7 @@
   private static final Pattern WORD = Pattern.compile("\\b\\p{L}*'?\\p{L}*");
 
   @NonNls
-  private static final Pattern WORD_EXT = Pattern.compile("(\\p{L}*?)[_$\\[\\]]");
+  private static final Pattern WORD_EXT = Pattern.compile("(\\p{L}*?)[-_$\\[\\]]");
 
   @NonNls
   private static final Pattern WORD_BRACES = Pattern.compile("(['\"]+?)(.*?)(['\"]+?)");
---------------
-------------
@@ -103,7 +103,7 @@
 
   private static void collectResourceDirs(Module module, Set<VirtualFile> result) {
     VirtualFile resDir = AndroidRootUtil.getResourceDir(module);
-    if (resDir == null || !result.add(resDir)) {
+    if (resDir != null && !result.add(resDir)) {
       return;
     }
     for (AndroidFacet depFacet : AndroidUtils.getAllAndroidDependencies(module, false)) {
---------------
-------------
@@ -161,6 +161,8 @@
     }
     catch (NoSuchMethodException e) {
     }
+    catch (IllegalArgumentException e) {
+    }
     if (result != null) return result;
 
     result = additionalProperties.getProperty(propName);
---------------
-------------
@@ -87,6 +87,7 @@
 
   public synchronized void save() throws MavenIndexException {
     try {
+      getListFile().getParentFile().mkdirs();
       FileOutputStream fs = new FileOutputStream(getListFile());
       try {
         DataOutputStream os = new DataOutputStream(fs);
---------------
-------------
@@ -113,7 +113,7 @@
 
     if (seq instanceof CharBuffer) {
       final CharBuffer buffer = (CharBuffer)seq;
-      if (buffer.hasArray() && !buffer.isReadOnly() && buffer.arrayOffset() == 0) {
+      if (buffer.hasArray() && !buffer.isReadOnly() && buffer.arrayOffset() == 0 && buffer.position() == 0) {
         return buffer.array();
       }
     }
---------------
-------------
@@ -176,6 +176,8 @@
     Set<TaskRepository> set = new HashSet<TaskRepository>(myRepositories);
     set.removeAll(repositories);
     myBadRepositories.removeAll(set); // remove all changed reps
+    myIssueCache.clear();
+    myTemporaryCache.clear();
 
     myRepositories.clear();
     myRepositories.addAll(repositories);
---------------
-------------
@@ -98,6 +98,8 @@
             final PsiClassType.ClassResolveResult initializerResult = ((PsiClassType) initializerType).resolveGenerics();
             final PsiClass initializerClass = initializerResult.getElement();
             if (initializerClass != null) {
+              if (declaredClass == initializerClass) return initializerType;
+              
               final PsiSubstitutor superSubstitutor = TypeConversionUtil.getClassSubstitutor(declaredClass, initializerClass, initializerResult.getSubstitutor());
               if (superSubstitutor != null) {
                 return getManager().getElementFactory().createType(declaredClass, superSubstitutor);
---------------
-------------
@@ -1,5 +1,5 @@
 class Test {
-    public final Class aClass = Class.forName(Test.class.getName);
+    public final Class<?> aClass = Class.forName(Test.class.getName);
 
     void foo() {
       Class clazz = aClass;
---------------
-------------
@@ -107,6 +107,7 @@
       if (!expect(builder, JavaTokenType.COMMA)) {
         if (builder.getTokenType() != null && builder.getTokenType() != JavaTokenType.SEMICOLON) {
           error(builder, JavaErrorMessages.message("expected.comma.or.semicolon"));
+          return;
         }
       }
     }
---------------
-------------
@@ -273,7 +273,7 @@
 
 
     myAnimator.stopMovie();
-    myTreeBuilder.performUpdate();
+    myTreeBuilder.updateFromRoot();
 
     LvcsHelper.addLabel(this);
 
---------------
-------------
@@ -605,7 +605,7 @@
           continue;
         }
         if (ch == '?') {
-          builder.append(".{1}");
+          builder.append("[^/]{1}");
           continue;
         }
         if (ch == '\\') {
---------------
-------------
@@ -209,7 +209,7 @@
         return text.charAt(CharArrayUtil.shiftForward(text, 0, " \t")) == '\n';
       }
 
-      if (!(sibling instanceof PsiComment) && !StringUtil.isEmptyOrSpaces(text)) {
+      if (!(sibling instanceof PsiComment) && !StringUtil.isEmptyOrSpaces(text) && !text.equals(";")) {
         return false;
       }
 
---------------
-------------
@@ -4,7 +4,7 @@
 
 public class UnnecessaryAnnotationParentheses {
 
-    @NotNull()
+    @Deprecated()
     Object foo() {
         return null;
     }
---------------
-------------
@@ -56,6 +56,7 @@
   }
 
   public void purgeObsoleteAndSave(long period) {
+    wasModifiedAfterLastSave = true;
     purgeObsolete(period);
     save();
   }
---------------
-------------
@@ -445,7 +445,7 @@
 
     if (!model.isEmpty()) {
       LookupElement first = model.iterator().next();
-      if (isFocused() && (!(isExactPrefixItem(first, true) || isExactPrefixItem(first, false)) || mySelectionTouched)) {
+      if (isFocused() && (!isExactPrefixItem(first, true) || mySelectionTouched)) {
         restoreSelection(oldSelected, hasPreselected, oldInvariant, snapshot.second);
       }
       else {
---------------
-------------
@@ -40,7 +40,7 @@
     return FileBasedIndex.getInstance().getAllKeys(NAME, project);
   }
 
-  private static final ID<String,Void> NAME = ID.create("XmlTagNames");
+  static final ID<String,Void> NAME = ID.create("XmlTagNames");
 
   @Override
   @NotNull
---------------
-------------
@@ -30,6 +30,7 @@
 
   private VirtualFile findOrCreateTargetDir(String path) throws IOException {
     VirtualFile root = LightPlatformTestCase.getSourceRoot();
+    if (path.length() == 0) return root;
     final String[] dirs = path.split("/");
     for (String dirName : dirs) {
       VirtualFile dir = root.findChild(dirName);
---------------
-------------
@@ -520,7 +520,7 @@
 
     public List<String> getModulePaths(Collection<String> profiles) {
       Set<String> paths = collectAbsoluteModulePaths(profiles);
-      if (myMavenProjectHolder.getSortedProjects() == null) return new ArrayList<String>(paths);
+      if (myMavenProjectHolder.getSortedProjects().isEmpty()) return new ArrayList<String>(paths);
 
       List<String> sorted = new ArrayList<String>();
       for (MavenProject each : myMavenProjectHolder.getSortedProjects()) {
---------------
-------------
@@ -338,7 +338,7 @@
     if (!Character.isLetterOrDigit(text.charAt(i))) {
       return false;
     }
-    if (i > 0 && MinusculeMatcher.isWordSeparator(text.charAt(i - 1))) {
+    if (i > 0 && (MinusculeMatcher.isWordSeparator(text.charAt(i - 1)) || text.charAt(i - 1) == '.')) {
       return true;
     }
     return false;
---------------
-------------
@@ -101,7 +101,7 @@
     if (text == null || text.length() == 0)
       return false;
     final EditorHighlighter highlighter = ((EditorEx) editor).getHighlighter();
-    if (caret < 1 || caret > text.length() - 2) {
+    if (caret < 1 || caret > text.length() - 1) {
       return false;
     }
     HighlighterIterator iterator = highlighter.createIterator(caret - 1);
---------------
-------------
@@ -58,7 +58,7 @@
         if (layerInfo != null) {
             return layerInfo.getResource().prefixedName();
         } else {
-            return groupInfo.getName();
+            return groupInfo.prefixedName();
         }
     }
     
---------------
-------------
@@ -8,7 +8,7 @@
 import org.geotools.feature.type.GeometryDescriptorImpl;
 import org.geotools.feature.type.GeometryTypeImpl;
 import org.geotools.geometry.jts.CurvedGeometry;
-import org.geotools.gml3.MultiCurvedGeometry;
+import org.geotools.geometry.jts.MultiCurvedGeometry;
 import org.opengis.feature.Property;
 import org.opengis.feature.type.AttributeType;
 import org.opengis.feature.type.FeatureType;
---------------
-------------
@@ -132,6 +132,7 @@
         expect(ns.getName()).andReturn(name).anyTimes();
         expect(ns.getPrefix()).andReturn(name).anyTimes();
         expect(ns.getMetadata()).andReturn(new MetadataMap()).anyTimes();
+        expect(ns.getURI()).andReturn(uri).anyTimes();
     
         expect(catalog.getNamespace(nsId)).andReturn(ns).anyTimes();
         expect(catalog.getNamespaceByPrefix(name)).andReturn(ns).anyTimes();
---------------
-------------
@@ -58,7 +58,7 @@
         if (layerInfo != null) {
             return layerInfo.getResource().prefixedName();
         } else {
-            return groupInfo.getName();
+            return groupInfo.prefixedName();
         }
     }
     
---------------
-------------
@@ -75,7 +75,7 @@
             String contactEmail = contact.getContactEmail();
             HashMap<String, String>params = new HashMap<String, String>();
             params.put("version", version);
-            params.put("contactEmail", contactEmail);
+            params.put("contactEmail", (contactEmail == null ? "geoserver@example.org" : contactEmail));
             Label label = new Label("footerMessage", new StringResourceModel("GeoServerHomePage.footer", this, new Model(params)));
             label.setEscapeModelStrings(false);
             add(label);
---------------
-------------
@@ -1262,7 +1262,7 @@
             // GeoServer does not need to be updated to the multicoverage stuff
             // (we might want to introduce a hint later for code that really wants to get the
             // multi-coverage reader)
-            return new SingleGridCoverage2DReader((GridCoverage2DReader) reader, coverageName);
+            return SingleGridCoverage2DReader.wrap((GridCoverage2DReader) reader, coverageName);
         } else {
             return (GridCoverage2DReader) reader;
         }
---------------
-------------
@@ -123,7 +123,7 @@
     }
 
     public String prefixedName() {
-        return prefixedName();
+        return delegate.prefixedName();
     }
 
     public ProjectionPolicy getProjectionPolicy() {
---------------
-------------
@@ -173,7 +173,7 @@
                     layerAtts.addAttribute("", "owsType", "owsType", "", owsType);
                 }
 
-                layerAtts.setAttribute(0, "", "name", "name", "", layer.getName());
+                layerAtts.setAttribute(0, "", "name", "name", "", layer.getLayerInfo().prefixedName());
                 start("LayerDescription", layerAtts);
 
                 queryAtts.setAttribute(0, "", "typeName", "typeName", "", layer.getName());
---------------
-------------
@@ -13,7 +13,7 @@
 /**
  * Class to retrieve the list of fonts available in GeoServer
  *
- * @author Jose Garc�a
+ * @author Jose Garca
  */
 public class FontListResource extends MapResource {
 
---------------
-------------
@@ -132,6 +132,7 @@
         expect(ns.getName()).andReturn(name).anyTimes();
         expect(ns.getPrefix()).andReturn(name).anyTimes();
         expect(ns.getMetadata()).andReturn(new MetadataMap()).anyTimes();
+        expect(ns.getURI()).andReturn(uri).anyTimes();
     
         expect(catalog.getNamespace(nsId)).andReturn(ns).anyTimes();
         expect(catalog.getNamespaceByPrefix(name)).andReturn(ns).anyTimes();
---------------
-------------
@@ -42,7 +42,7 @@
     static {
         try {
             final SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
-            WCS11_SCHEMA = factory.newSchema(new File("./schemas/wcs/1.1.1/wcsAll.xsd"));
+            WCS11_SCHEMA = factory.newSchema(new File("wcs1_1/schemas/wcs/1.1.1/wcsAll.xsd"));
         } catch(Exception e) {
             throw new RuntimeException("Could not parse the WCS 1.1.1 schemas", e);
         }
---------------
-------------
@@ -26,7 +26,7 @@
 				 cloneAndSet(rightNode.array, index,
 					     create(shift, leftHash, leftKey, leftValue)));
 	} else {
-	    final INode newNode = NodeUtils.splice(shift, counts, leftKey, leftValue, 0, null, subNode);
+	    final INode newNode = NodeUtils.splice(shift + 5, counts, leftKey, leftValue, 0, null, subNode);
 	    return newNode == subNode ? 
 		rightNode :
 		new ArrayNode(null,
---------------
-------------
@@ -28,7 +28,7 @@
                                                              leftNode.bitmap,
                                                              leftNode.array,
                                                              PersistentHashMap.mask(rightHash, shift),
-                                                             NodeUtils.promote(shift + 5, leftKey, leftValue)));
+                                                             NodeUtils.promote(shift + 5, rightKey, rightValue)));
             else
                 return new BitmapIndexedNode(null,
                                              leftNode.bitmap | bit,
---------------
-------------
@@ -137,7 +137,7 @@
   }
 
   static <T> boolean isPrimitive(AvroType<T> avroType) {
-    return PRIMITIVES.containsKey(avroType.getTypeClass());
+    return avroType.getTypeClass().isPrimitive() || PRIMITIVES.containsKey(avroType.getTypeClass());
   }
 
   private static <T> AvroType<T> create(Class<T> clazz, Schema.Type schemaType) {
---------------
-------------
@@ -71,7 +71,7 @@
             LOG.debug("Save new topic.");
             topicDto.setCreatedTime(System.currentTimeMillis());
             List topicsByAppIdAndName = topicDao.findTopicsByAppIdAndName(topicDto.getApplicationId(), topicDto.getName());
-            if(topicsByAppIdAndName.isEmpty()){
+            if(!topicsByAppIdAndName.isEmpty()){
                 throw new IllegalArgumentException("Topic with the same name already present!");
             }
         }
---------------
-------------
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2014-2015 CyberVision, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package org.kaaproject.kaa.server.common.dao;
 
 public class DaoConstants {
---------------
-------------
@@ -104,7 +104,7 @@
      * @param e the exception causing the failure
      */
     protected void logUnableToInitializeAntBuilder(final Throwable e) {
-        getLog().error("Unable to initialize 'ant' with a new AntBuilder object.  Is Ant a dependency?", e);
+        getLog().error("Unable to initialize 'ant' with a new AntBuilder object.  Is Groovy a dependency?  If you are using Groovy >= 2.3.0-rc-1, remember to include groovy-ant as a dependency.", e);
     }
 
 }
---------------
-------------
@@ -116,7 +116,7 @@
 
   } */
 
-  @Test
+  // @Test
   public void problem() throws IOException {
     String filename = "conventions/coards/inittest24.QRIDV07200.ncml";
     String dodsUrl = TestWithLocalServer.server + path + filename;
---------------
-------------
@@ -286,8 +286,8 @@
    * @see InvCatalog#findDatasetByID
    */
   public void addDatasetByID(InvDatasetImpl ds) {
-    if (ds.getID() != null && ds.getID().startsWith("null"))
-      System.out.printf("HEY addDatasetByID %s%n", ds.getID());
+    //if (ds.getID() != null && ds.getID().startsWith("null"))
+    //  System.out.printf("HEY addDatasetByID %s%n", ds.getID());
 
     if (ds.getID() != null)
       dsHash.put(ds.getID(), ds);
---------------
-------------
@@ -41,7 +41,7 @@
 		// XXX: dropping exceptions
 	}
 }
-protected boolean visit(IResourceDelta change) throws CoreException {
+protected boolean visit(IResourceDelta change) {
 	System.out.println(((ResourceDelta) change).toDebugString());
 	return true;
 }
---------------
-------------
@@ -64,6 +64,7 @@
 				try {
 					Thread.sleep(tickLength);
 				} catch (InterruptedException e) {
+					//ignore
 				}
 				monitor.worked(1);
 			}
---------------
-------------
@@ -114,7 +114,7 @@
 		ArrayList<Pair> list = new ArrayList<Pair>(map.size());
 		for (Object key : map.keySet()) {
 			String name = null == key ? "null" : key.toString();
-			Object value = map.get(name);
+			Object value = map.get(key);
 			if (!this.isIgnore(name, value))
 				list.add(new Pair(name, value));
 		}
---------------
-------------
@@ -31,7 +31,7 @@
 
   private static final String ROLE = "HIVE";
   private static final String NAME = "hive";
-  private static final String EXTERNAL_PATH = "/hive/api/vi";
+  private static final String EXTERNAL_PATH = "/hive/api/v1";
 
   @Override
   public String getRole() {
---------------
-------------
@@ -145,7 +145,6 @@
           }
           if (groupsMapped) {
             addMappedGroupsToSubject(mappedPrincipalName, groups, subject);
-            addMappedGroupsToSubject("*", groups, subject);
           }
           doAs(request, response, chain, subject);
         }
---------------
-------------
@@ -25,7 +25,6 @@
 import java.io.IOException;
 import java.util.zip.ZipFile;
 
-import org.apache.derby.iapi.services.info.JVMInfo;
 import org.apache.derby.io.StorageFile;
 
 /**
---------------
-------------
@@ -31,12 +31,9 @@
  * Create and boot the supplied db argument. This auxiliary program is used by
  * {@code BootLockTest.java} to boot a db in a different jvm and subsequently
  * attempt a boot to from the original VM to detect dual boot attempt.
-* <p>
- * You can verify this subprogram by invoking it directly as:
- * </p>
- * <p>
- * {@code java org.apache.derbyTesting.functionTests.tests.store.BootLockMinion <dbname>}
- * </p>
+ * <p/>
+ * Started as:
+ * {@code java org.apache.derbyTesting.functionTests.tests.store.BootLockMinion <dbname> <port>}
  */
 
 public class BootLockMinion {
---------------
-------------
@@ -162,9 +162,6 @@
      *      using initCause().  On JDK 1.3, since initCause() does not exist,
      *      a non-SQL exception can not be chained.  Instead, the exception class
      *      and message text is appended to the message for this exception.
-     *
-     * @return 
-     *      An instance of SqlException that you can throw to your heart's content.
      */
     public SqlException(LogWriter logwriter, 
         ClientMessageId msgid, Object[] args, Throwable cause)
---------------
-------------
@@ -226,7 +226,7 @@
         suite.addTest(HalfCreatedDatabaseTest.suite());
         suite.addTest(NativeAuthenticationServiceTest.suite());
         suite.addTest(Derby5652.suite());
-        //suite.addTest(TruncateTableAndOnlineBackupTest.suite()); 
+        suite.addTest(TruncateTableAndOnlineBackupTest.suite()); 
         return suite;
 	}
 }
---------------
-------------
@@ -47,7 +47,7 @@
         TestSuite suite = new TestSuite("JUnit unit tests");
 
         suite.addTest(FormatableBitSetTest.suite());
-        //suite.addTest(SystemPrivilegesPermissionTest.suite());
+        suite.addTest(SystemPrivilegesPermissionTest.suite());
         suite.addTest(UTF8UtilTest.suite());
 
         return suite;
---------------
-------------
@@ -150,6 +150,7 @@
 					throw EmbedResultSet.noStateChangeException(e);
 				}
 				finally {
+					results.close();
 					results = null;
 				}
 
---------------
-------------
@@ -123,6 +123,7 @@
         suite.addTest(SynonymTest.suite());
         suite.addTest(CommentTest.suite());
         suite.addTest(NestedWhereSubqueryTest.suite());
+        suite.addTest(ConglomerateSharingTest.suite());
 
         // Add the XML tests, which exist as a separate suite
         // so that users can "run all XML tests" easily.
---------------
-------------
@@ -183,6 +183,8 @@
         }
 
         jvmProps.addElement("derby.system.home=" + homeDirName);
+		jvmProps.addElement("user.language=en");
+		jvmProps.addElement("user.country=US");
 		jvm.setD(jvmProps);
 		jvm.setSecurityProps();
         // For some platforms (like Mac) the process exec command
---------------
-------------
@@ -4839,6 +4839,11 @@
             default:
                 return false;
             }
+        } else if (resultSetMetaData_.hasLobColumns()) {
+            // DERBY-6737: If the result set has LOB columns, we cannot use
+            // the cached locator since it might have been released, so
+            // always fetch the row from the server.
+            return false;
         } else {
             return rowIsInCurrentRowset(rowNumber);
         }
---------------
-------------
@@ -161,7 +161,7 @@
     boolean isUpdateColumn(String columnName);
 
 	/**
-	 * set this parepared statement to be valid
+	 * set this prepared statement to be valid
 	 */
 	void setValid();
 
---------------
-------------
@@ -82,7 +82,7 @@
     public void writeExternal(ObjectOutput out) throws IOException
     {
         // first write the version id
-        out.writeInt( FIRST_VERSION );
+        out.writeInt( TIMESTAMPED_VERSION );
 
         // now write the state
         out.writeObject( currencyCode );
---------------
-------------
@@ -63,6 +63,7 @@
 		suite.addTest(StreamTest.suite());
                 suite.addTest(ParameterMappingTest.suite());
 		suite.addTest(DboPowersTest.suite());
+                suite.addTest(CallableTest.suite());
         
         // Old harness .java tests that run using the HarnessJavaTest
         // adapter and continue to use a single master file.
---------------
-------------
@@ -60,6 +60,10 @@
         suite.addTest(OfflineBackupTest.suite());
         suite.addTest(LiveLockTest.suite());
         suite.addTest(ClobReclamationTest.suite());
+
+        // Disabled until DERBY-2991 has been fixed
+        //suite.addTest(IndexSplitDeadlockTest.suite());
+
         // Encryption only supported for Derby in J2SE/J2EE environments.
         // J2ME (JSR169) does not support encryption.
         if (JDBC.vmSupportsJDBC3()) {
---------------
-------------
@@ -58,6 +58,7 @@
         suite.addTest(OSReadOnlyTest.suite());
         suite.addTest(BackupRestoreTest.suite());
         suite.addTest(OfflineBackupTest.suite());
+        suite.addTest(LiveLockTest.suite());
         // Encryption only supported for Derby in J2SE/J2EE environments.
         // J2ME (JSR169) does not support encryption.
         if (JDBC.vmSupportsJDBC3()) {
---------------
-------------
@@ -51,6 +51,7 @@
 
         TestSuite suite = new TestSuite("management");
 
+        suite.addTest(JMXTest.suite());
         suite.addTest(ManagementMBeanTest.suite());
         suite.addTest(VersionMBeanTest.suite());
         
---------------
-------------
@@ -1638,6 +1638,8 @@
                 SYSCS_GET_DATABASE_PROPERTY(Property.DEFAULT_CONNECTION_MODE_PROPERTY);
             if (defaultAccess != null)
                 defaultAccess = StringUtil.SQLToUpperCase(defaultAccess);
+            else
+                defaultAccess = Property.FULL_ACCESS; // is the default.
             
             return defaultAccess;
             
---------------
-------------
@@ -120,6 +120,7 @@
         suite.addTest(Bug5052rtsTest.suite());
         suite.addTest(Bug5054Test.suite());
         suite.addTest(Bug4356Test.suite());
+        suite.addTest(SynonymTest.suite());
 
         // Add the XML tests, which exist as a separate suite
         // so that users can "run all XML tests" easily.
---------------
-------------
@@ -149,6 +149,7 @@
             else
                 suite.addTest(LDAPAuthenticationTest.suite());
             suite.addTest(InvalidLDAPServerAuthenticationTest.suite());
+            suite.addTest(XAJNDITest.suite());
         }
 
         return suite;
---------------
-------------
@@ -608,6 +608,9 @@
 
         // Reset the current schema (see DERBY-3690).
         setDefaultSchema(null);
+
+		// Reset the current role
+		getCurrentSQLSessionContext().setRole(null);
 	}
 
 	/**
---------------
-------------
@@ -508,6 +508,10 @@
 
             for (int i = 0; i < row.length; i++)
             {
+            	//DERBY-5531 If the row column's value is null, then 
+            	// don't worry about the data type match.
+            	if (row[i].isNull())
+            		continue;
                 // Compare class's rather than format id's to pick up 
                 // different problems with wrong collation implementation.
 				if (!row[i].getClass().equals(template[i].getClass()))
---------------
-------------
@@ -1000,7 +1000,7 @@
 																	 getNodeFactory().doJoinOrderOptimization(),
 																	 getContextManager());
 			bindExpressions(afromList);
-            bindResultColumns(afromList);
+            fromList.bindResultColumns(afromList);
 		}
 
 		/* Preprocess the fromList.  For each FromTable, if it is a FromSubquery
---------------
-------------
@@ -331,6 +331,7 @@
         if (prop instanceof ArrayProperty) {
             Object[] ar = (Object[]) prop.getValue();
             if (ar == null) {
+                jg.writeEndArray();
                 return;
             }
             org.nuxeo.ecm.core.schema.types.Type type = ((ListType) prop.getType()).getFieldType();
---------------
-------------
@@ -36,7 +36,7 @@
     @FindBy(xpath = "//img[@title=\"Add to worklist\"]")
     public WebElement addToWorklistButton;
 
-    @FindBy(name = "documentActionsUpperButtons:permalinkAction_link")
+    @FindBy(xpath = "//img[@title=\"Permanent link to this document\"]")
     public WebElement permaButton;
 
     @FindBy(id = "fancybox-overlay")
---------------
-------------
@@ -123,7 +123,7 @@
                 continue;
             }
             if (prevLine != null) {
-                line = prevLine + line;
+                line = prevLine + "\n" + line;
             }
             prevLine = null;
             setPropertyLine(map, line);
---------------
-------------
@@ -12,7 +12,7 @@
 @Deploy({ "org.nuxeo.ecm.platform.url.core", "org.nuxeo.ecm.relations.api", "org.nuxeo.ecm.relations",
         "org.nuxeo.ecm.relations.jena", "org.nuxeo.ecm.platform.types.api", "org.nuxeo.ecm.platform.types.core",
         "org.nuxeo.ecm.annotations", "org.nuxeo.ecm.annotations.contrib", "org.nuxeo.ecm.annotations.repository",
-        "org.nuxeo.ecm.annotations.repository.test" })
+        "org.nuxeo.ecm.annotations.repository.test", "org.nuxeo.runtime.jtajca", "org.nuxeo.runtime.datasource" })
 @LocalDeploy({ "org.nuxeo.runtime.datasource:anno-ds.xml" })
 public class AnnotationFeature extends SimpleFeature {
 
---------------
-------------
@@ -268,7 +268,7 @@
         List<DocumentModel> result = new ArrayList<DocumentModel>();
         CollectionMember collectionMemberAdapter = collectionMember.getAdapter(CollectionMember.class);
         List<String> collectionIds = collectionMemberAdapter.getCollectionIds();
-        for (int i = 0; i < collectionIds.size() && i < maxResult; i++) {
+        for (int i = 0; i < collectionIds.size() && result.size() < maxResult; i++) {
             final String collectionId = collectionIds.get(i);
             DocumentRef documentRef = new IdRef(collectionId);
             if (session.exists(documentRef)
---------------
-------------
@@ -76,6 +76,7 @@
                 "org.nuxeo.ecm.sql.jena.databaseTransactionEnabled", "false");
         deployBundle("org.nuxeo.ecm.core");
         deployBundle("org.nuxeo.ecm.relations");
+        deployBundle("org.nuxeo.ecm.annotations.contrib");
         deployBundle("org.nuxeo.ecm.annotations");
         deployBundle("org.nuxeo.ecm.annotations.repository");
         deployBundle("org.nuxeo.ecm.platform.url.core");
---------------
-------------
@@ -69,7 +69,7 @@
 
     @Path("/automation")
     public Object getAutomationEndPoint() throws Exception {
-        return new AutomationResource();
+        return newObject("automation");
     }
 
     @Path("/directory")
---------------
-------------
@@ -73,7 +73,7 @@
 
     public boolean workflowAlreadyStarted() {
           return findElementWithTimeout(
-                By.xpath("//form[@id='nxl_grid_summary_layout:nxw_summary_document_route_form']")).getText().contains("review has been started");
+                By.xpath("//*[@id='nxl_grid_summary_layout:nxw_summary_document_route_form']")).getText().contains("review has been started");
     }
 
     public boolean openTaskForCurrentUser() {
---------------
-------------
@@ -11,7 +11,7 @@
     ZERO(Opcodes.DCONST_0),
     ONE(Opcodes.DCONST_1);
 
-    private static final StackManipulation.Size SIZE = StackSize.SINGLE.toIncreasingSize();
+    private static final StackManipulation.Size SIZE = StackSize.DOUBLE.toIncreasingSize();
 
     private static class ConstantPool implements StackManipulation {
 
---------------
-------------
@@ -97,7 +97,7 @@
                     Assigner.DEFAULT,
                     Assigner.STATICALLY_TYPED);
         } else if (type == Class.class) {
-            return new ForPoolValue(ClassConstant.of(new TypeDescription.ForLoadedType(type)),
+            return new ForPoolValue(ClassConstant.of(new TypeDescription.ForLoadedType((Class<?>) fixedValue)),
                     TypeDescription.CLASS,
                     Assigner.DEFAULT,
                     Assigner.STATICALLY_TYPED);
---------------
-------------
@@ -31,7 +31,7 @@
 	 * 
 	 * @see XBee64BitAddress
 	 */
-	public RemoteRaw802Device(DigiMeshDevice localXBeeDevice, XBee64BitAddress xbee64BitAddress) {
+	public RemoteRaw802Device(Raw802Device localXBeeDevice, XBee64BitAddress xbee64BitAddress) {
 		super(localXBeeDevice, xbee64BitAddress);
 	}
 	
---------------
-------------
@@ -56,7 +56,7 @@
     Pipe pipe = new Each( previous, argumentFieldSelector, new Identity( new Fields( "n", "l", "v" ) ) );
 
     // name and rate against others of same movie
-    pipe = new Group( pipe, new Fields( "l" ), 2, new Fields( "n1", "l", "v1", "n2", "l2", "v2" ) );
+    pipe = new Group( pipe, new Fields( "l" ), 1, new Fields( "n1", "l", "v1", "n2", "l2", "v2" ) );
 
     // remove useless fields
     pipe = new Each( pipe, new Fields( "l", "n1", "v1", "n2", "v2" ), new Identity() );
---------------
-------------
@@ -262,7 +262,7 @@
 
       LOG.debug( "handling path: {}", stringPath );
 
-      URI uri = new URI( stringPath );
+      URI uri = new Path( stringPath ).toUri(); // safer URI parsing
       String schemeString = uri.getScheme();
       String authority = uri.getAuthority();
 
---------------
-------------
@@ -47,7 +47,7 @@
     criteria.upperNick().equal(nick.toUpperCase());
     criteria.channel().equal(channel);
     Logs logs = criteria.query().get();
-    return new Seen(logs.getChannel(), logs.getMessage(), logs.getNick(), logs.getUpdated());
+    return logs != null ? new Seen(logs.getChannel(), logs.getMessage(), logs.getNick(), logs.getUpdated()) : null;
   }
 
 }
\ No newline at end of file
---------------
-------------
@@ -39,7 +39,7 @@
                         + " optional.  if not given all packages found will be documented"));
             }
         }
-        if (args.size() == 2 || existing) {
+        if (args.size() >= 2 || existing) {
             final String name = args.remove(0);
             Api api = dao.find(name);
             if (existing && api != null) {
---------------
-------------
@@ -100,7 +100,7 @@
   }
 
   @Override
-  protected void onNotice(final String sourceNick, final String sourceLogin, final String sourceHostname,
+  public void onNotice(final String sourceNick, final String sourceLogin, final String sourceHostname,
       final String target, final String notice) {
     super.onNotice(sourceNick, sourceLogin, sourceHostname, target, notice);
     if (sourceNick.equalsIgnoreCase("NickServ")) {
---------------
-------------
@@ -117,7 +117,7 @@
                         responses.add(new Message(channel, event, "I'm afraid I can't let you do that, Dave."));
                     } else {
                         final List<Message> list = getBot()
-                            .getResponses(channel, sender, event.getLogin(), event.getHostname(), thing);
+                            .getResponses(channel, nick, event.getLogin(), event.getHostname(), thing);
                         for (Message msg : list) {
                             responses.add(new TellMessage(nick, msg.getDestination(), msg.getEvent(), msg.getMessage()));
                         }
---------------
-------------
@@ -33,7 +33,7 @@
     }
 
     public boolean isSeen(String nick, String channel) {
-        return getSeen(nick, channel).getNick() != null;
+        return getSeen(nick, channel) != null;
     }
 
     public Seen getSeen(String nick, String channel) {
---------------
-------------
@@ -47,7 +47,7 @@
         }
     }
 
-    @Test(groups = {"operations"}, dependsOnMethods = {"testOperation"})
+    @Test(groups = {"operations"}, dependsOnMethods = {"addFactoid"})
     public void removeFactoid() {
         for(Database database : getDatabases()) {
             String key = "remove factoid";
---------------
-------------
@@ -15,7 +15,7 @@
 
 		output = output + "\\includegraphics";
 
-		Pattern label = Pattern.compile("(?s)(?i)label=(\\w+)?");
+		Pattern label = Pattern.compile("(?s)(?i)label=(\\S+)?");
 		Matcher labelMatcher = label.matcher(options);
 
 		Pattern description = Pattern.compile("(?s)(?i)\"(.+?)\"");
---------------
-------------
@@ -9,6 +9,7 @@
 
 public class ImageTag implements Tag {
 
+	// TODO: make it work more gracefully... i.e., eliminate this workaround
 	private static final String RELATIVEPATH = "$$RELATIVE$$/";
 
 	public String parse(final String path, final String options) {
---------------
-------------
@@ -58,7 +58,7 @@
         for (Reader reader: introductionReaders) {
             Scanner scanner = new Scanner(reader);
             scanner.useDelimiter("$$");
-            introductionChapters = parseChapters(scanner.next());
+            introductionChapters.addAll(parseChapters(scanner.next()));
         }
         return introductionChapters;
     }
---------------
-------------
@@ -98,6 +98,7 @@
 			if (current == '<' && i < text.length() - 2) {
 				String next = text.substring(i + 1, i + 3);
 				if (next.equals("::")) {
+					sane.append(current);
 					continue;
 				}
 			}
---------------
-------------
@@ -163,7 +163,7 @@
 						.create(getShortName());
 		}
 	},
-	IFDEFS('d', "ifdef", "Defines boolean variables avaiable to freemarker templates") {
+	IFDEFS('e', "ifdef", "Defines boolean variables avaiable to freemarker templates") {
         @Override
         public void configure(TubainaBuilder builder, CommandLine cmd) {
             String[] optionValues = cmd.getOptionValues(getShortName());
---------------
-------------
@@ -23,7 +23,7 @@
 		return parseLatex(text, highlights, 1);
 	}
 	public String parseLatex(String text, List<Integer> highlights, int start) {
-		return parse(text, highlights, start, "{\\bf ", "}");
+		return parse(text, highlights, start, "\\colorbox{yellow}{", "}\\");
 	}
 	public String parse(String text, List<Integer> highlights, int start, String openTag, String closeTag) {
 		if (highlights == null) {
---------------
-------------
@@ -72,7 +72,7 @@
 		CodeHighlightTag codeHighlightTag = new CodeHighlightTag();
 		List<Integer> highlights = codeHighlightTag.getHighlights(options);
 		String toProcess = this.parseSpaces(this.indentator.indent(code));
-		output = codeHighlightTag.parseHtml(output, highlights);
+		toProcess = codeHighlightTag.parseHtml(toProcess, highlights);
 		while (!toProcess.isEmpty()) {
 			toProcess = processNextElement(toProcess);
 		}
---------------
-------------
@@ -35,7 +35,6 @@
     public String parse(String string) {
         // TODO: remove eventual $1, $2 from the string so as not to be
         // interpreted
-
         string = new EscapeTag().parse(string, null);
         for (Tag tag : tags) {
             string = tag.parse(string, null);
---------------
-------------
@@ -51,7 +51,7 @@
     }
 
     private String latexFilenameFor(String filename) {
-        return filename.isEmpty() ? "" : FILE_NAME + "{src/Main.java}\n";
+        return filename.isEmpty() ? "" : FILE_NAME + "{" + filename + "}\n";
     }
 
     private String matchFilename(String options, StringBuilder filenameBuilder) {
---------------
-------------
@@ -21,7 +21,7 @@
 
 class GroovycTest2 {
     static void main(String[] args) throws IOException {
-        File f = new File("build/test-classes/org/codehaus/groovy/ant/GroovycTest2_Result.txt");
+        File f = new File("build/classes/test/org/codehaus/groovy/ant/GroovycTest2_Result.txt");
         FileOutputStream fout = new FileOutputStream(f);
         try {
             fout.write("OK.".getBytes());
---------------
-------------
@@ -129,7 +129,9 @@
      */
     public void exec(String source, int lineNo, int columnNo, Object script) throws BSFException {
         try {
-            shell.run(script.toString(), source, EMPTY_ARGS);
+            // use evaluate to pass in the BSF variables
+            shell.evaluate(script.toString(), source);
+            //shell.run(script.toString(), source, EMPTY_ARGS);
         }
         catch (Exception e) {
             e.printStackTrace();
---------------
-------------
@@ -59,7 +59,7 @@
         suite.addTestSuite(FileSystemCompilerTest.class);
         suite.addTestSuite(ForTest.class);
         suite.addTestSuite(GetPropertyTest.class);
-        suite.addTestSuite(GroovyTest.class);
+        suite.addTest(GroovyTest.suite());
         suite.addTestSuite(GroovycTest.class);
         suite.addTestSuite(GroovyClassLoaderTest.class);
         suite.addTestSuite(GroovyDocToolTest.class);
---------------
-------------
@@ -361,7 +361,7 @@
     public boolean implementsInteface(String name) {
         ClassNode node = this;
         do {
-            if (declaresInterface(name)) {
+            if (node.declaresInterface(name)) {
                 return true;
             }
             node = node.getSuperClassNode();
---------------
-------------
@@ -53,7 +53,7 @@
 
   public void leave(ActivityExecution execution) {
     CompensationUtil.createEventScopeExecution((ExecutionEntity) execution);
-    bpmnActivityBehavior.performDefaultOutgoingBehavior(execution);
+    super.leave(execution);
   }
 
 }
---------------
-------------
@@ -71,6 +71,8 @@
         if (defaultSequenceFlow != null) {
           PvmTransition defaultTransition = execution.getActivity().findOutgoingTransition(defaultSequenceFlow);
           if (defaultTransition != null) {
+            // since this execution is the only foregoing, it has to be reactivated
+            execution.setActive(true);
             execution.take(defaultTransition);
           } else {
             throw new ProcessEngineException("Default sequence flow '" + defaultSequenceFlow + "' could not be not found");
---------------
-------------
@@ -159,7 +159,7 @@
     for (AbstractDataAssociation dataOutputAssociation : dataOutputAssociations) {
       Object value = null;
         if (dataOutputAssociation.getVariables() != null) {
-          Map<String, Object> variables = execution.getVariables();
+          Map<String, Object> variables = subProcessInstance.getVariables();
           if (variables != null && !variables.isEmpty()) {
             execution.setVariables(subProcessInstance.getVariables());
           }
---------------
-------------
@@ -85,7 +85,7 @@
 
   public void parseProcess(Element processElement, ProcessDefinitionEntity processDefinition) {
     if (historyLevel.isHistoryEventProduced(HistoryEventTypes.PROCESS_INSTANCE_END, null)) {
-      processDefinition.addExecutionListener(PvmEvent.EVENTNAME_END, PROCESS_INSTANCE_END_LISTENER);
+      processDefinition.addBuiltInListener(PvmEvent.EVENTNAME_END, PROCESS_INSTANCE_END_LISTENER);
     }
   }
 
---------------
-------------
@@ -148,7 +148,8 @@
    */
   public static URI urlToURI(URL url) {
     try {
-      return new URI(url.getProtocol(), url.getAuthority(), url.getPath(), url.getQuery(), null);
+      //return new URI(url.getProtocol(), url.getAuthority(), url.getPath(), url.getQuery(), null);
+      return new URI(url.getProtocol(), url.getPath(), null);
     } catch (URISyntaxException e) {
       throw new ProcessEngineException("couldn't convert URL to URI " + url, e);
     }
---------------
-------------
@@ -39,6 +39,7 @@
                                      @QueryParam("maxResults") Integer maxResults);
 
   @POST
+  @Path("/create")
   @Consumes(MediaType.MULTIPART_FORM_DATA)
   @Produces(MediaType.APPLICATION_JSON)
   DeploymentDto createDeployment(@Context UriInfo uriInfo, MultipartFormData multipartFormData);
---------------
-------------
@@ -378,7 +378,7 @@
   public void stopTask() {
     assertCommandContextNotActive();
     assertTaskAssociated();
-    associationManager.setTask(null);
+    associationManager.disAssociate();
   }
 
   /**
---------------
-------------
@@ -188,6 +188,7 @@
   }
 
   public void parseTransaction(Element transactionElement, ScopeImpl scope, ActivityImpl activity) {
+    addActivityHandlers(activity);
   }
 
   public void parseCompensateEventDefinition(Element compensateEventDefinition, ActivityImpl compensationActivity) {
---------------
-------------
@@ -35,6 +35,7 @@
     if(activity != null) {
       activity.addBuiltInListener(CaseExecutionListener.START, listener);
       activity.addBuiltInListener(CaseExecutionListener.MANUAL_START, listener);
+      activity.addBuiltInListener(CaseExecutionListener.OCCUR, listener);
     }
   }
 
---------------
-------------
@@ -42,8 +42,9 @@
     ExecutionEntity topmostCancellableExecution = sourceInstanceExecution;
     ExecutionEntity parentScopeExecution = (ExecutionEntity) topmostCancellableExecution.getParentScopeExecution(false);
 
-    // if topmostCancellabelExecution's parent is concurrent, we have reached the target execution
-    while (parentScopeExecution != null && !topmostCancellableExecution.isConcurrent() && !topmostCancellableExecution.getParent().isConcurrent()) {
+    // if topmostCancellableExecution's scope execution has no other non-event-scope children,
+    // we have reached the correct execution
+    while (parentScopeExecution != null && (parentScopeExecution.getNonEventScopeExecutions().size() <= 1)) {
       topmostCancellableExecution = parentScopeExecution;
       parentScopeExecution = (ExecutionEntity) topmostCancellableExecution.getParentScopeExecution(false);
     }
---------------
-------------
@@ -230,7 +230,7 @@
       timer.schedule(task, maxMillisToWait);
       boolean conditionIsViolated = true;
       try {
-        while (conditionIsViolated) {
+        while (conditionIsViolated && !task.isTimeLimitExceeded()) {
           Thread.sleep(intervalMillis);
           conditionIsViolated = !condition.call();
         }
---------------
-------------
@@ -483,7 +483,7 @@
     return getProcessEngine().getRuntimeService()
       .createVariableInstanceQuery()
       .disableBinaryFetching()
-      .disableObjectValueDeserialization()
+      .disableCustomObjectDeserialization()
       .variableNameIn(variableNames.toArray(new String[variableNames.size()]))
       .variableScopeIdIn(variableScopeIds.toArray(new String[variableScopeIds.size()]))
       .list();
---------------
-------------
@@ -137,6 +137,7 @@
 
   public Object getPersistentState() {
     Map<String, Object> persistentState = new HashMap<String, Object>();
+    persistentState.put("executionId", executionId);
     persistentState.put("lockOwner", lockOwner);
     persistentState.put("lockExpirationTime", lockExpirationTime);
     persistentState.put("retries", retries);
---------------
-------------
@@ -106,7 +106,7 @@
     PvmActivity activity = execution.getActivity();
     if (execution.isConcurrent()) {
       for (ActivityExecution concurrentExecution : getLeaveExecutions(execution.getParent())) {
-        if (concurrentExecution.isActive() && concurrentExecution.getActivity() != activity) {
+        if (concurrentExecution.isActive()) {
 
           // TODO: when is transitionBeingTaken cleared? Should we clear it?
           boolean reachable = false;
---------------
-------------
@@ -72,7 +72,7 @@
     ActivityInstance activityInstance = null;
     
     try {
-      activityInstance = runtimeService.getProcessInstance(processInstanceId);
+      activityInstance = runtimeService.getActivityInstance(processInstanceId);
     } catch (ProcessEngineException e) {
       throw new InvalidRequestException(Status.INTERNAL_SERVER_ERROR, e, e.getMessage());
     }
---------------
-------------
@@ -148,7 +148,7 @@
     addDatabaseSpecificStatement(POSTGRES, "selectFilter", "selectFilter_postgres");
     addDatabaseSpecificStatement(POSTGRES, "selectFilterByQueryCriteria", "selectFilterByQueryCriteria_postgres");
     addDatabaseSpecificStatement(POSTGRES, "selectCaseSentryPartsByQueryCriteria", "selectCaseSentryPartsByQueryCriteria_postgres");
-    addDatabaseSpecificStatement(POSTGRES, "selectCaseSentryPartsCountByQueryCriteria", "selectCaseSentryPartsCountByQueryCriteria_postges");
+    addDatabaseSpecificStatement(POSTGRES, "selectCaseSentryPartsCountByQueryCriteria", "selectCaseSentryPartsCountByQueryCriteria_postgres");
 
     constants = new HashMap<String, String>();
     constants.put("constant.event", "'event'");
---------------
-------------
@@ -145,7 +145,7 @@
   }
 
   protected URL lookupBpmPlatformXmlLocationFromJndi() {
-    String jndi = "java:/comp/env/" + BPM_PLATFORM_XML_LOCATION;
+    String jndi = "java:comp/env/" + BPM_PLATFORM_XML_LOCATION;
 
     try {
       String bpmPlatformXmlLocation = InitialContext.doLookup(jndi);
---------------
-------------
@@ -2247,6 +2247,8 @@
       // scope of the boundary event is the parent of the activity to which it is attached.
       nestedActivity.setScope(parentActivity.getParentScope());
       nestedActivity.setActivityBehavior(behavior);
+
+      parseExecutionListenersOnScope(boundaryEventElement, nestedActivity);
     }
   }
 
---------------
-------------
@@ -104,7 +104,7 @@
     try {
       List<VirtualFile> processes = processArchiveRoot.getChildrenRecursively(new VirtualFileFilter() {
         public boolean accepts(VirtualFile file) {
-          return ProcessApplicationScanningUtil.isDeployable(file.getName());
+          return file.isFile() && ProcessApplicationScanningUtil.isDeployable(file.getName());
         }
       });
       for (final VirtualFile process : processes) {
---------------
-------------
@@ -35,7 +35,7 @@
   /** Only select executions which have the given process instance id. **/
   ExecutionQuery processInstanceId(String processInstanceId);
   
-  /** Only executions with the given business key */
+  /** Only select executions that belong to a process instance with the given business key */
   ExecutionQuery processInstanceBusinessKey(String processInstanceBusinessKey);
 
   /** Only select executions with the given id. **/
---------------
-------------
@@ -58,7 +58,7 @@
         throw new PvmException("couldn't execute event listener : "+e.getMessage(), e);
       }
       execution.setListenerIndex(executionListenerIndex + 1);
-      execution.performOperation(this);
+      execution.performOperationSync(this);
 
     } else {
       log.fine(execution+" takes transition "+transition);
---------------
-------------
@@ -1088,7 +1088,7 @@
       dbSchemaUpdate();
     }
     
-    checkHistoryLevel();
+//    checkHistoryLevel();
   }
 
   public void performSchemaOperationsProcessEngineClose() {
---------------
-------------
@@ -51,6 +51,7 @@
     processInstanceId = te.processInstanceId;
     jobDefinitionId = te.jobDefinitionId;
     suspensionState = te.suspensionState;
+    deploymentId = te.deploymentId;
   }
 
   @Override
---------------
-------------
@@ -394,6 +394,8 @@
     variableInstance.setTaskId(id);
     variableInstance.setExecutionId(executionId);
     variableInstance.setProcessInstanceId(processInstanceId);
+    variableInstance.setCaseExecutionId(caseExecutionId);
+    variableInstance.setCaseInstanceId(caseInstanceId);
   }
 
   protected List<VariableInstanceEntity> loadVariableInstances() {
---------------
-------------
@@ -2928,7 +2928,7 @@
     }
 
     CallActivityBehavior callActivityBehaviour = null;
-    String expressionRegex = "\\$+\\{+.+\\}";
+    String expressionRegex = "[$#]+\\{+.+\\}";
     if (calledElement != null && calledElement.matches(expressionRegex)) {
       if (calledElementBinding == null) {
         callActivityBehaviour = new CallActivityBehavior(expressionManager.createExpression(calledElement));
---------------
-------------
@@ -129,7 +129,7 @@
     }
 
     // switch all jobs to the new process definition version
-    List<JobEntity> jobs = commandContext.getJobManager().findJobsByExecutionId(processInstanceId);
+    List<JobEntity> jobs = commandContext.getJobManager().findJobsByProcessInstanceId(processInstanceId);
     List<JobDefinitionEntity> currentJobDefinitions =
         commandContext.getJobDefinitionManager().findByProcessDefinitionId(currentProcessDefinition.getId());
     List<JobDefinitionEntity> newVersionJobDefinitions =
---------------
-------------
@@ -50,7 +50,7 @@
       if (superExecution != null) {
         executeCatchInSuperProcess(superExecution);
       } else {
-        // TODO Shouldn't this be an exception as in executeCatchInSuperProcess()?
+        // TODO Shouldn't this be an exception as in executeCatchInSuperProcess() or is this dead code?
         LOG.info(execution.getActivity().getId() + " throws error event with errorCode '"
                 + errorCode + "', but no catching boundary event was defined. "
                 +   "Execution will simply be ended (none end event semantics).");
---------------
-------------
@@ -741,7 +741,7 @@
         }
 
         // the host and port the message came from
-        this.ourAddressAndPort.writeMarshallable(out);
+        ourAddressAndPort.writeMarshallable(out);
 
         remoteNode.writeMarshallable(out);
 
---------------
-------------
@@ -29,7 +29,7 @@
 	private final SimpleDateFormat iso8601Format;
 
 	public DateGsonConverter() {
-		this.iso8601Format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
+		this.iso8601Format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss Z");
 	}
 	
 	@Override
---------------
-------------
@@ -62,7 +62,7 @@
 
 	@Override
 	public boolean supports(String feature) {
-		return Boolean.parseBoolean(get(feature));
+		return Boolean.parseBoolean(get(feature).trim());
 	}
 
 	@Override
---------------
-------------
@@ -72,7 +72,7 @@
 	}
 	
 	@PostConstruct
-	public void setup() {
+	protected void setup() {
 		loadProperties();
 	}
 	
---------------
-------------
@@ -62,7 +62,7 @@
 
 	@Override
 	public boolean supports(String feature) {
-		return Boolean.parseBoolean(get(feature));
+		return Boolean.parseBoolean(get(feature).trim());
 	}
 
 	@Override
---------------
-------------
@@ -154,7 +154,7 @@
 				
 				CtMethod method = CtNewMethod.abstractMethod(returnType, name, m.getParameterTypes(), new CtClass[0], inter);
 				inter.addMethod(method);
-				CtMethod getter = CtNewMethod.make(String.format("abstract String get%s();", StringUtils.capitalize(name)), inter);
+				CtMethod getter = CtNewMethod.abstractMethod(returnType, String.format("get%s", StringUtils.capitalize(name)), m.getParameterTypes(), new CtClass[0], inter);
 				inter.addMethod(getter);
 				
 				logger.debug("added method {} to interface {}", method.getName(), controller);
---------------
-------------
@@ -76,7 +76,7 @@
             ).toArray(new String[query.getIntervals().size()])
         )
         .setDimension("hasFilters", String.valueOf(query.hasFilters()))
-        .setDimension("duration", query.getDuration().toPeriod().toStandardMinutes().toString());
+        .setDimension("duration", query.getDuration().toString());
   }
 
   public static <T> ServiceMetricEvent.Builder makeQueryTimeMetric(
---------------
-------------
@@ -173,7 +173,7 @@
                          public String apply(Row input)
                          {
                            // Multi-value dimensions have all been flattened at this point;
-                           final List<String> dimList = input.getDimension(dimension);
+                           final List<String> dimList = input.getDimension(dimension.toLowerCase());
                            return dimList.isEmpty() ? null : dimList.get(0);
                          }
                        }
---------------
-------------
@@ -56,7 +56,7 @@
   @Override
   public boolean appliesTo(DataSegment segment, DateTime referenceTimestamp)
   {
-    final Interval currInterval = new Interval(referenceTimestamp.minus(period), period);
+    final Interval currInterval = new Interval(period, referenceTimestamp);
     return currInterval.contains(segment.getInterval());
   }
 }
---------------
-------------
@@ -136,7 +136,7 @@
     testProperties.putAll(propertyValues);
     injector = Initialization.makeInjectorWithModules(
         GuiceInjectors.makeStartupInjector(),
-        ImmutableList.<Object>of(simpleJsonConfigModule)
+        ImmutableList.<Module>of(simpleJsonConfigModule)
     );
     configurator = injector.getBinding(JsonConfigurator.class).getProvider().get();
     configProvider = JsonConfigProvider.of(configPrefix, clazz);
---------------
-------------
@@ -39,7 +39,7 @@
     S3DataSegmentPusherConfig restoreConfig
   )
   {
-    super(s3Client);
+    super(s3Client, restoreConfig);
     this.archiveConfig = archiveConfig;
     this.restoreConfig = restoreConfig;
   }
---------------
-------------
@@ -210,7 +210,7 @@
                     final Map<String, Object> values = Maps.newHashMap();
                     // put non finalized aggregators for calculating dependent post Aggregators
                     for (AggregatorFactory agg : query.getAggregatorSpecs()) {
-                      values.put(agg.getName(), fn.manipulate(agg, input.getMetric(agg.getName())));
+                      values.put(agg.getName(), input.getMetric(agg.getName()));
                     }
 
                     for (PostAggregator postAgg : query.getPostAggregatorSpecs()) {
---------------
-------------
@@ -110,7 +110,7 @@
     return Arrays.asList(
         new Object[][]{
             {
-                makeQueryRunner(factory, new IncrementalIndexSegment(rtIndex))
+                makeQueryRunner(factory, new IncrementalIndexSegment(rtIndex, null))
             },
             {
                 makeQueryRunner(factory, new QueryableIndexSegment(null, mMappedTestIndex))
---------------
-------------
@@ -215,7 +215,7 @@
                           while (baseIter.hasNext()) {
                             currEntry.set(baseIter.next());
                             if (filterMatcher.matches()) {
-                              break;
+                              return;
                             }
 
                             numAdvanced++;
---------------
-------------
@@ -501,6 +501,7 @@
     )
     {
       this.targetPartitionSize = targetPartitionSize == 0 ? DEFAULT_TARGET_PARTITION_SIZE : targetPartitionSize;
+      Preconditions.checkArgument(rowFlushBoundary >= 0, "rowFlushBoundary should be positive or zero");
       this.rowFlushBoundary = rowFlushBoundary == 0 ? DEFAULT_ROW_FLUSH_BOUNDARY : rowFlushBoundary;
       this.numShards = numShards == null ? -1 : numShards;
       this.indexSpec = indexSpec == null ? DEFAULT_INDEX_SPEC : indexSpec;
---------------
-------------
@@ -76,7 +76,7 @@
             ).toArray(new String[query.getIntervals().size()])
         )
         .setDimension("hasFilters", String.valueOf(query.hasFilters()))
-        .setDimension("duration", query.getDuration().toPeriod().toStandardMinutes().toString());
+        .setDimension("duration", query.getDuration().toString());
   }
 
   public static <T> ServiceMetricEvent.Builder makeQueryTimeMetric(
---------------
-------------
@@ -127,7 +127,7 @@
     if (dataSource instanceof QueryDataSource) {
       GroupByQuery subquery;
       try {
-        subquery = (GroupByQuery) ((QueryDataSource) dataSource).getQuery();
+        subquery = (GroupByQuery) ((QueryDataSource) dataSource).getQuery().withOverriddenContext(query.getContext());
       }
       catch (ClassCastException e) {
         throw new UnsupportedOperationException("Subqueries must be of type 'group by'");
---------------
-------------
@@ -10,7 +10,7 @@
 
   public LoadQueuePeonTester()
   {
-    super(null, null, null, null, null, null);
+    super(null, null, null, null, null);
   }
 
   @Override
---------------
-------------
@@ -127,7 +127,7 @@
     if (dataSource instanceof QueryDataSource) {
       GroupByQuery subquery;
       try {
-        subquery = (GroupByQuery) ((QueryDataSource) dataSource).getQuery();
+        subquery = (GroupByQuery) ((QueryDataSource) dataSource).getQuery().withOverriddenContext(query.getContext());
       }
       catch (ClassCastException e) {
         throw new UnsupportedOperationException("Subqueries must be of type 'group by'");
---------------
-------------
@@ -253,7 +253,7 @@
         log.warn(e, "Unable to close leaderLatch, ignoring");
       }
 
-      exec.shutdownNow();
+      exec.shutdown();
 
       started = false;
     }
---------------
-------------
@@ -39,7 +39,7 @@
     S3DataSegmentPusherConfig restoreConfig
   )
   {
-    super(s3Client);
+    super(s3Client, restoreConfig);
     this.archiveConfig = archiveConfig;
     this.restoreConfig = restoreConfig;
   }
---------------
-------------
@@ -10,7 +10,7 @@
 
   public LoadQueuePeonTester()
   {
-    super(null, null, null, null, null, null);
+    super(null, null, null, null, null);
   }
 
   @Override
---------------
-------------
@@ -67,7 +67,7 @@
 
 	private Map<String, Object> buildStringKeyMap(ByteBuffer input)
 	{
-		int payloadSize = input.limit();
+		int payloadSize = input.remaining();
 
 		if (chars == null || chars.remaining() < payloadSize)
 		{
---------------
-------------
@@ -94,6 +94,6 @@
   public boolean appliesTo(Interval interval, DateTime referenceTimestamp)
   {
     final Interval currInterval = new Interval(period, referenceTimestamp);
-    return currInterval.contains(interval);
+    return currInterval.overlaps(interval) && interval.getStartMillis() >= currInterval.getStartMillis();
   }
 }
---------------
-------------
@@ -24,6 +24,7 @@
 import com.fasterxml.jackson.databind.ObjectWriter;
 import com.google.common.base.Charsets;
 import com.google.common.base.Joiner;
+import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.io.ByteStreams;
 import com.google.inject.Inject;
---------------
-------------
@@ -58,6 +58,7 @@
   @Override
   public String apply(String dimValue)
   {
+    dimValue = (dimValue == null) ? "" : dimValue;
     Matcher matcher = pattern.matcher(dimValue);
     return matcher.find() ? dimValue : null;
   }
---------------
-------------
@@ -173,7 +173,7 @@
                          public String apply(Row input)
                          {
                            // Multi-value dimensions have all been flattened at this point;
-                           final List<String> dimList = input.getDimension(dimension);
+                           final List<String> dimList = input.getDimension(dimension.toLowerCase());
                            return dimList.isEmpty() ? null : dimList.get(0);
                          }
                        }
---------------
-------------
@@ -20,7 +20,7 @@
     private static final long serialVersionUID = 7695540852439013425L;
 
     private static final String IAR_WARNING_PATTERN =
-        "^\"?(.*?)\"?(?:,|\\()(\\d+)(?:\\s*|\\)\\s*:\\s*)(Error|Remark|Warning|Fatal error)\\[(\\w+)\\]: (.*)$";
+    "^(?:\\[.*\\]\\s*)?\\\"?(.*?)\\\"?(?:,|\\()(\\d+)(?:\\s*|\\)\\s*:\\s*)(Error|Remark|Warning|Fatal error)\\[(\\w+)\\]: (.*)$";
 
     /**
      * Creates a new instance of {@link IarParser}.
---------------
-------------
@@ -6,7 +6,7 @@
 import hudson.plugins.warnings.WarningsDescriptor;
 
 /**
- * A parser for the javac compiler warnings.
+ * A parser for the scalac compiler warnings.
  * You should use -feature & -deprecation compiler opts.
  *
  * @author <a href="mailto:alexey.kislin@gmail.com">Alexey Kislin</a>
---------------
-------------
@@ -19,7 +19,7 @@
     /** Warning type of this parser. */
     static final String WARNING_TYPE = "gcc";
     /** Pattern of gcc compiler warnings. */
-    private static final String GCC_WARNING_PATTERN = "^(.*\\.[chpimxsola0-9]+):(?:(\\d*):(?:\\d*:)*\\s*(?:(warning|error|note)\\s*:|\\s*(.*))|\\s*(undefined reference to.*))(.*)|.*ld:\\s*(.*-l(.*))$";
+    private static final String GCC_WARNING_PATTERN = "^\\s*(?:\\[.*\\]\\s*)?(.*\\.[chpimxsola0-9]+):(?:(\\d*):(?:\\d*:)*\\s*(?:(warning|error|note)\\s*:|\\s*(.*))|\\s*(undefined reference to.*))(.*)|.*ld:\\s*(.*-l(.*))$";
 
     /**
      * Creates a new instance of <code>GccParser</code>.
---------------
-------------
@@ -90,7 +90,7 @@
   }
 
   public Object putIdIfNotPresent(DBObject obj) {
-    if (!obj.containsField(ID_KEY)) {
+    if (!obj.containsField(ID_KEY) || obj.get(ID_KEY) == null) {
       ObjectId id = new ObjectId();
       if (!nonIdCollection){
         obj.put(ID_KEY, id);
---------------
-------------
@@ -121,7 +121,7 @@
     }
 
     public boolean accept(File file) {
-      return pattern.match(file.getAbsolutePath());
+      return pattern.match(FilenameUtils.separatorsToUnix(file.getAbsolutePath()));
     }
 
     public boolean accept(File file, String filename) {
---------------
-------------
@@ -1164,7 +1164,7 @@
                 }
                 if (query.getFirstRow() != null || query.getPageSize() != null)
                 {
-                    TypedQuery<Long> qCount = em.createQuery("SELECT COUNT(h) FROM JobInstance h " + wh, Long.class);
+                    TypedQuery<Long> qCount = em.createQuery("SELECT COUNT(h) FROM JobInstance h " + wh2, Long.class);
                     for (Map.Entry<String, Object> entry : prms.entrySet())
                     {
                         qCount.setParameter(entry.getKey(), entry.getValue());
---------------
-------------
@@ -79,7 +79,7 @@
         node = Helpers.checkAndUpdateNodeConfiguration(nodeName, em);
 
         // Check if double-start
-        long toWait = (long) (1.1 * Long.parseLong(Helpers.getParameter("aliveSignalMs", "60000", em)));
+        long toWait = (long) (2 * Long.parseLong(Helpers.getParameter("aliveSignalMs", "60000", em)));
         if (node.getLastSeenAlive() != null
                 && Calendar.getInstance().getTimeInMillis() - node.getLastSeenAlive().getTimeInMillis() <= toWait)
         {
---------------
-------------
@@ -193,6 +193,7 @@
                     {
                         em.remove(jdp);
                     }
+                    jd.getParameters().clear();
                     NodeList prmList = jdElement.getElementsByTagName("parameter");
                     for (int prmIndex = 0; prmIndex < prmList.getLength(); prmIndex++)
                     {
---------------
-------------
@@ -352,7 +352,7 @@
     {
         em.getTransaction().begin();
         for (JobInstance ji : em
-                .createQuery("SELECT ji FROM JobInstance ji WHERE ji.node = :node AND (ji.state = 'SUBMITTED' OR ji.state = 'RUNNING')",
+                .createQuery("SELECT ji FROM JobInstance ji WHERE ji.node = :node AND (ji.state = 'ATTRIBUTED' OR ji.state = 'RUNNING')",
                         JobInstance.class).setParameter("node", node).getResultList())
         {
             History h = em.find(History.class, ji.getId());
---------------
-------------
@@ -418,7 +418,7 @@
     	}
     }
 
-    private static Map<String, List<String>> readHeaders(InputStream in, StringBuilder command, String[] skipHeaders, I2PAppContext ctx) throws IOException {
+    protected static Map<String, List<String>> readHeaders(InputStream in, StringBuilder command, String[] skipHeaders, I2PAppContext ctx) throws IOException {
     	HashMap<String, List<String>> headers = new HashMap<String, List<String>>();
         StringBuilder buf = new StringBuilder(128);
         
---------------
-------------
@@ -28,7 +28,6 @@
         suite.addTestSuite(ElGamalTest.class);
         suite.addTestSuite(HMACSHA256Test.class);
         suite.addTestSuite(KeyGeneratorTest.class);
-        suite.addTestSuite(SessionEncryptionTest.class);
         suite.addTestSuite(SHA1HashTest.class);
         suite.addTestSuite(SHA256Test.class);
         
---------------
-------------
@@ -38,7 +38,6 @@
  */
 public class StandaloneManualExample
 {
-  @SuppressWarnings("restriction")
   public static void main(String[] args)
   {
     // Enable logging and tracing
---------------
-------------
@@ -229,5 +229,6 @@
     testClasses.add(Bugzilla_343332_Test.class);
     testClasses.add(Bugzilla_343471_Test.class);
     testClasses.add(Bugzilla_349793_Test.class);
+    testClasses.add(Bugzilla_349804_Test.class);
   }
 }
---------------
-------------
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2004 - 2009 Eike Stepper (Berlin, Germany) and others.
+ * Copyright (c) 2004 - 2009 Andre Dietisheim (Bern, Switzerland) and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -162,9 +162,10 @@
      *            file descriptor pointing to a full snapshot of the
      *            application's data.  The application should consume every
      *            entity represented in this data stream.
-     * @param appVersionCode The
-     *            {@link android.R.styleable#AndroidManifest_versionCode android:versionCode}
-     *            value of the application that backed up this particular data set. This
+     * @param appVersionCode The value of the <a
+     * href="{@docRoot}guide/topics/manifest/manifest-element.html#vcode">{@code
+     *            android:versionCode}</a> manifest attribute,
+     *            from the application that backed up this particular data set. This
      *            makes it possible for an application's agent to distinguish among any
      *            possible older data versions when asked to perform the restore
      *            operation.
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -93,7 +93,7 @@
                     webView.addJavascriptInterface(object, name);
                     webView.getSettings().setJavaScriptEnabled(true);
                     webView.setWebViewClient(mWebViewClient);
-                    webView.loadData("<html><head></head><body></body></html>", "text/html", null);
+                    webView.loadData("<!DOCTYPE html><title></title>", "text/html", null);
                 }
             });
             mWebViewClient.waitForOnPageFinished();
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -23,7 +23,6 @@
 
     public static String[] children() {
         return new String[] {
-                StringTest.class.getName(),
                 HashMapPerformanceTest.class.getName(),
                 ArrayListPerformanceTest.class.getName(),
                 TreeMapPerformanceTest.class.getName(),
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -56,7 +56,7 @@
     static Pattern sAddressPattern = Pattern.compile(
             /* scheme    */ "(?:(http|https|file)\\:\\/\\/)?" +
             /* authority */ "(?:([-A-Za-z0-9$_.+!*'(),;?&=]+(?:\\:[-A-Za-z0-9$_.+!*'(),;?&=]+)?)@)?" +
-            /* host      */ "([-" + GOOD_IRI_CHAR + "%_]+(?:\\.[-" + GOOD_IRI_CHAR + "%_]+)*|\\[[0-9a-fA-F:\\.]+\\])?" +
+            /* host      */ "([" + GOOD_IRI_CHAR + "%_-][" + GOOD_IRI_CHAR + "%_\\.-]*|\\[[0-9a-fA-F:\\.]+\\])?" +
             /* port      */ "(?:\\:([0-9]*))?" +
             /* path      */ "(\\/?[^#]*)?" +
             /* anchor    */ ".*", Pattern.CASE_INSENSITIVE);
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -152,7 +152,13 @@
             concatRef.refNumber = refNumber;
             concatRef.seqNumber = i + 1;  // 1-based sequence
             concatRef.msgCount = msgCount;
-            concatRef.isEightBits = false;
+            // TODO: We currently set this to true since our messaging app will never
+            // send more than 255 parts (it converts the message to MMS well before that).
+            // However, we should support 3rd party messaging apps that might need 16-bit
+            // references
+            // Note:  It's not sufficient to just flip this bit to true; it will have
+            // ripple effects (several calculations assume 8-bit ref).
+            concatRef.isEightBits = true;
             SmsHeader smsHeader = new SmsHeader();
             smsHeader.concatRef = concatRef;
 
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -237,7 +237,7 @@
     final long prev = getAndSetPrevious(k, curr);
     final Id id = nameFunction.apply(k);
     if (id != null) {
-      spectatorRegistry.counter(id).increment(prev - curr);
+      spectatorRegistry.counter(id).increment(curr - prev);
     }
   }
 
---------------
-------------
@@ -237,7 +237,7 @@
     final long prev = getAndSetPrevious(k, curr);
     final Id id = nameFunction.apply(k);
     if (id != null) {
-      spectatorRegistry.counter(id).increment(prev - curr);
+      spectatorRegistry.counter(id).increment(curr - prev);
     }
   }
 
---------------
-------------
@@ -118,7 +118,9 @@
     final char[] buffer = termAtt.buffer();
     // Remove any remaining non-alphanumeric characters
     for (int i = 0; i < termAtt.length(); i++) {
-      if (!(Character.isAlphabetic(buffer[i]) || Character.isDigit(buffer[i]))) {
+      // TODO: isAlphabetic is a better choice than isLetter since it scrubs some weird
+      // characters, but isAlphabetic is a JDK7 method. Note, affects a test case.
+      if (!(Character.isLetter(buffer[i]) || Character.isDigit(buffer[i]))) {
         System.arraycopy(buffer, i + 1, buffer, i, buffer.length - 1 - i);
         termAtt.setLength(termAtt.length() - 1);
         i--; // Correct for the (now displaced) buffer position
---------------
-------------
@@ -38,6 +38,6 @@
 
   @Override
   public byte[] convert(ValueMetaInterface meta, BytesWritable obj) throws TypeConversionException {
-    return obj.getBytes();
+    return obj.getBytes().clone();
   }
 }
---------------
-------------
@@ -67,7 +67,7 @@
    * @return {@code true} if the class should be ignored by this class loader
    */
   protected boolean ignoreClass(String name) {
-    if (loadClassesFromParent.contains(name)) {
+    if (name == null || loadClassesFromParent.contains(name)) {
       return true;
     }
     for (String prefix : loadClassesFromParent) {
---------------
-------------
@@ -19,7 +19,7 @@
   /** Empty URI. */
   public static final Uri EMPTY = new Uri(Token.EMPTY);
   /** URI validation regex as specified by RFC 3986: Appendix B. */
-  private static Pattern VALID_URI = Pattern.compile(
+  private static final Pattern VALID_URI = Pattern.compile(
       "^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
 
   /**
---------------
-------------
@@ -115,7 +115,7 @@
     try {
       return it.node() && it.type != NodeType.TXT ? serialize() :
         Token.string(it.atom(null));
-    } catch(QueryException e) {
+    } catch(final QueryException e) {
       throw new XQException(e.getMessage(), e.code());
     }
   }
---------------
-------------
@@ -8,7 +8,7 @@
 import org.basex.core.*;
 import org.basex.core.cmd.*;
 import org.basex.server.*;
-import org.basex.test.*;
+import org.basex.test.SandboxTest;
 import org.junit.*;
 
 /**
---------------
-------------
@@ -19,7 +19,7 @@
   /** Empty URI. */
   public static final Uri EMPTY = new Uri(Token.EMPTY);
   /** URI validation regex as specified by RFC 3986: Appendix B. */
-  private static Pattern VALID_URI = Pattern.compile(
+  private static final Pattern VALID_URI = Pattern.compile(
       "^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
 
   /**
---------------
-------------
@@ -138,7 +138,6 @@
   @Override
   public void markTailCalls(final QueryContext ctx) {
     for(final Catch c : ctch) c.markTailCalls(ctx);
-    expr.markTailCalls(ctx);
   }
 
   @Override
---------------
-------------
@@ -29,7 +29,7 @@
 
   @Override
   public void write(final int b) throws IOException {
-    if(b == 0x00 || b == 0xFF) os.write(0xFF);
+    if(b == 0x00 || (b & 0xFF) == 0xFF) os.write(0xFF);
     os.write(b);
   }
 
---------------
-------------
@@ -250,7 +250,7 @@
     final int rpre = pre + nsize;
     int off = 0;
     final int diff = sub - nsize;
-    final int max = rpre - Math.abs(diff);
+    final int max = diff <= 0 ? rpre - Math.abs(diff) : pre + nsize;
     for(int i = pre; i < max; i++) {
       final int o = cursor(i);
       final byte[] b = bf.data;
---------------
-------------
@@ -124,6 +124,6 @@
 
     @Validation
     private void validate() {
-
+        System.out.println("config validated");
     }
 }
---------------
-------------
@@ -284,6 +284,12 @@
         errorMessageSetup.initialize(errorMessageFile, propertyLoader);
     }
 
+    /**
+     * Gets an instance of the ConfigBuilder for a given config class
+     *
+     * @param clazz config class for which the config builder is instantiated.
+     * @return ConfigBuilder instance for config class
+     */
     public static <T> ConfigBuilder<T> on(Class<T> clazz) {
         return new ConfigBuilder<T>(clazz);
     }
---------------
-------------
@@ -11,7 +11,7 @@
         propertyLoader.getSuffixes().clear();
         String[] suffixes = ((PropertySuffixes) annotation).extraSuffixes();
         for (String suffix : suffixes) {
-            propertyLoader.getSuffixes().addString(suffix);
+            propertyLoader.getSuffixes().addSuffix(suffix);
         }
         if (((PropertySuffixes) annotation).hostNames()) {
             propertyLoader.getSuffixes().addLocalHostNames();
---------------
-------------
@@ -310,7 +310,7 @@
      * @param sourceVertex source vertex of the edge.
      * @param targetVertex target vertex of the edge.
      *
-     * @return the removed edges, or <code>null</code> if no either vertex not
+     * @return the removed edges, or <code>null</code> if either vertex is not
      * part of graph
      */
     public Set<E> removeAllEdges(V sourceVertex, V targetVertex);
---------------
-------------
@@ -273,7 +273,7 @@
                 while (iter.hasNext()) {
                     E edge = iter.next();
                     VertexData<V> targetData =
-                        vertexToVertexData.get(this.graph.getEdgeTarget(edge));
+                        vertexToVertexData.get(graph.getEdgeTarget(edge));
 
                     if (!targetData.discovered) {
                         // the "recursion"
---------------
-------------
@@ -125,7 +125,7 @@
 				if(flowValue<=epsilon) //There is no flow on this edge
 					it.remove();
 			}
-			for(E edge: outEdges){
+			for(E edge: inEdges){
 				processQueue.add(Graphs.getOppositeVertex(graph, edge, vertex));
 			}
 		}
---------------
-------------
@@ -107,7 +107,7 @@
 
          // trim off line comments.
          if (line.contains("//")) {
-            line = line.substring(line.indexOf("//"), line.length());
+            line = line.substring(0, line.indexOf("//"));
          }
 
          // with \r\n or just ;\n line ends we get blanks. Filter here.
---------------
-------------
@@ -392,7 +392,7 @@
                     vertex);
 
             // check if the path does not loop over the start vertex.
-            if (vertexReachedByEdge != this.startVertex) {
+            if (!vertexReachedByEdge.equals(this.startVertex)) {
                 if (this.seenDataContainer.containsKey(vertexReachedByEdge)) {
                     boolean relaxed =
                         tryToAddNewPaths(vertexReachedByEdge,
---------------
-------------
@@ -248,7 +248,7 @@
                 part = 27 * part + e.hashCode(); 
             }
 
-            // this is a "piaring function" (see details here: http://en.wikipedia.org/wiki/Pairing_function) (VK)
+            // this is a "pairing function" (see details here: http://en.wikipedia.org/wiki/Pairing_function) (VK)
             int pairing = ((source + target) * (source + target + 1) / 2) + target;
             part = 27 * part + pairing;
 
---------------
-------------
@@ -30,7 +30,7 @@
  * Original Author:  Barak Naveh
  * Contributor(s):   -
  *
- * $Id: GraphReader.java 504 2006-07-03 02:37:26Z perfecthash $
+ * $Id$
  *
  * Changes
  * -------
---------------
-------------
@@ -31,7 +31,7 @@
 
     @Override
     public Image getImage(final Object object) {
-        return null;//Pics.getImage("ContractInput.gif", ContractPlugin.getDefault());
+        return null;
     }
 
 }
---------------
-------------
@@ -315,7 +315,7 @@
 		bot.waitUntil(Conditions.shellIsActive(newVariable));
 		
 		// "Name"
-		bot.textWithLabel(name).setText(varName);
+		bot.textWithLabel(name+" *").setText(varName);
 		
 		// "Data type"
 		bot.comboBoxWithLabel(datatypeLabel).setSelection(varType);
---------------
-------------
@@ -98,7 +98,7 @@
         final FormMapping mapping = (FormMapping) formMappingObservable.getValue();
         final Expression targetForm = mapping.getTargetForm();
         if (targetForm.hasContent()) {
-            repositoryAccessor.getRepositoryStore(WebPageRepositoryStore.class).getChild(targetForm.getContent() + ".json").open();
+            repositoryAccessor.getRepositoryStore(WebPageRepositoryStore.class).getChild(targetForm.getContent()).open();
         }
     }
 }
---------------
-------------
@@ -43,7 +43,7 @@
     }
 
     public URL openPageDesignerHome() throws MalformedURLException {
-        return new URL(baseURL() + "/#/" + locale());
+        return new URL(baseURL() + "/#/" + locale() + "/home");
     }
 
     public URL openPage(final String pageId) throws MalformedURLException {
---------------
-------------
@@ -1,6 +1,6 @@
 /**
- * Copyright (C) 2012 BonitaSoft S.A.
- * BonitaSoft, 31 rue Gustave Eiffel - 38000 Grenoble
+ * Copyright (C) 2012 Bonitasoft S.A.
+ * Bonitasoft, 32 rue Gustave Eiffel - 38000 Grenoble
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 2.0 of the License, or
---------------
-------------
@@ -98,7 +98,7 @@
         return this;
     }
 
-    private void createProjectManifest(final IProgressMonitor monitor) throws CoreException {
+    protected void createProjectManifest(final IProgressMonitor monitor) throws CoreException {
         final IFolder metaInf = project.getFolder(META_INF_FOLDER_NAME);
         metaInf.create(false, true, monitor);
         final IFile projectManifest = project.getFolder(META_INF_FOLDER_NAME).getFile("MANIFEST.MF");
---------------
-------------
@@ -63,7 +63,7 @@
  */
 public class WebFormBOSArchiveFileStoreProvider implements IBOSArchiveFileStoreProvider {
 
-    private static final String WIDGET_ENTRY_REGEXP = "^resources\\\\widgets\\\\(.*)\\\\.*\\.json";
+    private static final String WIDGET_ENTRY_REGEXP = "^resources/widgets/(.*)/.*\\.json";
     private static final String FRAGMENT_ENTRY_REGEXP = "^resources/fragments/(.*\\.json)";
 
     @Inject
---------------
-------------
@@ -662,6 +662,7 @@
                 "Project 'spring-aspects' is an AspectJ project"
                 );
     
+       buildProjects();
         
         //check that the refresh preferences got setup properly (only checking one property).
         //the one that has a non-default value.
---------------
-------------
@@ -269,7 +269,7 @@
         int aclLength = istream.read();
         acl = new int[aclLength];
         for(int i = 0; i < aclLength; i++) {
-            acl[0] = istream.readInt();
+            acl[i] = istream.readInt();
         }
     }
 
---------------
-------------
@@ -164,7 +164,7 @@
     		String pattern =
     			translateRegexp(getArgument(1).eval(contextSequence, contextItem).getStringValue());
             String replace =
-    			((StringValue) getArgument(2).eval(contextSequence, contextItem)).getStringValue(true);
+    			getArgument(2).eval(contextSequence, contextItem).getStringValue();
             //An error is raised [err:FORX0004] if the value of $replacement contains a "$" character that is not immediately followed by a digit 0-9 and not immediately preceded by a "\".
             //An error is raised [err:FORX0004] if the value of $replacement contains a "\" character that is not part of a "\\" pair, unless it is immediately followed by a "$" character.            
             for (int i = 0 ; i < replace.length() ; i++) {
---------------
-------------
@@ -472,7 +472,7 @@
 
         	return compiledQuery;
         } catch(final XPathException e) {
-            LOG.warn(e.getMessage(), e);
+            LOG.warn(e.getMessage());
     		TriggerStatePerThread.setTriggerRunningState(TriggerStatePerThread.NO_TRIGGER_RUNNING, this, null);
     		TriggerStatePerThread.setTransaction(null);
         	throw new TriggerException(PEPARE_EXCEIPTION_MESSAGE, e);
---------------
-------------
@@ -164,7 +164,7 @@
     		String pattern =
     			translateRegexp(getArgument(1).eval(contextSequence, contextItem).getStringValue());
             String replace =
-    			((StringValue) getArgument(2).eval(contextSequence, contextItem)).getStringValue(true);
+    			getArgument(2).eval(contextSequence, contextItem).getStringValue();
             //An error is raised [err:FORX0004] if the value of $replacement contains a "$" character that is not immediately followed by a digit 0-9 and not immediately preceded by a "\".
             //An error is raised [err:FORX0004] if the value of $replacement contains a "\" character that is not part of a "\\" pair, unless it is immediately followed by a "$" character.            
             for (int i = 0 ; i < replace.length() ; i++) {
---------------
-------------
@@ -252,7 +252,7 @@
                 //it looks like an empty sequence could be considered as a sub-type of Type.NODE
                 //well, no so stupid I think...    
                 if (steps.size() > 1 && !(result instanceof VirtualNodeSet) && !result.isEmpty() &&
-                        !Type.subTypeOf(result.getItemType(), Type.NODE))
+                        Type.subTypeOf(result.getItemType(), Type.ATOMIC))
                     gotAtomicResult = true;
 
                 if(steps.size() > 1)
---------------
-------------
@@ -117,7 +117,8 @@
                 ++i;
                 skip = true;
             }
-            if(other.components[j].compareTo(components[i]) == 0) {
+            if(other.components[j].compareTo(components[i]) == 0 && (j + 1 == other.pos || other.components[j + 1].compareTo(components[i]) != 0)) {
+           // if(other.components[j].compareTo(components[i]) == 0) {
                 ++i;
                 skip = false;
             } else if(skip) {
---------------
-------------
@@ -15,6 +15,7 @@
 
     @Override
     public void start() throws Exception {
+        dataSource.start();
     }
 
     @Override
---------------
-------------
@@ -93,7 +93,7 @@
 
         @ValidationMethod(message = "must have logging.file.archivedLogFilenamePattern if logging.file.archive is true")
         public boolean isValidArchiveConfiguration() {
-            return !archive || archivedLogFilenamePattern != null;
+            return !enabled || !archive || archivedLogFilenamePattern != null;
         }
 
         @ValidationMethod(message = "must have logging.file.currentLogFilename if logging.file.enabled is true")
---------------
-------------
@@ -78,7 +78,7 @@
                     }
                 }
             }
-            else if (event.getType() == RequestEvent.Type.RESOURCE_METHOD_FINISHED) {
+            else if (event.getType() == RequestEvent.Type.RESP_FILTERS_START) {
                 if (this.session != null) {
                     try {
                         commitTransaction();
---------------
-------------
@@ -192,6 +192,7 @@
 
             rollingPolicy.setParent(appender);
             rollingPolicy.start();
+            return appender;
         }
         return new FileAppender<>();
     }
---------------
-------------
@@ -41,7 +41,7 @@
     @Override
     protected void doPost(HttpServletRequest req,
                           HttpServletResponse resp) throws ServletException, IOException {
-        final Task task = tasks.get(req.getRequestURI());
+        final Task task = tasks.get(req.getServletPath());
         if (task != null) {
             try {
                 resp.setContentType(MediaType.TEXT_PLAIN);
---------------
-------------
@@ -41,7 +41,7 @@
     @Override
     protected void doPost(HttpServletRequest req,
                           HttpServletResponse resp) throws ServletException, IOException {
-        final Task task = tasks.get(req.getRequestURI());
+        final Task task = tasks.get(req.getServletPath());
         if (task != null) {
             try {
                 resp.setContentType(MediaType.TEXT_PLAIN);
---------------
-------------
@@ -95,6 +95,7 @@
 
         // copy jar
         ArtifactDescriptor targetDescriptor = new ArtifactDescriptor(canonical);
+        targetDescriptor.setProperty(IArtifactDescriptor.FORMAT, null);
         IStatus status = Status.OK_STATUS;
         if (!target.contains(targetDescriptor)) {
             monitor.subTask("Downloading " + getArtifactKey().getId());
---------------
-------------
@@ -122,7 +122,7 @@
         }
         if (writeIsStarted()) {
             // if the sink was opened, it should also be closed
-            assertThat(writeIsAborted() || writeIsStarted(), is(true));
+            assertThat(writeIsAborted() || writeIsCommitted(), is(true));
         }
     }
 
---------------
-------------
@@ -1,3 +1,13 @@
+/*******************************************************************************
+ * Copyright (c) 2011 SAP AG and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    SAP AG - initial API and implementation
+ *******************************************************************************/
 package org.eclipse.tycho.p2.impl.publisher.rootfiles;
 
 import java.io.File;
---------------
-------------
@@ -24,7 +24,7 @@
     private static final List<CustomQuery> queryLibrary = new ArrayList<>();
 
     static {
-        queryLibrary.add(new OrgFilterQuery());
+//        queryLibrary.add(new OrgFilterQuery());
     }
 
     private SqlRepositoryConfiguration repoConfiguration;
---------------
-------------
@@ -314,7 +314,7 @@
 			// We have got JAXB object here, but the code expects DOM
 			object = JAXBUtil.objectTypeToDom(objectType, null);
 		} catch (Exception ex) {
-			LoggingUtils.logException(LOGGER, "Variable {} couldn't be serialized to XML, skipping", ex);
+			LoggingUtils.logException(LOGGER, "Variable {} couldn't be serialized to XML, skipping", ex, oid);
 		}
 
 		return object;
---------------
-------------
@@ -68,8 +68,6 @@
 					focusContext.getOid(), SchemaConstants.PATH_ACTIVATION_ADMINISTRATIVE_STATUS, getPrismContext(), 
 					desiredStatus);
 			focusContext.setPrimaryDelta(activationDelta);
-			ObjectDelta<F> delta = objectOld.createDeleteDelta();
-	        focusContext.setPrimaryDelta(delta);
 		}
 
 	}
---------------
-------------
@@ -116,7 +116,7 @@
 	@Override
 	protected void assertStepSyncToken(String syncTaskOid, int step, long tsStart, long tsEnd)
 			throws ObjectNotFoundException, SchemaException {
-		assertSyncToken(syncTaskOid, (Integer)(step+5));
+		assertSyncToken(syncTaskOid, (Integer)(step+4));
 	}
 	
 }
---------------
-------------
@@ -101,6 +101,7 @@
         list.add(Projections.groupProperty(CLOSURE_ALIAS + ".descendant"));
         String alias = getContext().getAlias(null);
         list.add(Projections.groupProperty(alias + ".name.orig"));     //just used for sorting by name
+        list.add(Projections.groupProperty(alias + ".fullObject"));
         list.add(Projections.property(alias + ".fullObject"));
 
         pCriteria.createCriteria(QUERY_PATH, CLOSURE_ALIAS).setFetchMode(ANCESTOR, FetchMode.DEFAULT)
---------------
-------------
@@ -150,7 +150,7 @@
 		Validate.notNull(result, "Result type must not be null.");
 		if (LOGGER.isTraceEnabled()) {
 			LOGGER.trace(JAXBUtil.silentMarshalWrap(user));
-			LOGGER.trace(JAXBUtil.silentMarshal(userTemplate));
+			LOGGER.trace(JAXBUtil.silentMarshalWrap(userTemplate));
 		}
 
 		if (userTemplate == null) {
---------------
-------------
@@ -362,7 +362,7 @@
                 return value.getTextContent();
             } else {
                 //composite elements or containers
-                return DOMUtil.printDom(value);
+                return DOMUtil.serializeDOMToString(value);
             }
         } else {
             object = XmlTypeConverter.toJavaValue(value, typeName);
---------------
-------------
@@ -221,7 +221,7 @@
 		AssertJUnit.assertNotNull(modelWeb);
 		AssertJUnit.assertNotNull(modelService);
 		AssertJUnit.assertNotNull(repositoryService);
-		AssertJUnit.assertTrue(systemInitialized);
+		AssertJUnit.assertTrue(isSystemInitialized());
 		AssertJUnit.assertNotNull(taskManager);
 
 		OperationResult result = new OperationResult(TestSanity.class.getName() + ".test000Integrity");
---------------
-------------
@@ -116,7 +116,7 @@
 		remove("99.0", "dropins", "myBundle_2.0.0.jar");
 		reconcile("99.1");
 		// TODO re-enable this when we fix bug 248468
-		if (false)
+		if (!DISABLED)
 			assertDoesNotExistInBundlesInfo("99.2", "myBundle", "2.0.0");
 	}
 
---------------
-------------
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008, 2011 Code 9 and others. All rights reserved. This
+ * Copyright (c) 2008, 2012 Code 9 and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
---------------
-------------
@@ -27,7 +27,7 @@
 
 	protected void setUp() throws Exception {
 		super.setUp();
-		Manipulator manipulator = createMinimalConfiguration(Activator.getContext().getDataFile(RemovingABundle.class.getName()).getAbsolutePath());
+		Manipulator manipulator = createMinimalConfiguration(RemovingABundle.class.getName());
 		manipulator.getConfigData().addBundle(new BundleInfo("bundle_1", "1.0.0", FileLocator.resolve(Activator.getContext().getBundle().getEntry("dataFile/bundle_1")).toExternalForm(), 4, false));
 		manipulator.save(false);
 
---------------
-------------
@@ -87,7 +87,7 @@
     // Janky, but keep ListProperty.toString from being huge and accidentally ruining perf
     String s = getValueObject().getName() + " [";
     for (int i = 0; i < e.size() && i < 20; i++) {
-      s += e.get(i).toString();
+      s += ObjectUtils.toStr(e.get(i), "null");
       if (i != e.size() - 1) {
         s += ", ";
       }
---------------
-------------
@@ -1995,7 +1995,7 @@
                                                                browseOnly,
                                                                clientWindowSize,
                                                                ackBatchSize,
-                                                               consumerMaxRate > 0 ? new TokenBucketLimiterImpl(maxRate,
+                                                               maxRate > 0 ? new TokenBucketLimiterImpl(maxRate,
                                                                                                                 false)
                                                                   : null,
                                                                executor,
---------------
-------------
@@ -1187,7 +1187,7 @@
 
       Map<Thread, StackTraceElement[]> postThreads = Thread.getAllStackTraces();
 
-      if (postThreads != null && postThreads.size() > previousThreads.size())
+      if (postThreads != null && previousThreads != null && postThreads.size() > previousThreads.size())
       {
 
          buffer.append("*********************************************************************************\n");
---------------
-------------
@@ -283,7 +283,7 @@
 
       try
       {
-         session.rollback();
+         session.rollback(true);
       }
       catch (HornetQException e)
       {
---------------
-------------
@@ -713,7 +713,7 @@
          // only override the exiration on messages where the expiration hasn't been set by the user
          if (message.getExpiration() == 0)
          {
-            message.setExpiration(expirationOverride);
+            message.setExpiration(System.currentTimeMillis() + expirationOverride);
          }
       }
    }
---------------
-------------
@@ -121,6 +121,7 @@
          channel.setReceiver(null);
          clientOpened = false;
       }
+      channel.close();
    }
 
    private class JGroupsReceiver extends ReceiverAdapter
---------------
-------------
@@ -38,7 +38,7 @@
 
    protected final boolean replicatedBackup;
    private final String directory;
-   private final Object nodeIDGuard = "";
+   private final Object nodeIDGuard = new Object();
    private SimpleString nodeID;
    private UUID uuid;
    private String nodeGroupName;
---------------
-------------
@@ -116,6 +116,7 @@
       TextPacket packet = new TextPacket(
             "testClientHandlePacketSentByServer from client");
       packet.setTargetID(serverPacketHandler.getID());
+      packet.setResponseTargetID(serverPacketHandler.getID());
       // send a packet to create a sender when the server
       // handles the packet
       session.write(packet);
---------------
-------------
@@ -120,7 +120,8 @@
       {
          if(pos >= addressParts.length)
          {
-            return false;
+            //test for # as last address part
+            return pos + 1 == add.getAddressParts().length && add.getAddressParts()[pos].equals(ANY_WORDS_SIMPLESTRING);
          }
          SimpleString curr = addressParts[pos];
          SimpleString next = addressParts.length > pos + 1 ? addressParts[pos + 1] : null;
---------------
-------------
@@ -124,7 +124,7 @@
       return sfilterString;
    }
 
-   public boolean match(final ServerMessage message)
+   public synchronized boolean match(final ServerMessage message)
    {
       try
       {
---------------
-------------
@@ -519,7 +519,7 @@
                            @Parameter(desc="do we send to the DLA when there is no where to route the message", name="sendToDLAOnNoRoute") boolean sendToDLAOnNoRoute,
                            @Parameter(desc="the ploicy to use when the address is full", name="addressFullMessagePolicy") String addressFullMessagePolicy) throws Exception;
 
-   AddressSettings getAddressSettings(String address);
+   AddressSettings getAddressSettings(String address) throws Exception;
 
    void removeAddressSettings(String addressMatch) throws Exception;
 
---------------
-------------
@@ -1332,7 +1332,7 @@
 
                for (RemotingConnection potentialConnection : remotingService.getConnections())
                {
-                  if (potentialConnection.getID().toString().equals(serverSession.getConnectionID()))
+                  if (potentialConnection.getID().toString().equals(serverSession.getConnectionID().toString()))
                   {
                      connection = potentialConnection;
                   }
---------------
-------------
@@ -703,7 +703,7 @@
 
             for (int i = 0; i < paramTypes.length; i++)
             {
-               if (params[i].getClass() != paramTypes[i])
+               if (params[i] != null && params[i].getClass() != paramTypes[i])
                {
                   continue;
                }
---------------
-------------
@@ -713,7 +713,7 @@
          // only override the exiration on messages where the expiration hasn't been set by the user
          if (message.getExpiration() == 0)
          {
-            message.setExpiration(expirationOverride);
+            message.setExpiration(System.currentTimeMillis() + expirationOverride);
          }
       }
    }
---------------
-------------
@@ -347,7 +347,7 @@
       if (sendSemaphore != null)
       {
          //Any threads blocking on the send semaphore should be allowed to return
-         sendSemaphore.release(Integer.MAX_VALUE);
+         sendSemaphore.release(Integer.MAX_VALUE - sendSemaphore.availablePermits());
       }
 
       if (!connection.isDestroyed() && !connection.removeChannel(id))
---------------
-------------
@@ -1187,7 +1187,7 @@
 
       Map<Thread, StackTraceElement[]> postThreads = Thread.getAllStackTraces();
 
-      if (postThreads != null && postThreads.size() > previousThreads.size())
+      if (postThreads != null && previousThreads != null && postThreads.size() > previousThreads.size())
       {
 
          buffer.append("*********************************************************************************\n");
---------------
-------------
@@ -291,7 +291,7 @@
          {
             try
             {
-               session.rollback();
+               session.rollback(true);
             }
             catch (HornetQException e1)
             {
---------------
-------------
@@ -1187,7 +1187,7 @@
 
       Map<Thread, StackTraceElement[]> postThreads = Thread.getAllStackTraces();
 
-      if (postThreads.size() > previousThreads.size())
+      if (postThreads != null && postThreads.size() > previousThreads.size())
       {
 
          buffer.append("*********************************************************************************\n");
---------------
-------------
@@ -65,7 +65,7 @@
 
    private static final Logger log = Logger.getLogger(RemotingServiceImpl.class);
 
-   private static final long CONNECTION_TTL_CHECK_INTERVAL = 2000;
+   public static final long CONNECTION_TTL_CHECK_INTERVAL = 2000;
 
    // Attributes ----------------------------------------------------
 
---------------
-------------
@@ -78,7 +78,7 @@
    
    public boolean add(E o)
    {
-      return theMap.put(o, dummy) == dummy;
+      return theMap.put(o, dummy) == null;
    }
    
    public boolean contains(Object o)
---------------
-------------
@@ -1187,7 +1187,7 @@
 
       Map<Thread, StackTraceElement[]> postThreads = Thread.getAllStackTraces();
 
-      if (postThreads.size() > previousThreads.size())
+      if (postThreads != null && postThreads.size() > previousThreads.size())
       {
 
          buffer.append("*********************************************************************************\n");
---------------
-------------
@@ -124,7 +124,7 @@
       return sfilterString;
    }
 
-   public boolean match(final ServerMessage message)
+   public synchronized boolean match(final ServerMessage message)
    {
       try
       {
---------------
-------------
@@ -82,7 +82,7 @@
          MessagingServer server = new MessagingServerImpl();
          ClientConnectionFactory cf = new ClientConnectionFactoryImpl(0, remotingConf, server.getVersion());
          ClientConnection conn = cf.createConnection(null, null);
-         ClientSession session = conn.createClientSession(false, true, true, 0, false, false);
+         ClientSession session = conn.createClientSession(false, true, true, -1, false, false);
          ClientProducer producer = session.createProducer(QUEUE);
 
          MessageImpl message = new MessageImpl(JBossTextMessage.TYPE, false, 0,
---------------
-------------
@@ -13,7 +13,6 @@
 
 package org.hornetq.api.jms.management;
 
-import java.util.List;
 import java.util.Map;
 
 import javax.management.MBeanOperationInfo;
---------------
-------------
@@ -161,7 +161,7 @@
             if (activation.getTopicTemporaryQueue() == null)
             {
                queueName = new SimpleString(UUID.randomUUID().toString());
-               session.createQueue(activation.getAddress(), queueName, selectorString, false);
+               session.createTemporaryQueue(activation.getAddress(), queueName, selectorString);
                activation.setTopicTemporaryQueue(queueName);
             }
             else
---------------
-------------
@@ -369,7 +369,7 @@
                                         final long clientFailureCheckPeriod,
                                         final long connectionTTL)
    {
-      if (connectionTTL <= 0 || clientFailureCheckPeriod <= 0)
+      if ((connectionTTL <= 0 || clientFailureCheckPeriod <= 0) && connectionTTL != -1 && clientFailureCheckPeriod != -1)
       {
          log.warn("Invalid values of connectionTTL/clientFailureCheckPeriod");
 
---------------
-------------
@@ -37,7 +37,7 @@
    protected void encodeBody(ConsumerFlowTokenMessage message, RemotingBuffer out) throws Exception
    {
       out.putInt(INT_LENGTH);
-      out.putFloat(message.getTokens());
+      out.putInt(message.getTokens());
    }
 
    @Override
---------------
-------------
@@ -69,7 +69,7 @@
 
    public HornetQAdmin()
    {
-       serverLifeCycleActive = Boolean.getBoolean(System.getProperty(SERVER_LIVE_CYCLE_PROPERTY, "true"));
+      serverLifeCycleActive = Boolean.valueOf(System.getProperty(SERVER_LIVE_CYCLE_PROPERTY, "true"));
       try
       {
          Hashtable<String, String> env = new Hashtable<String, String>();
---------------
-------------
@@ -104,6 +104,8 @@
 
    {
       this(transportConnection, -1, interceptors, active, false);
+      
+      log.info("Created remotingconnection " + this + " on server");
    }
 
    private RemotingConnectionImpl(final Connection transportConnection,
---------------
-------------
@@ -73,6 +73,7 @@
 	public TypedProperties(final TypedProperties other)
 	{	   
 		this.properties = other.properties == null ? null : new HashMap<SimpleString, PropertyValue>(other.properties);
+		this.size = other.size;
 	}
 	
 	public void putBooleanProperty(final SimpleString key, final boolean value)
---------------
-------------
@@ -1677,7 +1677,7 @@
             {
                long tx = storageManager.generateUniqueID();
                storageManager.deleteQueueBinding(tx, queueBindingInfo.getId());
-               storageManager.commit(tx);
+               storageManager.commitBindings(tx);
                continue;
             }
             else
---------------
-------------
@@ -444,9 +444,6 @@
    public boolean isBodyAssignableTo(@SuppressWarnings("rawtypes")
    Class c)
    {
-      if (bodyLength == 0)
-         return true;
-      // XXX FIXME HORNETQ-1209 What to do on Serializable?
       return c.isAssignableFrom(byte[].class);
    }
 
---------------
-------------
@@ -182,6 +182,8 @@
 
    public boolean getNoLocal() throws JMSException
    {
+      checkClosed();
+
       return noLocal;
    }
 
---------------
-------------
@@ -139,7 +139,7 @@
 	public void createJournal() throws Exception
 	{     
 		journal =
-			new JournalImpl(fileSize, minFiles, sync, fileFactory, 1000, filePrefix, fileExtension, maxAIO, 120);
+			new JournalImpl(fileSize, minFiles, sync, fileFactory, 1000, filePrefix, fileExtension, maxAIO, 120000);
 	}
 	
 	protected void startJournal() throws Exception
---------------
-------------
@@ -189,7 +189,7 @@
 
    // Connection implementation --------------------------------------------------------------------
 
-   public Session createSession(final boolean transacted, final int acknowledgeMode) throws JMSException
+   public synchronized Session createSession(final boolean transacted, final int acknowledgeMode) throws JMSException
    {
       checkClosed();
 
---------------
-------------
@@ -1050,7 +1050,8 @@
 
    private void internalAddRedistributor(final Executor executor, final Channel replicatingChannel)
    {
-      if (consumers.size() == 0)
+      // create the redistributor only once if there are no local consumers
+      if (consumers.size() == 0 && redistributor == null)
       {
          redistributor = new Redistributor(this,
                                            storageManager,
---------------
-------------
@@ -182,7 +182,7 @@
         benchmark.doTest(5, tests);
     }
 
-    private static abstract class TimeDateElementBenchmarkTestBase {
+    private abstract static class TimeDateElementBenchmarkTestBase {
         protected static final String months[] = { "Jan", "Feb", "Mar", "Apr",
                 "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
 
---------------
-------------
@@ -164,7 +164,7 @@
       File entryFile = (File) iter.next();
       String entryPath = getRelativePath(file, entryFile);
       if (preserveRoot) {
-        entryPath = file.getName() + "/" + entryPath;
+        entryPath = file.getName() + entryPath;
       }
       this.changedEntries.add(new FileSource(entryPath, entryFile));
     }
---------------
-------------
@@ -164,7 +164,7 @@
       File entryFile = (File) iter.next();
       String entryPath = getRelativePath(file, entryFile);
       if (preserveRoot) {
-        entryPath = file.getName() + "/" + entryPath;
+        entryPath = file.getName() + entryPath;
       }
       this.changedEntries.add(new FileSource(entryPath, entryFile));
     }
---------------
-------------
@@ -68,7 +68,7 @@
       else if (encoding == null) return 1;
       else if (encoding != null) return -1;
 
-      return 0;
+      return compare;
    }
 
    public Variant getVariant()
---------------
-------------
@@ -146,7 +146,7 @@
       }
       catch (NumberFormatException e)
       {
-         throw new RuntimeException("MediaType q parameter must be a float: " + type, e);
+         throw new LoggableFailure("MediaType q parameter must be a float: " + type, HttpResponseCodes.SC_BAD_REQUEST);
       }
       return 1.0f;
    }
---------------
-------------
@@ -127,7 +127,7 @@
             if (produce.getEncoding() == null || accept.getEncoding() == null) match = true;
             else match = produce.getEncoding().equals(accept.getEncoding());
 
-            return produce.getVariant();
+            if (match) return produce.getVariant();
          }
       }
       return null;
---------------
-------------
@@ -196,7 +196,7 @@
    {
       Object rtn = methodInjector.invoke(request, response, target);
       if (request.isSuspended()) return null;
-      if (method.getReturnType().equals(Response.class))
+      if (Response.class.isAssignableFrom(method.getReturnType()) || rtn instanceof Response)
       {
          return (Response) rtn;
       }
---------------
-------------
@@ -424,7 +424,7 @@
             List<String> vals = map.get(theName);
             for (Object val : vals)
             {
-               path += ";" + name + "=" + val.toString();
+               path += ";" + theName + "=" + val.toString();
             }
          }
       }
---------------
-------------
@@ -103,7 +103,7 @@
 		if (isCond(sub)) {
 			explanCond(expr.operator.name, sub, where);
 		} else {
-			if (sub.operator.priority < expr.operator.priority) {
+			if (sub.operator.priority > expr.operator.priority) {
 				Where subWhere = new Where(expr.getOperator().name);
 				where.addWhere(subWhere);
 				parseWhere(sub, subWhere);
---------------
-------------
@@ -189,6 +189,7 @@
 			}
 			String type = sqlSelectOrderByItem.getType().toString();
 			for (String name : lists) {
+				name = name.replace("`", "");
 				select.addOrderBy(name, type);
 			}
 			lists.clear();
---------------
-------------
@@ -110,7 +110,17 @@
         }
 
         private static int prefixToSubnetMask(int cidrPrefix) {
-            return -1 << 32 - cidrPrefix;
+            /**
+             * Perform the shift on a long and downcast it to int afterwards.
+             * This is necessary to handle a cidrPrefix of zero correctly.
+             * The left shift operator on an int only uses the five least
+             * significant bits of the right-hand operand. Thus -1 << 32 evaluates
+             * to -1 instead of 0. The left shift operator applied on a long
+             * uses the six least significant bits.
+             *
+             * Also see https://github.com/netty/netty/issues/2767
+             */
+            return (int) ((-1L << 32 - cidrPrefix) & 0xffffffff);
         }
     }
 
---------------
-------------
@@ -233,6 +233,7 @@
             // Doubled
 
             int normalizedCapacity = reqCapacity;
+            normalizedCapacity --;
             normalizedCapacity |= normalizedCapacity >>>  1;
             normalizedCapacity |= normalizedCapacity >>>  2;
             normalizedCapacity |= normalizedCapacity >>>  4;
---------------
-------------
@@ -829,6 +829,7 @@
         int length = currentBuffer.readableBytes();
         if (length > HttpPostBodyUtil.chunkSize) {
             ByteBuf slice = currentBuffer.slice(currentBuffer.readerIndex(), HttpPostBodyUtil.chunkSize);
+            currentBuffer.retain();
             currentBuffer.skipBytes(HttpPostBodyUtil.chunkSize);
             return slice;
         } else {
---------------
-------------
@@ -968,7 +968,8 @@
             verifyPrefaceReceived();
 
             // Send an ack back to the remote client.
-            frameWriter.writePing(ctx, ctx.newPromise(), true, data);
+            // Need to retain the buffer here since it will be released after the write completes.
+            frameWriter.writePing(ctx, ctx.newPromise(), true, data.retain());
 
             AbstractHttp2ConnectionHandler.this.onPingRead(ctx, data);
         }
---------------
-------------
@@ -198,7 +198,7 @@
     }
 
     public ByteBuffer toByteBuffer(int index, int length) {
-        return ByteBuffer.wrap(array, index, length);
+        return ByteBuffer.wrap(array, index, length).order(order());
     }
 
     public String toString(int index, int length, String charsetName) {
---------------
-------------
@@ -231,6 +231,7 @@
 
 			}
 
+			// FIXME: this will not include arbitrary data-* attributes
 			for (PropertyKey attribute : EntityContext.getPropertySet(getClass(), PropertyView.Html)) {
 
 				try {
---------------
-------------
@@ -580,7 +580,7 @@
 		if (enableRewriteFilter) {
 			
 			FilterHolder rewriteFilter = new FilterHolder(UrlRewriteFilter.class);
-			rewriteFilter.setInitParameter("confPath", "/urlrewrite.xml");
+			rewriteFilter.setInitParameter("confPath", "urlrewrite.xml");
 			servletContext.addFilter(rewriteFilter, "/*", EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD));
 		}
 
---------------
-------------
@@ -26,7 +26,7 @@
 import org.structr.common.error.FrameworkException;
 import org.structr.common.property.*;
 import org.structr.core.EntityContext;
-import org.structr.core.node.NodeService.NodeIndex;
+import org.structr.core.graph.NodeService.NodeIndex;
 
 /**
  *
---------------
-------------
@@ -85,7 +85,7 @@
         JetExpression jetBodyExpression = declaration.getBodyExpression();
         assert jetBodyExpression != null : "Cannot translate a body of an abstract function.";
         JsBlock jsBlock = new JsBlock(setDefaultValueForArguments(descriptor, context()));
-        jsBlock.getStatements().addAll(mayBeWrapWithReturn(Translation.translateExpression(jetBodyExpression, context())).getStatements());
+        jsBlock.getStatements().addAll(mayBeWrapWithReturn(Translation.translateExpression(jetBodyExpression, context(), jsBlock)).getStatements());
         return jsBlock;
     }
 
---------------
-------------
@@ -113,6 +113,8 @@
                 .beforeInside(LBRACE, WHEN).spacing(1, 1, 0, true, 0)          //omit blank lines before '{' in 'when' statement
 
                 .aroundInside(ARROW, FUNCTION_TYPE).spaceIf(jetSettings.SPACE_AROUND_FUNCTION_TYPE_ARROW)
+
+                .betweenInside(REFERENCE_EXPRESSION, FUNCTION_LITERAL_EXPRESSION, CALL_EXPRESSION).spaces(1)
                 ;
     }
 
---------------
-------------
@@ -49,7 +49,7 @@
         if (!theClass.isAssignableFrom(other.theClass)) {
             return false;
         }
-        if (nullable && !other.nullable) {
+        if (!nullable && other.nullable) {
             return false;
         }
         if (typeParameters != null) {
---------------
-------------
@@ -339,7 +339,6 @@
             case CLASS_OBJECT:
                 return objectCreationMethodReference();
             case ANNOTATION_CLASS:
-                throw new IllegalStateException("Can't create annotation class instance: " + descriptor);
             case CLASS:
                 return DescriptorUtils.isAnonymousObject(descriptor)
                        ? objectCreationMethodReference()
---------------
-------------
@@ -73,7 +73,7 @@
                 .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)
                 .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)
                 .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)
-                .around(TokenSet.create(PLUS, MINUS)).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)
+                .aroundInside(TokenSet.create(PLUS, MINUS), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)
                 .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)
                 .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)
                 .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)
---------------
-------------
@@ -251,6 +251,7 @@
         int modifiers = JetTypeMapper.getAccessModifiers(propertyDescriptor, 0);
         PropertySetterDescriptor setter = propertyDescriptor.getSetter();
         int flags = setter == null ? modifiers : JetTypeMapper.getAccessModifiers(setter, modifiers);
+        flags |= (propertyDescriptor.getModality() == Modality.ABSTRACT ? Opcodes.ACC_ABSTRACT : 0);
         generateDefaultSetter(propertyDescriptor, flags, p);
     }
 
---------------
-------------
@@ -162,7 +162,7 @@
         final JetStandardLibrary stdlib = JetStandardLibrary.getInstance();
 
         if (returnType != null && !stdlib.getTuple0Type().equals(returnType)) {
-            bodyBuilder.append(" : ").append(returnType.toString());
+            bodyBuilder.append(" : ").append(DescriptorRenderer.COMPACT.renderTypeWithShortNames(returnType));
             ImportInsertHelper.addImportDirectiveIfNeeded(returnType, file);
         }
 
---------------
-------------
@@ -142,7 +142,7 @@
     };
     PsiElementOnlyDiagnosticFactory3<JetModifierListOwner, CallableMemberDescriptor, CallableMemberDescriptor, DeclarationDescriptor> VIRTUAL_MEMBER_HIDDEN = PsiElementOnlyDiagnosticFactory3.create(ERROR, "''{0}'' hides ''{1}'' in class {2} and needs 'override' modifier", DescriptorRenderer.TEXT);
 
-    PsiElementOnlyDiagnosticFactory1<JetSimpleNameExpression, DeclarationDescriptor> UNINITIALIZED_VARIABLE = PsiElementOnlyDiagnosticFactory1.create(ERROR, "Variable ''{0}'' must be uninitialized", NAME);
+    PsiElementOnlyDiagnosticFactory1<JetSimpleNameExpression, DeclarationDescriptor> UNINITIALIZED_VARIABLE = PsiElementOnlyDiagnosticFactory1.create(ERROR, "Variable ''{0}'' must be initialized", NAME);
     PsiElementOnlyDiagnosticFactory1<JetSimpleNameExpression, DeclarationDescriptor> VAL_REASSIGNMENT = PsiElementOnlyDiagnosticFactory1.create(ERROR, "Val can not be reassigned", NAME);
 
     SimpleDiagnosticFactory UNREACHABLE_CODE = SimpleDiagnosticFactory.create(ERROR, "Unreachable code");
---------------
-------------
@@ -296,7 +296,7 @@
         );
 
         String s = configuration.get(JVMConfigurationKeys.ANDROID_RES_PATH);
-        project.registerService(AndroidUIXmlParser.class, new CliAndroidUIXmlParser(s));
+        project.registerService(AndroidUIXmlParser.class, new CliAndroidUIXmlParser(project, s));
         project.registerService(VirtualFileFinderFactory.class, new CliVirtualFileFinderFactory(classPath));
     }
 
---------------
-------------
@@ -90,7 +90,7 @@
         renameLocalNames(namingContext, invokedFunction);
         removeStatementsAfterTopReturn();
 
-        if (canBeExpression(body)) {
+        if (isResultNeeded && canBeExpression(body)) {
             resultExpr = asExpression(body);
             body.getStatements().clear();
 
---------------
-------------
@@ -110,7 +110,7 @@
                               other.message.matches(textMatchesRegexp));
             return;
         }
-        Assert.assertEquals(other.message, this.message);
+        Assert.assertEquals(this.message, other.message);
     }
 
     @Override
---------------
-------------
@@ -7,6 +7,9 @@
  */
 public class OverloadUtil {
 
+    /**
+     * Does not check names.
+     */
     public static OverloadCompatibilityInfo isOverloadble(FunctionDescriptor a, FunctionDescriptor b) {
         OverridingUtil.OverrideCompatibilityInfo overrideCompatibilityInfo = OverridingUtil.isOverridableByImpl(a, b, false);
         if (overrideCompatibilityInfo.isSuccess()) {
---------------
-------------
@@ -14,6 +14,7 @@
     }
 
     public interface Super2 {
+        @KotlinSignature("fun foo(s : Array<out String?>?)")
         void foo(String[] s);
     }
 
---------------
-------------
@@ -1504,7 +1504,6 @@
                 throw new UnsupportedOperationException("don't know how to handle non-class types in as/as?");
             }
             Type type = typeMapper.mapType(jetType, OwnerKind.INTERFACE);
-            gen(expression.getLeft(), OBJECT_TYPE);
             generateInstanceOf(new Runnable() {
                         @Override
                         public void run() {
---------------
-------------
@@ -221,7 +221,7 @@
 
         @Override
         public boolean prefixMatches(@NotNull String name) {
-            return StringUtil.startsWithIgnoreCase(name, getPrefix());
+            return StringUtil.startsWith(name, getPrefix());
         }
 
         @NotNull
---------------
-------------
@@ -178,7 +178,7 @@
             String fq2 = ((JetClass) another).getQualifiedName();
             return fq1 != null && fq2 != null && fq1.equals(fq2);
         }
-        return true;
+        return false;
     }
 
     @Nullable
---------------
-------------
@@ -2199,7 +2199,7 @@
                 if(getterDescriptor.getReceiverParameter().exists()) {
                     index++;
                 }
-                for (TypeParameterDescriptor typeParameterDescriptor : getterDescriptor.getTypeParameters()) {
+                for (TypeParameterDescriptor typeParameterDescriptor : resolvedGetCall.getCandidateDescriptor().getTypeParameters()) {
                     if(typeParameterDescriptor.isReified()) {
                         generateTypeInfo(resolvedGetCall.getTypeArguments().get(typeParameterDescriptor), null);
                         index++;
---------------
-------------
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package kotlinlib.testall;
+package stdlib.testall;
 
 import junit.framework.TestSuite;
 import test.collections.*;
---------------
-------------
@@ -466,6 +466,7 @@
                 List<ValueParameterDescriptor> paramDescrs = functionDescriptor.getValueParameters();
                 for (int i = 0; i < paramDescrs.size(); i++) {
                     int size = argTypes[i + (hasReceiver ? 1 : 0)].getSize();
+                    frameMap.enter(paramDescrs.get(i),size);
                     var += size;
                 }
 
---------------
-------------
@@ -290,7 +290,7 @@
             }
 
             StackValue outer = getOuterExpression(null, ignoreNoOuter);
-            result = result == null ? outer : StackValue.composed(result, outer);
+            result = result == null || outer == null ? outer : StackValue.composed(result, outer);
         }
 
         return parentContext != null ? parentContext.lookupInContext(d, result, state, ignoreNoOuter) : null;
---------------
-------------
@@ -397,7 +397,7 @@
     }
 
     public static boolean isCacheNeeded(@NotNull JsExpression expression) {
-        return !(expression instanceof JsLiteral) &&
+        return !(expression instanceof JsLiteral.JsValueLiteral) &&
                (!(expression instanceof JsNameRef) || ((JsNameRef) expression).getQualifier() != null);
     }
 
---------------
-------------
@@ -263,7 +263,7 @@
         final JetParameter loopParameter = expression.getLoopParameter();
         final VariableDescriptor parameterDescriptor = bindingContext.get(BindingContext.VALUE_PARAMETER, loopParameter);
         JetType paramType = parameterDescriptor.getOutType();
-        Type asmParamType = typeMapper.mapType(paramType);
+        Type asmParamType = typeMapper.boxType(typeMapper.mapType(paramType));
 
         int iteratorVar = myMap.enterTemp();
         gen(expression.getLoopRange(), loopRangeType);
---------------
-------------
@@ -117,7 +117,7 @@
         JsInvocation call = new JsInvocation(Namer.getFunctionCallRef(Namer.superMethodNameRef(ref)));
         call.getArguments().add(JsLiteral.THIS);
         call.getArguments().addAll(arguments);
-        initializerStatements.add(call.makeStmt());
+        initializerStatements.add(0, call.makeStmt());
     }
 
     @NotNull
---------------
-------------
@@ -39,7 +39,7 @@
       while (start > -1) {
         if (start > 0 && src[start - 1] == '\\') {
           // the variable is escaped. remove the backslash.
-          builder.append(src, offset, start - 1).append(openToken);
+          builder.append(src, offset, start - offset - 1).append(openToken);
           offset = start + openToken.length();
         } else {
           int end = text.indexOf(closeToken, start);
---------------
-------------
@@ -163,7 +163,7 @@
 	  return str;
 	}
 	
-  private static String convertPathSlashes( String absolutePath ) {
+  public static String convertPathSlashes( String absolutePath ) {
     return absolutePath.replaceAll( "\\\\", "/" );
   }
 
---------------
-------------
@@ -89,6 +89,7 @@
         } catch ( SQLException e ) {
             LOG.debug( "Unable to load driver: {}", e.getLocalizedMessage() );
         }
+        System.out.println(workspace);
         super.startup( workspace );
     }
 
---------------
-------------
@@ -126,6 +126,7 @@
                             throws ResourceInitException {
         this.dialect = dialect;
         this.metadata = metadata;
+        this.workspace = workspace;
         this.connectionId = config.getJDBCConnId();
         this.config = config;
 
---------------
-------------
@@ -221,7 +221,7 @@
                     Transformation prev = chain.getFirst();
                     // align the axis of source crs of the given transformation to the targetcrs of the previous one.
                     if ( prev != null ) {
-                        Transformation allign = MatrixTransform.createAllignMatrixTransform( prev.getSourceCRS(),
+                        Transformation allign = MatrixTransform.createAllignMatrixTransform( prev.getTargetCRS(),
                                                                                              tbu.getSourceCRS() );
                         if ( !TransformationFactory.isIdentity( allign ) ) {
                             resultChain.add( allign );
---------------
-------------
@@ -211,7 +211,7 @@
 
   /**
    * Closes the store instance, releasing all transient resources locally held by it.
-   * The instance can't be used any further upon the method returning.
+   * The instance should not be used any further upon the method returning.
    * Data held remotely or on some persistent storage remains untouched and can be accessed by creating a new Store
    */
   void close();
---------------
-------------
@@ -211,7 +211,7 @@
 
   /**
    * Closes the store instance, releasing all transient resources locally held by it.
-   * The instance can't be used any further upon the method returning.
+   * The instance should not be used any further upon the method returning.
    * Data held remotely or on some persistent storage remains untouched and can be accessed by creating a new Store
    */
   void close();
---------------
-------------
@@ -111,7 +111,7 @@
     }
 
     protected ActionRepeater<WebElement> withWebElement() {
-      return with(getWrappedElement(), timeout);
+      return with(getWrappedElement(), timeout, interval);
     }
 
     @Override
---------------
-------------
@@ -25,7 +25,7 @@
 import org.geowebcache.layer.wms.WMSMetaTile;
 import org.geowebcache.layer.wms.WMSSourceHelper;
 
-public final class MockWMSSourceHelper extends WMSSourceHelper {
+public class MockWMSSourceHelper extends WMSSourceHelper {
     private Font font = Font.decode("Arial-BOLD-14");
 
     private Map<List<Integer>, byte[]> images = new HashMap<List<Integer>, byte[]>();
---------------
-------------
@@ -61,6 +61,7 @@
 
     private TileLayerDispatcher layerDispatcher;
 
+    @Override
     public void handle(Request request, Response response) {
         Method met = request.getMethod();
         try {
---------------
-------------
@@ -207,7 +207,7 @@
 		if (style == ChatColor.UNDERLINE) return this.underlined(true);
 		if (style == ChatColor.STRIKETHROUGH) return this.striketrhough(true);
 		if (style == ChatColor.MAGIC) return this.obfuscated(true);
-		if (style.isColor()) return this.color(color);
+		if (style.isColor()) return this.color(style);
 		
 		throw new UnsupportedOperationException(style.name());
 	}
---------------
-------------
@@ -204,7 +204,7 @@
     public void agentEndpointDisconnected(Session session) {
         // Find session
         Session foundSession = sessionToAgents.get(session.getAgentId());
-        if (!foundSession.equals(session)) {
+        if (foundSession == null || !foundSession.equals(session)) {
             return;
         } else {
             sessionToAgents.remove(session.getAgentId());
---------------
-------------
@@ -162,7 +162,7 @@
 		if ( "jar".equals( protocol ) ) {
 			return new JarProtocolVisitor( jarUrl, filters, entry );
 		}
-		else if ( StringHelper.isEmpty( protocol ) || "file".equals( protocol ) ) {
+		else if ( StringHelper.isEmpty( protocol ) || "file".equals( protocol ) || "vfszip".equals( protocol ) || "vfsfile".equals( protocol ) ) {
 			File file;
 			try {
 				final String filePart = jarUrl.getFile();
---------------
-------------
@@ -127,7 +127,7 @@
 					return getObjectFromList( results, id, session );
 				}
 			}
-			return ( loaders[batchSizes.length-1] ).load( id, optionalObject, session );
+			return ( loaders[batchSizes.length-1] ).load( id, optionalObject, session, lockOptions );
 		}
 	}
 
---------------
-------------
@@ -122,7 +122,7 @@
      * @since 3.3
      */
     public static <T extends Serializable> T roundtrip(final T msg) {
-        return SerializationUtils.deserialize(SerializationUtils.serialize(msg));
+        return (T) SerializationUtils.deserialize(SerializationUtils.serialize(msg));
     }
 
     // Serialize
---------------
-------------
@@ -220,7 +220,7 @@
      * @return true if the locale is a known locale
      */
     public static boolean isAvailableLocale(Locale locale) {
-        return cAvailableLocaleSet.contains(locale);
+        return availableLocaleList().contains(locale);
     }
 
     //-----------------------------------------------------------------------
---------------
-------------
@@ -1669,7 +1669,7 @@
      * 
      * @return the version, for example 131 for Java 1.3.1
      */
-    static float toJavaVersionInt(String version) {
+    static int toJavaVersionInt(String version) {
         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
     }
 
---------------
-------------
@@ -1626,7 +1626,7 @@
             return equals(getImplicitLowerBounds(w), getImplicitLowerBounds(other))
                 && equals(getImplicitUpperBounds(w), getImplicitUpperBounds(other));
         }
-        return true;
+        return false;
     }
 
     /**
---------------
-------------
@@ -817,7 +817,7 @@
      * @return the formatted string
      */
     public String format(Date date) {
-        Calendar c = new GregorianCalendar(mTimeZone);
+        Calendar c = new GregorianCalendar(mTimeZone, mLocale);
         c.setTime(date);
         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
     }
---------------
-------------
@@ -881,7 +881,7 @@
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
-                str.getChars(0, strLen, buffer, size);
+                str.getChars(0, width, buffer, size);
             } else {
                 int padLen = width - strLen;
                 str.getChars(0, strLen, buffer, size);
---------------
-------------
@@ -1034,7 +1034,7 @@
     }
     
     /**
-     * @see Nestable#getThrowableS()
+     * @see Nestable#getThrowables()
      */
     public Throwable[] getThrowables()
     {
---------------
-------------
@@ -679,6 +679,7 @@
                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
                         (str.charAt(2) == 'S' || str.charAt(2) == 's');
                 }
+                return false;
             }
             case 4: {
                 char ch = str.charAt(0);
---------------
-------------
@@ -62,7 +62,7 @@
 
         for (FulfillmentOption option : options) {
             if (canCalculateCostForFulfillmentGroup(fulfillmentGroup, option)) {
-                Money price = ((FixedPriceFulfillmentOption)fulfillmentGroup.getFulfillmentOption()).getPrice();
+                Money price = ((FixedPriceFulfillmentOption) option).getPrice();
                 shippingPrices.put(option, price);
                 return response;
             }
---------------
-------------
@@ -73,6 +73,6 @@
         break;
       }
     }
-    return virtualFile == null ? null : new OpenFileHyperlinkInfo(myModule.getProject(), virtualFile, line);
+    return virtualFile == null ? null : new OpenFileHyperlinkInfo(myModule.getProject(), virtualFile, line - 1);
   }
 }
---------------
-------------
@@ -34,7 +34,7 @@
 
     private static final MeasurementRecorderSource RECORDER = 
             RecorderFactory.createScalableCountingRecorderSource("allocations", "instances", 
-            Integer.valueOf(System.getProperty("perf.allocations.sampleTime", "1000")) );
+            Integer.valueOf(System.getProperty("perf.allocations.sampleTime", "300000")) );
     
     private static final boolean RECORD_OBJECT_SIZE = Boolean.valueOf(System.getProperty("perf.allocations.recordSize", "true"));
        
---------------
-------------
@@ -257,7 +257,7 @@
         CompleteTaskCommand cmd = new CompleteTaskCommand();
         cmd.setTaskId(taskId);
         cmd.setUserId(userId);
-        JaxbStringObjectPairArray values = convertMapToJaxbStringObjectPairArray(data);
+        cmd.setData(convertMapToJaxbStringObjectPairArray(data));
         executeCommand(cmd);
     }
 
---------------
-------------
@@ -58,7 +58,7 @@
             int instancesOfPath = 1;
             // count how many instances/steps should current path have
             if (numberOfAllInstances > 1) {
-                instancesOfPath = (int) (numberOfAllInstances * probability);
+                instancesOfPath = (int) Math.round((numberOfAllInstances * probability));
             
                 for (int i = 0; i < instancesOfPath; i++) {
                     f.newStep( interval * i )
---------------
-------------
@@ -22,7 +22,6 @@
 import org.kie.api.KieBase;
 import org.kie.api.runtime.KieSession;
 import org.kie.api.runtime.StatelessKieSession;
-import org.kie.spring.KieSpringUtils;
 import org.kie.spring.beans.Person;
 import org.kie.spring.beans.SampleBean;
 import org.springframework.context.ApplicationContext;
---------------
-------------
@@ -89,7 +89,7 @@
     protected ProcessRequestBean processRequestBean;
 
     @Inject
-    private BackupIdentityProviderProducer backupIdentityProviderProducer;
+    protected BackupIdentityProviderProducer backupIdentityProviderProducer;
 
     @Inject
     private DynamicJaxbContext dynamicJaxbContext;
---------------
-------------
@@ -521,7 +521,7 @@
                 KieContainerInstance kci = containers.putIfAbsent(containerId, ci);
                 if( kci != null && kci.getStatus() == KieContainerStatus.FAILED ) {
                     // if previous container filed, allow override
-                    containers.put("containerId", ci);
+                    containers.put(containerId, ci);
                     return null;
                 }
                 return kci;
---------------
-------------
@@ -44,7 +44,7 @@
     @Override
     public byte[] getBytes(String pResourceName) {
         URL url = bundle.getEntry(pResourceName);
-        return readUrlAsBytes(url);
+        return url == null ? null : readUrlAsBytes(url);
     }
 
     @Override
---------------
-------------
@@ -73,7 +73,7 @@
             String res = resources[i];
             String type = types[i].getDefaultExtension();
 
-            kfs.write( "src/kbases/" + id + "/org/test/res" + i + "." + type, res );
+            kfs.write( "src/main/resources/" + id + "/org/test/res" + i + "." + type, res );
         }
 
         KieBaseModel kBase1 = kproj.newKieBaseModel( id )
---------------
-------------
@@ -28,7 +28,7 @@
 public abstract class Query<T, E> 
       extends PersistenceController<T> //TODO: extend MutableController!
 {
-   private static final Pattern SUBJECT_PATTERN = Pattern.compile("^select\\s+(\\w+(?:\\s*\\.\\s*\\w+)*?)(?:\\s*,\\s*(\\w+(?:\\s*\\.\\s*\\w+)*?))*?\\s+from", Pattern.CASE_INSENSITIVE); 
+   private static final Pattern SUBJECT_PATTERN = Pattern.compile("^select\\s+((distinct)?\\s?\\w+(?:\\s*\\.\\s*\\w+)?)(?:\\s,\\s*(\\w+(?:\\s*\\.\\s*\\w+)?))?\\s+from", Pattern.CASE_INSENSITIVE); 
    private static final Pattern FROM_PATTERN = Pattern.compile("(^|\\s)(from)\\s",       Pattern.CASE_INSENSITIVE);
    private static final Pattern WHERE_PATTERN = Pattern.compile("\\s(where)\\s",         Pattern.CASE_INSENSITIVE);
    private static final Pattern ORDER_PATTERN = Pattern.compile("\\s(order)(\\s)+by\\s", Pattern.CASE_INSENSITIVE);
---------------
-------------
@@ -1,7 +1,5 @@
 package actions;
 
-import java.io.IOException;
-
 import javax.servlet.http.HttpServletResponse;
 
 import org.jboss.seam.ScopeType;
---------------
-------------
@@ -298,7 +298,7 @@
          public void process() throws ServletException, IOException, LoginException
          {
             Identity identity = Identity.instance();
-            identity.setUsername(username);
+            identity.getCredentials().setUsername(username);
             identity.authenticate();
          }
       }.run();  
---------------
-------------
@@ -48,7 +48,7 @@
    @WebRemote
    public List<Category> getAllCategories()
    {
-      allCategories = entityManager.createQuery("from Category").getResultList(); 
+      allCategories = entityManager.createQuery("from Category c order by c.categoryId").getResultList(); 
       return allCategories;
    }
    
---------------
-------------
@@ -14,7 +14,7 @@
 @Provider
 public class CalendarConverter implements StringConverter<GregorianCalendar>
 {
-   public static final String ISO_FORMAT = "yyyy-MM-dd'T'HH:mm:ss";
+   public static final String ISO_FORMAT = "yyyy-MM-dd'T'HH:mm:ssZ";
 
    public GregorianCalendar fromString(String s)
    {
---------------
-------------
@@ -66,7 +66,7 @@
    {
       hotel = null;
       String searchPattern = searchString==null ? "%" : '%' + searchString.toLowerCase().replace('*', '%') + '%';
-      hotels = bookingDatabase.createQuery("from Hotel where lower(city) like :search or lower(zip) like :search or lower(address) like :search")
+      hotels = bookingDatabase.createQuery("from Hotel where lower(name) like :search or lower(city) like :search or lower(zip) like :search or lower(address) like :search")
             .setParameter("search", searchPattern)
             .setMaxResults(50)
             .getResultList();
---------------
-------------
@@ -9,7 +9,6 @@
 import javax.faces.convert.Converter;
 import javax.servlet.ServletRequest;
 
-import org.jboss.seam.contexts.Lifecycle;
 import org.jboss.seam.core.ServletContexts;
 
 public class Parameters
---------------
-------------
@@ -33,7 +33,7 @@
    @In(create=true)
    Foo foo;
    
-   @Out
+   @Out(required=false)
    String string;
    
    @Begin
---------------
-------------
@@ -276,7 +276,7 @@
       if (o1.value > o2.value) {
         return 1;
       } else if (o1.value < o2.value) {
-        return 0;
+        return -1;
       }
 
       // otherwise on alphabetic order
---------------
-------------
@@ -104,7 +104,7 @@
     addParser("literal", new ValueSourceParser() {
       @Override
       public ValueSource parse(FunctionQParser fp) throws ParseException {
-        return new LiteralValueSource(fp.getString());
+        return new LiteralValueSource(fp.parseArg());
       }
     });
     addParser("rord", new ValueSourceParser() {
---------------
-------------
@@ -202,7 +202,7 @@
       //then be sure all of the new words have the same optional/required/prohibited status in the query.
       while(indexOfSpace>-1 && indexOfSpace<corr.length()-1) {
         addParenthesis = true;
-        char previousChar = tok.startOffset()>0 ? collation.charAt(tok.startOffset()-1) : ' ';
+        char previousChar = tok.startOffset()>0 ? origQuery.charAt(tok.startOffset()-1) : ' ';
         if(previousChar=='-' || previousChar=='+') {
           corrSb.insert(indexOfSpace + bump, previousChar);
           if(requiredOrProhibited==null) {
---------------
-------------
@@ -450,6 +450,8 @@
       for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {
         Map.Entry<Token, String> entry = bestIter.next();
         Token tok = entry.getKey();
+        // we are replacing the query in order, but injected terms might cause illegal offsets due to previous replacements.
+        if (tok.getPositionIncrement() == 0) continue;
         collation.replace(tok.startOffset() + offset, 
           tok.endOffset() + offset, entry.getValue());
         offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());
---------------
-------------
@@ -228,7 +228,7 @@
    * This only supports bytes.length <= blockSize */
   public void copy(BytesRef bytes, BytesRef out) throws IOException {
     int left = blockSize - upto;
-    if (bytes.length > left) {
+    if (bytes.length > left || currentBlock==null) {
       if (currentBlock != null) {
         blocks.add(currentBlock);
         blockEnd.add(upto);
---------------
-------------
@@ -41,7 +41,7 @@
   public static Double[] toSparseLocalFreqDoubleArray(Terms docTerms, Terms fieldTerms) throws IOException {
     TermsEnum fieldTermsEnum = fieldTerms.iterator(null);
     Double[] freqVector = null;
-    if (docTerms != null) {
+    if (docTerms != null && fieldTerms.size() > -1) {
       freqVector = new Double[(int) fieldTerms.size()];
       int i = 0;
       TermsEnum docTermsEnum = docTerms.iterator(null);
---------------
-------------
@@ -43,6 +43,13 @@
  * will match a significant amount of the term dictionary. If you really want this, consider
  * using an n-gram indexing technique (such as the SpellChecker in the 
  * <a href="{@docRoot}/../suggest/overview-summary.html">suggest module</a>) instead.
+ *
+ * <p>NOTE: terms of length 1 or 2 will sometimes not match because of how the scaled
+ * distance between two terms is computed.  For a term to match, the edit distance between
+ * the terms must be less than the minimum length term (either the input term, or
+ * the candidate term).  For example, FuzzyQuery on term "abcd" with maxEdits=2 will
+ * not match an indexed term "ab", and FuzzyQuery on term "a" with maxEdits=2 will not
+ * match an indexed term "abc".
  */
 public class FuzzyQuery extends MultiTermQuery {
   
---------------
-------------
@@ -227,7 +227,7 @@
       int endTerm = numTermsInField;  // one past the end
 
       TermsEnum te = getOrdTermsEnum(searcher.getAtomicReader());
-      if (prefix != null && prefix.length() > 0) {
+      if (te != null && prefix != null && prefix.length() > 0) {
         final BytesRef prefixBr = new BytesRef(prefix);
         if (te.seekCeil(prefixBr, true) == TermsEnum.SeekStatus.END) {
           startTerm = numTermsInField;
---------------
-------------
@@ -613,7 +613,6 @@
       resourceLoader.inform( resourceLoader );
       resourceLoader.inform( this );  // last call before the latch is released.
     } catch (Throwable e) {
-      log.error("Error in constructing the core", e);
       latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine
       //close down the searcher and any other resources, if it exists, as this is not recoverable
       close();
---------------
-------------
@@ -101,6 +101,7 @@
     if (len>0) {
       return pushed.charAt(len-1);
     }
+    numRead++;
     int ch = input.read();
     push(ch);
     return ch;
---------------
-------------
@@ -16,6 +16,7 @@
   // without breaking configs.
 
   private static final String SOURCE_HOME = determineSourceHome();
+  public static String WEBAPP_HOME = new File(SOURCE_HOME, "src/webapp/web").getAbsolutePath();
   public static String EXAMPLE_HOME = new File(SOURCE_HOME, "example/solr").getAbsolutePath();
   public static String EXAMPLE_MULTICORE_HOME = new File(SOURCE_HOME, "example/multicore").getAbsolutePath();
   public static String EXAMPLE_SCHEMA=EXAMPLE_HOME+"/conf/schema.xml";
---------------
-------------
@@ -76,7 +76,7 @@
   }
 
   void cleanup() {
-    assertU(delQ("id:[100 TO 110]"));
+    assertU(delQ("*:*"));
     assertU(commit());
   }
 
---------------
-------------
@@ -1,5 +1,22 @@
 package org.apache.lucene.facet.search;
 
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Set;
---------------
-------------
@@ -257,8 +257,6 @@
    * Returns true iff {@link Similarity#coord(int,int)} is disabled in scoring
    * for the high and low frequency query instance. The top level query will
    * always disable coords.
-   * 
-   * @see #CommonTermsQuery(Occur, Occur, float, boolean)
    */
   public boolean isCoordDisabled() {
     return disableCoord;
---------------
-------------
@@ -53,6 +53,7 @@
         log.info("Creating job aid content measure for call id " + callId);
 
         AudioTrackerLog audioTrackerLog = audioTrackerLogService.getLogFor(callId);
+        if(audioTrackerLog == null) return;
 
         FrontLineWorkerDimension frontLineWorkerDimension = allFrontLineWorkerDimensions.fetchFor(audioTrackerLog.callerIdAsLong());
         RegistrationMeasure registrationMeasure = allRegistrationMeasures.fetchFor(frontLineWorkerDimension.getId());
---------------
-------------
@@ -77,7 +77,7 @@
 	
 	private Ds2dsConfiguration configuration = null;
 		
-	public Ds2dsAction(ActionConfiguration actionConfiguration) {
+	public Ds2dsAction(Ds2dsConfiguration actionConfiguration) {
 		super(actionConfiguration);
         configuration = super.configuration; // this has been cloned and should be shared between DsBaseAction and this.
 	}
---------------
-------------
@@ -57,7 +57,7 @@
     public void doFilter(ServletRequest request, ServletResponse response,
         FilterChain chain) throws IOException, ServletException {
 
-        if(response.isCommitted()){
+        if (response.isCommitted()) {
             log.warn("Response was already committed!");
             return;
         }
---------------
-------------
@@ -102,7 +102,6 @@
     public void delete(E entity) {
         E toDelete = find(entity.getId());
         currentSession().delete(toDelete);
-        flush();
     }
     
     public void bulkDelete(List<E> entities) {
---------------
-------------
@@ -139,7 +139,7 @@
         if (isCompliant()) {
             return GREEN;
         }
-        if (!partiallyCompliantProducts.isEmpty() && nonCompliantProducts.isEmpty()) {
+        if (nonCompliantProducts.isEmpty()) {
             return YELLOW;
         }
         return RED;
---------------
-------------
@@ -83,7 +83,7 @@
      * @param pools
      * @param c
      * @param date
-     * @return
+     * @return suggested quantities for all pools requested
      */
     public Map<String, SuggestedQuantity> getSuggestedQuantities(List<Pool> pools,
             Consumer c, Date date) {
---------------
-------------
@@ -151,7 +151,6 @@
     @MapKeyColumn(name = "mapkey")
     @Column(name = "element")
     @Cascade({org.hibernate.annotations.CascadeType.ALL})
-    @Size(max = 255)
     private Map<String, String> facts;
 
     @OneToOne(cascade = CascadeType.ALL)
---------------
-------------
@@ -54,7 +54,7 @@
      * @throws InstantiationException thrown if this.scheduler can't be
      * initialized.
      */
-    public PinsetterKernel() throws InstantiationException {
+    protected PinsetterKernel() throws InstantiationException {
         this(new Config());
     }
 
---------------
-------------
@@ -37,7 +37,7 @@
         Properties toReturn = new Properties();
         
         for(String key: inputConfiguration.keySet()) {
-            toReturn.put(key.substring(PREFIX_LENGTH), inputConfiguration.get(key));
+            toReturn.put(key.substring(PREFIX_LENGTH + 1), inputConfiguration.get(key));
         }
         return toReturn;
     }
---------------
-------------
@@ -562,6 +562,6 @@
 
     @Transient
     public boolean isManifest() {
-        return getType().isManifest();
+        return getType() == null ? false : getType().isManifest();
     }
 }
---------------
-------------
@@ -257,7 +257,7 @@
                     "] futureExpire [" + futureExpire + "]");
             }
 
-            if (expire.compareTo(futureExpire) < 0) {
+            if (expire.before(futureExpire)) {
                 log.warn("regenerating certificate for [" + uuid + "]");
                 consumer = this.regenerateIdentityCertificates(uuid);
             }
---------------
-------------
@@ -34,7 +34,7 @@
 		// uglier 
 		registerLocation(constructDefaultFromModel());
 		// the ugliest
-		IPath workspaceCopy = new Path("/org.eclipse.gmf.runtime.notation/src/model/notation.genmodel");
+		IPath workspaceCopy = new Path("/org.eclipse.gmf.runtime.notation/model/notation.genmodel");
 		if (ResourcesPlugin.getWorkspace().getRoot().getFile(workspaceCopy).exists()) {
 			registerLocation(URI.createPlatformResourceURI(workspaceCopy.toPortableString()));
 		}
---------------
-------------
@@ -19,7 +19,7 @@
 		TestSuite suite = new TestSuite("Test for org.eclipse.gmf.tests.migration"); //$NON-NLS-1$
 		//$JUnit-BEGIN$
 		suite.addTestSuite(GenericMigrationTest.class);
-// COMMENTED OUT for M7 BUILD		suite.addTestSuite(MigrationPatchesTest.class);
+		suite.addTestSuite(MigrationPatchesTest.class);
 		suite.addTestSuite(TestCustomCopier.class);
 		//$JUnit-END$
 		return suite;
---------------
-------------
@@ -115,6 +115,7 @@
                 TypeElement typeElement = (TypeElement)declaredType.asElement();
                 switch(typeElement.getKind()){
                 case ENUM:      return createEnumType(declaredType, typeElement, p);
+                case ANNOTATION_TYPE:
                 case CLASS:     return createClassType(declaredType, typeElement, p);
                 case INTERFACE: return createInterfaceType(declaredType, typeElement, p);
                 default: throw new IllegalArgumentException("Illegal type " + typeElement);
---------------
-------------
@@ -128,7 +128,7 @@
         boolean toLower = str.toUpperCase().equals(str);
         StringBuilder builder = new StringBuilder(str.length());
         for (int i = 0; i < str.length(); i++) {
-            if (str.charAt(i) == '_') {
+            if (str.charAt(i) == '_' || str.charAt(i) == ' ') {
                 i += 1;
                 if (i < str.length()) {
                     builder.append(Character.toUpperCase(str.charAt(i)));    
---------------
-------------
@@ -37,7 +37,7 @@
      * @param templates
      */
     public ColQueryImpl(ColQueryTemplates templates) {
-        this(new DefaultQueryEngine(new DefaultEvaluatorFactory(ColQueryTemplates.DEFAULT)));
+        this(new DefaultQueryEngine(new DefaultEvaluatorFactory(templates)));
     }
     
     /**
---------------
-------------
@@ -129,7 +129,7 @@
         boolean toLower = str.toUpperCase().equals(str);
         StringBuilder builder = new StringBuilder(str.length());
         for (int i = 0; i < str.length(); i++) {
-            if (str.charAt(i) == '_' || str.charAt(i) == ' ' || str.charAt(i) == '-') {
+            if (i < str.length() - 1 && (str.charAt(i) == '_' || str.charAt(i) == ' ' || str.charAt(i) == '-')) {
                 i += 1;
                 if (i < str.length()) {
                     builder.append(Character.toUpperCase(str.charAt(i)));    
---------------
-------------
@@ -485,6 +485,7 @@
         long total = count();
         try {
             if (total > 0) {
+                queryMixin.getMetadata().clearProjection();
                 QueryModifiers modifiers = queryMixin.getMetadata().getModifiers();
                 return new SearchResults<RT>(list(expr), modifiers, total);
             } else {
---------------
-------------
@@ -149,7 +149,7 @@
             Class<?> beanType = type;
             while (!beanType.equals(Object.class)){
                 try {
-                    Field field = type.getDeclaredField(property);
+                    Field field = beanType.getDeclaredField(property);
                     field.setAccessible(true);
                     fields.put(property, field);
                     beanType = Object.class;
---------------
-------------
@@ -64,7 +64,6 @@
         registerDefault(Types.LONGVARBINARY, Object.class);
         registerDefault(Types.NULL, Object.class);
         registerDefault(Types.OTHER, Object.class);
-        registerDefault(Types.REAL, Object.class);
         registerDefault(Types.REF, Object.class);
         registerDefault(Types.ROWID, Object.class);
         registerDefault(Types.STRUCT, Object.class);
---------------
-------------
@@ -169,6 +169,7 @@
             queryString = serializer.toString();
             logger.debug(queryString);
             stmt = connection.prepareStatement(queryString);
+            setParameters(stmt, serializer.getConstants(), serializer.getConstantPaths(), Collections.<Param<?>,Object>emptyMap());
             
             // add first batch
             stmt.addBatch();
---------------
-------------
@@ -361,7 +361,7 @@
         dmlWithSchema = false;
         // columns
         if (!columns.isEmpty()) {
-            append("(");
+            append(" (");
             skipParent = true;
             handle(COMMA, columns);
             skipParent = false;
---------------
-------------
@@ -147,7 +147,7 @@
 
         else if (op == Ops.EQ_IGNORE_CASE) {
             return asDBObject(asDBKey(expr, 0),
-                    Pattern.compile("^" + regexValue(expr, 1) + "$", Pattern.CASE_INSENSITIVE));
+                    Pattern.compile("^" + regexValue(expr, 1) + "$", Pattern.CASE_INSENSITIVE)); 
         }
 
         else if (op == Ops.STRING_CONTAINS) {
---------------
-------------
@@ -53,7 +53,6 @@
  * @cdk.created    2007-07-20
  * @cdk.module     core
  * @cdk.githash
- * @cdk.bug        1802998
  */
 @TestClass("org.openscience.cdk.atomtype.CDKAtomTypeMatcherTest")
 public class CDKAtomTypeMatcher implements IAtomTypeMatcher {
---------------
-------------
@@ -41,6 +41,7 @@
 
 	public NNBond() {
 		this(null, null, null, CDKConstants.STEREO_BOND_NONE);
+		this.atomCount = 0;
 	}
 
 	public NNBond(IAtom atom1, IAtom atom2) {
---------------
-------------
@@ -47,7 +47,7 @@
  * @cdk.created 2012-04-13
  * 
  * @cdk.keyword bond order
- * @cdk.module  valency
+ * @cdk.module  valencycheck
  */
 @TestClass( "org.openscience.cdk.tools.ATASaturationCheckerTest" )
 public class AtomTypeAwareSaturationChecker implements IValencyChecker,
---------------
-------------
@@ -751,7 +751,7 @@
         b1 = bondsA1[((RNode) gr.getGraph().get(j)).getRMap().getId1()];
         b2 = bondsA2[((RNode) gr.getGraph().get(j)).getRMap().getId2()];
 
-        if (a1 instanceof IQueryBond) {
+        if (a2 instanceof IQueryBond) {
             if (a1.equals(b1) || a2.equals(b2) ||
                 !queryAdjacency(a1, b1, a2, b2)) {
                 x.getForbidden().set(j);
---------------
-------------
@@ -795,6 +795,8 @@
 	{
 		logger.debug("handleRing():");
 		double bondStat = bondStatusForRingClosure;
+		if (ringbonds[thisRing] > bondStat)
+			bondStat = ringbonds[thisRing];
 		IBond bond = null;
 		IAtom partner = null;
 		IAtom thisNode = rings[thisRing];
---------------
-------------
@@ -161,7 +161,6 @@
  * @cdk.keyword    SMILES, generator
  * @cdk.module     smiles
  * @cdk.githash
- * @cdk.bug        1793446
  *
  * @see org.openscience.cdk.aromaticity.Aromaticity
  * @see org.openscience.cdk.stereo.Stereocenters
---------------
-------------
@@ -444,6 +444,7 @@
      * @return null.
      */
     @Override
+    @TestMethod("testReturnsNull")
     public Number getFlagValue() {
         return null;
     }
---------------
-------------
@@ -258,7 +258,7 @@
         try {
             reader.setReader(input);
         } catch ( CDKException e1 ) {
-            throw new IOException("Exception while setting the InputStream: " + e1.getMessage(), e1);
+            throw new IOException("Exception while setting the InputStream: " + e1.getMessage());
         }
         return reader;
     }
---------------
-------------
@@ -109,7 +109,7 @@
     		getParameters(),
     		new DoubleResult(
     			Math.abs(factory.getElement(atoms[0].getSymbol()).getAtomicNumber() - 
-    					 factory.getElement(atoms[0].getSymbol()).getAtomicNumber())
+    					 factory.getElement(atoms[1].getSymbol()).getAtomicNumber())
     		),
     		descriptorName);
     }
---------------
-------------
@@ -744,7 +744,7 @@
     			if (isAcceptable(atom, atomContainer, type)) return type;
     		} else if (neighborcount == 2) {
     			if (maxBondOrder == CDKConstants.BONDORDER_DOUBLE) {
-    				IAtomType type = getAtomType("P.ine");
+    				IAtomType type = getAtomType("P.irane");
     				if (isAcceptable(atom, atomContainer, type)) return type;
     			} else if (maxBondOrder == CDKConstants.BONDORDER_SINGLE) {
     				IAtomType type = getAtomType("P.ine");
---------------
-------------
@@ -45,7 +45,7 @@
  * CDK atom types to be perceived.
  *
  * @author         egonw
- * @cdk.module     experimental
+ * @cdk.module     standard
  * @cdk.svnrev     $Revision: 9162 $
  * @cdk.created    2007-10-05
  * 
---------------
-------------
@@ -368,7 +368,7 @@
         IAtomContainer atomContainer = (IAtomContainer) o;
         if (!atomContainer.getProperty(CDKConstants.TITLE).equals(title)) return -1;
 
-        if (atomContainer.getAtomCount() != coordinates.size()) return -1;
+        if (atomContainer.getAtomCount() != coordinates.get(0).length) return -1;
 
         boolean coordsMatch;
         for (int j = coordinates.size() - 1; j >= 0; j--) {
---------------
-------------
@@ -45,7 +45,7 @@
     /**Number of maximum resonance structures*/
 	private int maxRS = 50;
 
-	private IMolecule molSigma;
+	private IAtomContainer molSigma;
 	private IAtomContainer acOldS;
 	private double[] marsiliFactors;
 	
---------------
-------------
@@ -222,7 +222,7 @@
 	 */
 	private boolean isTheSame(IIsotope isotopeOne, IIsotope isotopeTwo) {
 		
-		if(isotopeOne.getSymbol() != isotopeTwo.getSymbol() )
+		if(!isotopeOne.getSymbol().equals(isotopeTwo.getSymbol()) )
 			return false;
 		if(isotopeOne.getNaturalAbundance() != isotopeTwo.getNaturalAbundance() )
 			return false;
---------------
-------------
@@ -135,7 +135,6 @@
 
         try {
             events.put(event);
-            System.out.println("LA" + events.size());
         } catch (InterruptedException e) {
             logger.error("Thread was interrupted while trying to enqueue event ", e);
         }
---------------
-------------
@@ -257,8 +257,6 @@
    * Returns true iff {@link Similarity#coord(int,int)} is disabled in scoring
    * for the high and low frequency query instance. The top level query will
    * always disable coords.
-   * 
-   * @see #CommonTermsQuery(Occur, Occur, float, boolean)
    */
   public boolean isCoordDisabled() {
     return disableCoord;
---------------
-------------
@@ -76,7 +76,7 @@
   }
 
   void cleanup() {
-    assertU(delQ("id:[100 TO 110]"));
+    assertU(delQ("*:*"));
     assertU(commit());
   }
 
---------------
-------------
@@ -227,7 +227,7 @@
       int endTerm = numTermsInField;  // one past the end
 
       TermsEnum te = getOrdTermsEnum(searcher.getAtomicReader());
-      if (prefix != null && prefix.length() > 0) {
+      if (te != null && prefix != null && prefix.length() > 0) {
         final BytesRef prefixBr = new BytesRef(prefix);
         if (te.seekCeil(prefixBr, true) == TermsEnum.SeekStatus.END) {
           startTerm = numTermsInField;
---------------
-------------
@@ -1,5 +1,22 @@
 package org.apache.lucene.facet.search;
 
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Set;
---------------
-------------
@@ -104,7 +104,7 @@
     addParser("literal", new ValueSourceParser() {
       @Override
       public ValueSource parse(FunctionQParser fp) throws ParseException {
-        return new LiteralValueSource(fp.getString());
+        return new LiteralValueSource(fp.parseArg());
       }
     });
     addParser("rord", new ValueSourceParser() {
---------------
-------------
@@ -16,6 +16,7 @@
   // without breaking configs.
 
   private static final String SOURCE_HOME = determineSourceHome();
+  public static String WEBAPP_HOME = new File(SOURCE_HOME, "src/webapp/web").getAbsolutePath();
   public static String EXAMPLE_HOME = new File(SOURCE_HOME, "example/solr").getAbsolutePath();
   public static String EXAMPLE_MULTICORE_HOME = new File(SOURCE_HOME, "example/multicore").getAbsolutePath();
   public static String EXAMPLE_SCHEMA=EXAMPLE_HOME+"/conf/schema.xml";
---------------
-------------
@@ -228,7 +228,7 @@
    * This only supports bytes.length <= blockSize */
   public void copy(BytesRef bytes, BytesRef out) throws IOException {
     int left = blockSize - upto;
-    if (bytes.length > left) {
+    if (bytes.length > left || currentBlock==null) {
       if (currentBlock != null) {
         blocks.add(currentBlock);
         blockEnd.add(upto);
---------------
-------------
@@ -450,6 +450,8 @@
       for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {
         Map.Entry<Token, String> entry = bestIter.next();
         Token tok = entry.getKey();
+        // we are replacing the query in order, but injected terms might cause illegal offsets due to previous replacements.
+        if (tok.getPositionIncrement() == 0) continue;
         collation.replace(tok.startOffset() + offset, 
           tok.endOffset() + offset, entry.getValue());
         offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());
---------------
-------------
@@ -613,7 +613,6 @@
       resourceLoader.inform( resourceLoader );
       resourceLoader.inform( this );  // last call before the latch is released.
     } catch (Throwable e) {
-      log.error("Error in constructing the core", e);
       latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine
       //close down the searcher and any other resources, if it exists, as this is not recoverable
       close();
---------------
-------------
@@ -101,6 +101,7 @@
     if (len>0) {
       return pushed.charAt(len-1);
     }
+    numRead++;
     int ch = input.read();
     push(ch);
     return ch;
---------------
-------------
@@ -81,7 +81,7 @@
      *         OnNoTokenPolicy in case of NotAuthorizedException
      * @throws MuleException
      */
-    public final MuleEvent process(MuleEvent event) throws MuleException
+    public MuleEvent process(MuleEvent event) throws MuleException
     {
         try
         {
---------------
-------------
@@ -247,7 +247,7 @@
                     Message outMessage = m.getExchange().getOutMessage();
                     
                     Message contentMsg = null;
-                    if (outFaultMessage != null) 
+                    if (outFaultMessage != null && outFaultMessage.getContent(OutputStream.class) != null) 
                     {
                         contentMsg = outFaultMessage;
                     } 
---------------
-------------
@@ -81,7 +81,7 @@
      *         OnNoTokenPolicy in case of NotAuthorizedException
      * @throws MuleException
      */
-    public final MuleEvent process(MuleEvent event) throws MuleException
+    public MuleEvent process(MuleEvent event) throws MuleException
     {
         try
         {
---------------
-------------
@@ -1,3 +1,13 @@
+/*
+ * $Id$
+ * --------------------------------------------------------------------------------------
+ * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
+ *
+ * The software in this package is published under the terms of the CPAL v1.0
+ * license, a copy of which has been included with this distribution in the
+ * LICENSE.txt file.
+ */
+
 package org.mule.util;
 
 /**
---------------
-------------
@@ -111,7 +111,7 @@
     /**
      * Remove instance, used for testing only
      */
-    protected void reset() {
+    protected static void reset() {
         so = null;
     }
 }
---------------
-------------
@@ -380,7 +380,7 @@
 
         sb.append(INDENT + "public static void main(String[] args) {" + ENDL + ENDL)
             .append(INDENT + INDENT
-                    + "TemplateService service =" + "new ServiceFactory(serviceRootUrl,"
+                    + "TemplateService service = new ServiceFactory(serviceRootUrl,"
                         + " \"TemplateService\").getTemplateService();" + ENDL + ENDL)
             .append(INDENT + INDENT
                     + "List<TemplateParameter> parameters = new ArrayList<TemplateParameter>();"
---------------
-------------
@@ -90,7 +90,7 @@
             }
             query = new PathQuery(model);
 
-            if (attrs.getValue("title") != null && ! attrs.getValue("title").isEmpty()) {
+            if (attrs.getValue("title") != null && !attrs.getValue("title").isEmpty()) {
                 query.setTitle(attrs.getValue("title"));
             }
 
---------------
-------------
@@ -138,6 +138,7 @@
             } catch (InterruptedException e) {
             }
         }
+        notifyAll();
         return list.removeFirst();
     }
 
---------------
-------------
@@ -121,6 +121,7 @@
      *
      * @param pkgName name of package to generation Java code in
      * @param modelName the name of the model to produce
+     * @param nameSpace namespace of the target model
      */
     public XmlSchemaParser(String modelName, String pkgName, String nameSpace) {
         this.pkgName = pkgName;
---------------
-------------
@@ -71,7 +71,7 @@
             Constant objC = (Constant) obj;
             if ((value.charAt(0) == '\'') && (value.charAt(value.length() - 1) == '\'')
                     && (objC.value.charAt(0) == '\'')
-                    && (objC.value.charAt(value.length() - 1) == '\'')) {
+                    && (objC.value.charAt(objC.value.length() - 1) == '\'')) {
                 // Both this and obj are string constants.
                 return (value.compareTo(objC.value) < 0 ? LESS : GREATER);
             }
---------------
-------------
@@ -40,7 +40,7 @@
      * {@inheritDoc}
      */
     @Override
-	public int compare(Path arg0, Path arg1) {
+    public int compare(Path arg0, Path arg1) {
         if (arg0 == null || arg1 == null) {
             throw new RuntimeException("Paths must not be null");
         }
---------------
-------------
@@ -455,7 +455,6 @@
     public synchronized String generateApiKey(Profile profile) {
         String newApiKey = generateApiKey();
         profile.setApiKey(newApiKey);
-
         return newApiKey;
     }
 
---------------
-------------
@@ -151,7 +151,6 @@
             SequenceFeature ir = (SequenceFeature) irIter.next();
             objectStoreWriter.store(ir);
             objectStoreWriter.store(ir.getChromosomeLocation());
-            objectStoreWriter.store(ir.getSynonyms().iterator().next());
             Set<Gene> adjacentGenes = (Set<Gene>) ir.getFieldValue("adjacentGenes");
             Iterator<?> adjacentGenesIter = adjacentGenes.iterator();
             while (adjacentGenesIter.hasNext()) {
---------------
-------------
@@ -70,8 +70,6 @@
         this.osw = osw;
     }
 
-
-
     private void storeNewSequence(SequenceFeature feature, ClobAccess sequenceString)
         throws ObjectStoreException {
         Sequence sequence =
---------------
-------------
@@ -221,6 +221,7 @@
     protected void configureSynonymItem(OboTermSynonym syn, Item item, OboTerm term)
         throws ObjectStoreException {
         item.setAttribute("name", syn.getName());
+        item.setAttribute("type", syn.getType());
     }
 
     /**
---------------
-------------
@@ -337,7 +337,7 @@
                     if (((AttributeDescriptor) field).getType().equals("boolean")) {
                         sb.append("(" + field.getName() + " ? 0 : 1)");
                     } else {
-                        sb.append(field.getName());
+                        sb.append("((int) " + field.getName() + ")");
                     }
                 } else {
                     // sb.append(field.getName() + ".hashCode()");
---------------
-------------
@@ -836,7 +836,7 @@
                 if (subAST.getType() != SqlTokenTypes.SQL_STATEMENT) {
                     throw (new IllegalArgumentException("Expected: a SQL SELECT statement"));
                 }
-                Query rightb = new Query();
+                Query rightb = new Query(aliasToTable);
                 rightb.processAST(subAST.getFirstChild());
                 return new SubQueryConstraint(leftb, rightb);
             default:
---------------
-------------
@@ -501,8 +501,6 @@
                 rAll = new ArrayList(rAll);
                 statsCalcCache.put(queryPopulation.toString(), rAll);
             }
-            LOG.error("statCalcCache: " + statsCalcCache);
-            LOG.error("from: " + querySample.getFrom());
             
             Iterator itAll = rAll.iterator();
 
---------------
-------------
@@ -127,7 +127,7 @@
                                                                    mapArray[i]).getIdentifier());
                     }
                     Item gene = createItem("Gene");
-                    gene.setAttribute("secondaryIdentifier", geneName);
+                    gene.setAttribute("identifier", geneName);
                     gene.setReference("organism", organism);
 
                     gene.addCollection(referenceList);
---------------
-------------
@@ -475,7 +475,7 @@
         // finally add an index to all M-to-N indirection table columns
         for (CollectionDescriptor col : cld.getCollectionDescriptors()) {
             if (FieldDescriptor.M_N_RELATION == col.relationType()) {
-                String tableName = DatabaseUtil.getIndirectionTableName(col);
+                String tableName = DatabaseUtil.getIndirectionTableName(col).toLowerCase();
                 String columnName = DatabaseUtil.getInwardIndirectionColumnName(col,
                         schema.getVersion());
                 String columnName2 = DatabaseUtil.getOutwardIndirectionColumnName(col,
---------------
-------------
@@ -233,7 +233,7 @@
                 .append(INDENT + "or die 'Could not find template';" + ENDL)
                 .append(ENDL)
                 .append(constraintComments.toString() + ENDL)
-                .append("my $results  = $template->results_with(" + ENDL)
+                .append("my $results = $template->results_with(" + ENDL)
                 .append(INDENT + "as     => 'string'," + ENDL)
                 .append(constraints.toString())
                 .append(");" + ENDL)
---------------
-------------
@@ -103,7 +103,7 @@
     }
 
     private String hierarchyUri(Episode episode) {
-        for (String alias : episode.getAliases()) {
+        for (String alias : episode.getAliasUrls()) {
             if (C4AtomApi.isACanonicalEpisodeUri(alias)) {
                 return alias;
             }
---------------
-------------
@@ -181,7 +181,7 @@
         if (version.getManifestedAs().isEmpty()) {
         	Encoding encoding = Iterables.getFirst(version.getManifestedAs(), new Encoding());
         	updateEncoding(version, encoding, entry);
-        	if (!version.getManifestedAs().contains(encoding)) {
+        	if (!encoding.getAvailableAt().isEmpty() && !version.getManifestedAs().contains(encoding)) {
         		version.addManifestedAs(encoding);
         	}
         } else {
---------------
-------------
@@ -42,7 +42,7 @@
 
     @Override
     public Map<String, List<Identified>> executeUriQuery(Iterable<String> uris, final ContentQuery query) {
-        Map<String, List<Identified>> results = resolveMongoEntries(query, mongoLookupResolver.entriesForUris(uris));
+        Map<String, List<Identified>> results = resolveMongoEntries(query, mongoLookupResolver.entriesForIdentifiers(uris));
         if (results.isEmpty()) {
             results = resolveCassandraEntries(uris, query);
         }
---------------
-------------
@@ -12,6 +12,7 @@
     private static final Map<Pattern, String> PATTERNS_TO_REMOVE = ImmutableMap.<Pattern, String>builder()
             .put(Pattern.compile("ZQ[A-Z]{1}"), "")
             .put(Pattern.compile("_"), " ")
+            .put(Pattern.compile(" \\(Curzon\\)$"), "")
             .build()
     ;
 
---------------
-------------
@@ -97,7 +97,7 @@
                     Lists.newArrayList(YOUVIEW), 
                     youViewChannelResolver().getAllChannels(),
                     0,
-                    8
+                    7
                 ).withName("YouView Schedule Equivalence (8 day) Updater"), RepetitionRules.NEVER);
         }
     }
---------------
-------------
@@ -181,7 +181,7 @@
         if (version.getManifestedAs().isEmpty()) {
         	Encoding encoding = Iterables.getFirst(version.getManifestedAs(), new Encoding());
         	updateEncoding(version, encoding, entry);
-        	if (!version.getManifestedAs().contains(encoding)) {
+        	if (!encoding.getAvailableAt().isEmpty() && !version.getManifestedAs().contains(encoding)) {
         		version.addManifestedAs(encoding);
         	}
         } else {
---------------
-------------
@@ -237,7 +237,7 @@
         
         String id = entry.slotId();
         if (id != null) {
-            broadcast.withId("c4:" + id);
+            broadcast.withId(id);
         }
 
         return broadcast;
---------------
-------------
@@ -56,7 +56,7 @@
 			} catch (JAXBException e) {
 				log.record(new AdapterLogEntry(Severity.INFO).withCause(e).withDescription("Couldn't create BBC Schedule Updater task"));
 			}
-			scheduler.schedule(bbcIonOndemandChangeUpdater(), HOURLY);
+			scheduler.schedule(bbcIonOndemandChangeUpdater(), FIFTEEN_MINUTES);
 			log.record(new AdapterLogEntry(Severity.INFO)
 				.withDescription("BBC update scheduled tasks installed"));
 		} else {
---------------
-------------
@@ -42,7 +42,7 @@
 
     @Override
     public Map<String, List<Identified>> executeUriQuery(Iterable<String> uris, final ContentQuery query) {
-        Map<String, List<Identified>> results = resolveMongoEntries(query, mongoLookupResolver.entriesForUris(uris));
+        Map<String, List<Identified>> results = resolveMongoEntries(query, mongoLookupResolver.entriesForIdentifiers(uris));
         if (results.isEmpty()) {
             results = resolveCassandraEntries(uris, query);
         }
---------------
-------------
@@ -67,7 +67,6 @@
         this.entryProcessor = entryProcessor;
         this.brandlessEntryProcessor = brandlessEntryProcessor;
     }
-    
 
     @Override
     protected void runTask() {
---------------
-------------
@@ -54,7 +54,7 @@
     public String getId(Action action);
 
     /**
-     * Registers the specified action with the specified id. Note that IDEA's keymaps
+     * Registers the specified action with the specified id. Note that IDE keymaps
      * processing deals only with registered actions.
      *
      * @param actionId
---------------
-------------
@@ -13,7 +13,7 @@
 			Field[] fields = clazz.getDeclaredFields();
 			for (Field field : fields) {
 
-				if (field.getType().isAssignableFrom(type)) {
+				if (type.isAssignableFrom(field.getType())) {
 					return (T) new FieldGetter(testInstance, field).get();
 				}
 			}
---------------
-------------
@@ -191,6 +191,7 @@
         private FilteringIterator(Iterator<T> i, Predicate<? super T> filter) {
             this.i = i;
             this.filter = filter;
+            hasNext(); // allow next() to be called without hasNext()
         }
         @Override
         public void remove() {
---------------
-------------
@@ -69,7 +69,7 @@
 
 	@Override
 	public void onReceive(Object o) throws Exception {
-	   // getSender().tell(o, getSelf());
+	    // do nothing
 	}
 
     }
---------------
-------------
@@ -39,7 +39,7 @@
 	/**
 	 * Defines a non-capturing group for postgres or edb
 	 */
-	private static final String VENDOR_LIST  =  JDBC_PREFIX + ":(?:postgres|edb)";
+	private static final String VENDOR_LIST  =  JDBC_PREFIX + ":(?:postgresql|edb)";
 	
 	/**
 	 * Defines a group for IPv6, IPv4 IPs and host names<br/>
---------------
-------------
@@ -58,7 +58,7 @@
         if (layerInfo != null) {
             return layerInfo.getResource().prefixedName();
         } else {
-            return groupInfo.getName();
+            return groupInfo.prefixedName();
         }
     }
     
---------------
-------------
@@ -8,7 +8,7 @@
 import org.geotools.feature.type.GeometryDescriptorImpl;
 import org.geotools.feature.type.GeometryTypeImpl;
 import org.geotools.geometry.jts.CurvedGeometry;
-import org.geotools.gml3.MultiCurvedGeometry;
+import org.geotools.geometry.jts.MultiCurvedGeometry;
 import org.opengis.feature.Property;
 import org.opengis.feature.type.AttributeType;
 import org.opengis.feature.type.FeatureType;
---------------
-------------
@@ -132,6 +132,7 @@
         expect(ns.getName()).andReturn(name).anyTimes();
         expect(ns.getPrefix()).andReturn(name).anyTimes();
         expect(ns.getMetadata()).andReturn(new MetadataMap()).anyTimes();
+        expect(ns.getURI()).andReturn(uri).anyTimes();
     
         expect(catalog.getNamespace(nsId)).andReturn(ns).anyTimes();
         expect(catalog.getNamespaceByPrefix(name)).andReturn(ns).anyTimes();
---------------
-------------
@@ -58,7 +58,7 @@
         if (layerInfo != null) {
             return layerInfo.getResource().prefixedName();
         } else {
-            return groupInfo.getName();
+            return groupInfo.prefixedName();
         }
     }
     
---------------
-------------
@@ -75,7 +75,7 @@
             String contactEmail = contact.getContactEmail();
             HashMap<String, String>params = new HashMap<String, String>();
             params.put("version", version);
-            params.put("contactEmail", contactEmail);
+            params.put("contactEmail", (contactEmail == null ? "geoserver@example.org" : contactEmail));
             Label label = new Label("footerMessage", new StringResourceModel("GeoServerHomePage.footer", this, new Model(params)));
             label.setEscapeModelStrings(false);
             add(label);
---------------
-------------
@@ -1262,7 +1262,7 @@
             // GeoServer does not need to be updated to the multicoverage stuff
             // (we might want to introduce a hint later for code that really wants to get the
             // multi-coverage reader)
-            return new SingleGridCoverage2DReader((GridCoverage2DReader) reader, coverageName);
+            return SingleGridCoverage2DReader.wrap((GridCoverage2DReader) reader, coverageName);
         } else {
             return (GridCoverage2DReader) reader;
         }
---------------
-------------
@@ -123,7 +123,7 @@
     }
 
     public String prefixedName() {
-        return prefixedName();
+        return delegate.prefixedName();
     }
 
     public ProjectionPolicy getProjectionPolicy() {
---------------
-------------
@@ -173,7 +173,7 @@
                     layerAtts.addAttribute("", "owsType", "owsType", "", owsType);
                 }
 
-                layerAtts.setAttribute(0, "", "name", "name", "", layer.getName());
+                layerAtts.setAttribute(0, "", "name", "name", "", layer.getLayerInfo().prefixedName());
                 start("LayerDescription", layerAtts);
 
                 queryAtts.setAttribute(0, "", "typeName", "typeName", "", layer.getName());
---------------
-------------
@@ -13,7 +13,7 @@
 /**
  * Class to retrieve the list of fonts available in GeoServer
  *
- * @author Jose Garc�a
+ * @author Jose Garca
  */
 public class FontListResource extends MapResource {
 
---------------
-------------
@@ -132,6 +132,7 @@
         expect(ns.getName()).andReturn(name).anyTimes();
         expect(ns.getPrefix()).andReturn(name).anyTimes();
         expect(ns.getMetadata()).andReturn(new MetadataMap()).anyTimes();
+        expect(ns.getURI()).andReturn(uri).anyTimes();
     
         expect(catalog.getNamespace(nsId)).andReturn(ns).anyTimes();
         expect(catalog.getNamespaceByPrefix(name)).andReturn(ns).anyTimes();
---------------
-------------
@@ -42,7 +42,7 @@
     static {
         try {
             final SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
-            WCS11_SCHEMA = factory.newSchema(new File("./schemas/wcs/1.1.1/wcsAll.xsd"));
+            WCS11_SCHEMA = factory.newSchema(new File("wcs1_1/schemas/wcs/1.1.1/wcsAll.xsd"));
         } catch(Exception e) {
             throw new RuntimeException("Could not parse the WCS 1.1.1 schemas", e);
         }
---------------
-------------
@@ -1074,7 +1074,7 @@
                 PropertyImpl prop = (PropertyImpl) itemMgr.getItem(id);
                 PropertyDefinition oldDef = affectedProps.get(id);
 
-                if (prop.getDefinition().isProtected()) {
+                if (oldDef.isProtected()) {
                     // remove 'orphaned' protected properties immediately
                     removeChildProperty(id.getName());
                     continue;
---------------
-------------
@@ -63,6 +63,7 @@
         suite.addTestSuite(ParentNodeTest.class);
         suite.addTestSuite(SimilarQueryTest.class);
         suite.addTestSuite(FulltextSQL2QueryTest.class);
+        suite.addTestSuite(LimitAndOffsetTest.class);
 
         return suite;
     }
---------------
-------------
@@ -133,7 +133,7 @@
 
         public void characters(char[] ch, int start, int length) {
             boolean space = false;
-            for (int i = start; i < length; i++) {
+            for (int i = start; i < start + length; i++) {
                 if (Character.isLetterOrDigit(ch[i])) {
                     if (space) {
                         buffer.append(' ');
---------------
-------------
@@ -1023,6 +1023,7 @@
     props.put(Overseer.QUEUE_OPERATION, CollectionAction.ADDREPLICA.toString());
     copyIfNotNull(req.getParams(), props, COLLECTION_PROP, "node", SHARD_ID_PROP, ShardParams._ROUTE_,
         CoreAdminParams.NAME, CoreAdminParams.INSTANCE_DIR, CoreAdminParams.DATA_DIR, ASYNC);
+    copyPropertiesIfNotNull(req.getParams(), props);
     ZkNodeProps m = new ZkNodeProps(props);
     handleResponse(CollectionAction.ADDREPLICA.toString(), m, rsp);
   }
---------------
-------------
@@ -257,8 +257,6 @@
    * Returns true iff {@link Similarity#coord(int,int)} is disabled in scoring
    * for the high and low frequency query instance. The top level query will
    * always disable coords.
-   * 
-   * @see #CommonTermsQuery(Occur, Occur, float, boolean)
    */
   public boolean isCoordDisabled() {
     return disableCoord;
---------------
-------------
@@ -43,6 +43,13 @@
  * will match a significant amount of the term dictionary. If you really want this, consider
  * using an n-gram indexing technique (such as the SpellChecker in the 
  * <a href="{@docRoot}/../suggest/overview-summary.html">suggest module</a>) instead.
+ *
+ * <p>NOTE: terms of length 1 or 2 will sometimes not match because of how the scaled
+ * distance between two terms is computed.  For a term to match, the edit distance between
+ * the terms must be less than the minimum length term (either the input term, or
+ * the candidate term).  For example, FuzzyQuery on term "abcd" with maxEdits=2 will
+ * not match an indexed term "ab", and FuzzyQuery on term "a" with maxEdits=2 will not
+ * match an indexed term "abc".
  */
 public class FuzzyQuery extends MultiTermQuery {
   
---------------
-------------
@@ -16,6 +16,7 @@
   // without breaking configs.
 
   private static final String SOURCE_HOME = determineSourceHome();
+  public static String WEBAPP_HOME = new File(SOURCE_HOME, "src/webapp/web").getAbsolutePath();
   public static String EXAMPLE_HOME = new File(SOURCE_HOME, "example/solr").getAbsolutePath();
   public static String EXAMPLE_MULTICORE_HOME = new File(SOURCE_HOME, "example/multicore").getAbsolutePath();
   public static String EXAMPLE_SCHEMA=EXAMPLE_HOME+"/conf/schema.xml";
---------------
-------------
@@ -76,7 +76,7 @@
   }
 
   void cleanup() {
-    assertU(delQ("id:[100 TO 110]"));
+    assertU(delQ("*:*"));
     assertU(commit());
   }
 
---------------
-------------
@@ -450,6 +450,8 @@
       for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {
         Map.Entry<Token, String> entry = bestIter.next();
         Token tok = entry.getKey();
+        // we are replacing the query in order, but injected terms might cause illegal offsets due to previous replacements.
+        if (tok.getPositionIncrement() == 0) continue;
         collation.replace(tok.startOffset() + offset, 
           tok.endOffset() + offset, entry.getValue());
         offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());
---------------
-------------
@@ -91,7 +91,7 @@
   public double getLongitude() {
     if (Math.abs(x) < MINIMUM_RESOLUTION && Math.abs(y) < MINIMUM_RESOLUTION)
       return 0.0;
-    return Math.atan2(y,z);
+    return Math.atan2(y,x);
   }
   
   /** Compute the linear magnitude of the point.
---------------
-------------
@@ -276,7 +276,7 @@
       if (o1.value > o2.value) {
         return 1;
       } else if (o1.value < o2.value) {
-        return 0;
+        return -1;
       }
 
       // otherwise on alphabetic order
---------------
-------------
@@ -20,6 +20,7 @@
 /**
  * Exception thrown when an error happening while mapping UIMA CAS model to Solr fields
  */
+@SuppressWarnings("serial")
 public class FieldMappingException extends Exception {
   public FieldMappingException(Exception e) {
     super(e);
---------------
-------------
@@ -104,7 +104,7 @@
     addParser("literal", new ValueSourceParser() {
       @Override
       public ValueSource parse(FunctionQParser fp) throws ParseException {
-        return new LiteralValueSource(fp.getString());
+        return new LiteralValueSource(fp.parseArg());
       }
     });
     addParser("rord", new ValueSourceParser() {
---------------
-------------
@@ -227,7 +227,7 @@
       int endTerm = numTermsInField;  // one past the end
 
       TermsEnum te = getOrdTermsEnum(searcher.getAtomicReader());
-      if (prefix != null && prefix.length() > 0) {
+      if (te != null && prefix != null && prefix.length() > 0) {
         final BytesRef prefixBr = new BytesRef(prefix);
         if (te.seekCeil(prefixBr, true) == TermsEnum.SeekStatus.END) {
           startTerm = numTermsInField;
---------------
-------------
@@ -228,7 +228,7 @@
    * This only supports bytes.length <= blockSize */
   public void copy(BytesRef bytes, BytesRef out) throws IOException {
     int left = blockSize - upto;
-    if (bytes.length > left) {
+    if (bytes.length > left || currentBlock==null) {
       if (currentBlock != null) {
         blocks.add(currentBlock);
         blockEnd.add(upto);
---------------
-------------
@@ -101,6 +101,7 @@
     if (len>0) {
       return pushed.charAt(len-1);
     }
+    numRead++;
     int ch = input.read();
     push(ch);
     return ch;
---------------
-------------
@@ -613,7 +613,6 @@
       resourceLoader.inform( resourceLoader );
       resourceLoader.inform( this );  // last call before the latch is released.
     } catch (Throwable e) {
-      log.error("Error in constructing the core", e);
       latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine
       //close down the searcher and any other resources, if it exists, as this is not recoverable
       close();
---------------
-------------
@@ -202,7 +202,7 @@
       //then be sure all of the new words have the same optional/required/prohibited status in the query.
       while(indexOfSpace>-1 && indexOfSpace<corr.length()-1) {
         addParenthesis = true;
-        char previousChar = tok.startOffset()>0 ? collation.charAt(tok.startOffset()-1) : ' ';
+        char previousChar = tok.startOffset()>0 ? origQuery.charAt(tok.startOffset()-1) : ' ';
         if(previousChar=='-' || previousChar=='+') {
           corrSb.insert(indexOfSpace + bump, previousChar);
           if(requiredOrProhibited==null) {
---------------
-------------
@@ -1,5 +1,22 @@
 package org.apache.lucene.facet.search;
 
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Set;
---------------
-------------
@@ -117,7 +117,7 @@
             content = Util.result(getStatus()) + "<span class=\"step-keyword\">" + keyword + " </span><span class=\"step-name\">" + name + "</span><span class=\"step-duration\">" + Util.formatDuration(result.getDuration()) + "</span><div class=\"step-error-message\"><pre>" + formatError(errorMessage) + "</pre></div>" + Util.closeDiv() + getImageTags();
         } else if (getStatus() == Util.Status.MISSING) {
             String errorMessage = "<span class=\"missing\">Result was missing for this step</span>";
-            content = Util.result(getStatus()) + "<span class=\"step-keyword\">" + keyword + " </span><span class=\"step-name\">" + name + "</span><span class=\"step-duration\">" + Util.formatDuration(result.getDuration()) + "</span><div class=\"step-error-message\"><pre>" + formatError(errorMessage) + "</pre></div>" + Util.closeDiv();
+            content = Util.result(getStatus()) + "<span class=\"step-keyword\">" + keyword + " </span><span class=\"step-name\">" + name + "</span><span class=\"step-duration\"></span><div class=\"step-error-message\"><pre>" + formatError(errorMessage) + "</pre></div>" + Util.closeDiv();
         } else {
             content = getNameAndDuration();
         }
---------------
-------------
@@ -117,7 +117,7 @@
             content = Util.result(getStatus()) + "<span class=\"step-keyword\">" + keyword + " </span><span class=\"step-name\">" + name + "</span><span class=\"step-duration\">" + Util.formatDuration(result.getDuration()) + "</span><div class=\"step-error-message\"><pre>" + formatError(errorMessage) + "</pre></div>" + Util.closeDiv() + getImageTags();
         } else if (getStatus() == Util.Status.MISSING) {
             String errorMessage = "<span class=\"missing\">Result was missing for this step</span>";
-            content = Util.result(getStatus()) + "<span class=\"step-keyword\">" + keyword + " </span><span class=\"step-name\">" + name + "</span><span class=\"step-duration\">" + Util.formatDuration(result.getDuration()) + "</span><div class=\"step-error-message\"><pre>" + formatError(errorMessage) + "</pre></div>" + Util.closeDiv();
+            content = Util.result(getStatus()) + "<span class=\"step-keyword\">" + keyword + " </span><span class=\"step-name\">" + name + "</span><span class=\"step-duration\"></span><div class=\"step-error-message\"><pre>" + formatError(errorMessage) + "</pre></div>" + Util.closeDiv();
         } else {
             content = getNameAndDuration();
         }
---------------
-------------
@@ -183,6 +183,7 @@
     }
     leafCount++;
     count++;
+    leavesSorted = (leafCount == 1);
   }
 
   @Override
---------------
-------------
@@ -42,7 +42,7 @@
      * @return the size that each message takes up in bytes
      */
     public int getSizeInBytes() {
-        return inspector.getSizeInBytes();
+        return Primitive.INT.sizeInBytes + inspector.getSizeInBytes();
     }
 
     public <I> I newFlyweight(Class<I> implementationParent, String templateFile, Object ... args) {
---------------
-------------
@@ -31,7 +31,7 @@
 
   private static final String ROLE = "HIVE";
   private static final String NAME = "hive";
-  private static final String EXTERNAL_PATH = "/hive/api/vi";
+  private static final String EXTERNAL_PATH = "/hive/api/v1";
 
   @Override
   public String getRole() {
---------------
-------------
@@ -145,7 +145,6 @@
           }
           if (groupsMapped) {
             addMappedGroupsToSubject(mappedPrincipalName, groups, subject);
-            addMappedGroupsToSubject("*", groups, subject);
           }
           doAs(request, response, chain, subject);
         }
---------------
-------------
@@ -165,5 +165,6 @@
   }
 
   public class TooManyPlayersException extends Exception {
+    private static final long serialVersionUID = -6603422097641992017L;
   }
 }
---------------
-------------
@@ -40,29 +40,6 @@
 	private Utils() {
 	}
 	
-//	public static File createRootDeploymentFile(File dest, String deployment) {
-//		StringBuilder path = new StringBuilder();
-//		path.append(dest.getAbsolutePath());
-//		path.append("/ROOT.");
-//		
-//		String dep = deployment.toLowerCase();
-//		if (isURL(dep)) {
-//			if (dep.contains(".ear")) {
-//				path.append("ear");
-//			} else if (dep.contains(".war")) {
-//				path.append("war");
-//			} else if (dep.contains("ear")) { // TODO: fuzzy! might be just part of the url e.g. /bear
-//				path.append("ear");
-//			} else { 						  
-//				path.append("war");
-//			}
-//		} else {
-//			path.append(getExtension(dep));
-//		}
-//		
-//		return new File(path.toString());
-//	}
-//	
 	public static boolean isURL(String str) {
 		return str.startsWith("http://") || str.startsWith("https://");
 	}
---------------
-------------
@@ -76,7 +76,7 @@
 		}};
 	
 	/** {@link Pattern} which matches a binding configuration part */
-	private static final Pattern BASE_CONFIG_PATTERN = Pattern.compile("(<|>)\\[(.*?)\\]");
+	private static final Pattern BASE_CONFIG_PATTERN = Pattern.compile("(<|>)\\[(.*?)\\](\\s|$)");
 	
 	/** {@link Pattern} which matches an In-Binding */
 	private static final Pattern IN_BINDING_PATTERN = Pattern.compile("(.*?):(?!//)(\\d*):(.*)");
---------------
-------------
@@ -277,6 +277,8 @@
                     matchCount = 0;
                 }
             } else {
+                // fix for DIRMINA-506
+                in.position(in.position()-matchCount);
                 matchCount = 0;
             }
         }
---------------
-------------
@@ -581,8 +581,7 @@
      * @see ByteBuffer#mark()
      */
     public void mark() {
-        // FIXME: this is broken and untested (it should set the mark instead of limit)
-        this.limit = position.duplicate();
+        this.mark = position.duplicate();
     }
 
     /**
---------------
-------------
@@ -53,7 +53,6 @@
     TrainingPlatformInfo trainingPlatformInfo = trainingPlatformInfoDao.get(trainingPlatformInfoDto
         .getTrainingPlatformInfoId());
     AppExceptionUtil.assertNotNull(trainingPlatformInfo);
-
     if (trainingPlatformInfoDto.getTrainingUserId() != null) {
       trainingPlatformInfo.setTrainingUserId(trainingPlatformInfoDto.getTrainingUserId());
     }
---------------
-------------
@@ -53,7 +53,7 @@
     TrainingPlatformInfo trainingPlatformInfo = trainingPlatformInfoDao.get(trainingPlatformInfoDto
         .getTrainingPlatformInfoId());
     AppExceptionUtil.assertNotNull(trainingPlatformInfo);
-
+    
     if (trainingPlatformInfoDto.getTrainingUserId() != null) {
       trainingPlatformInfo.setTrainingUserId(trainingPlatformInfoDto.getTrainingUserId());
     }
---------------
-------------
@@ -30,6 +30,7 @@
  * your own risk.
  * </p>
  */
+@SuppressWarnings( "deprecation" )
 public class TestSession implements HttpSession {
 
   private final Map<String,Object> attributes;
---------------
-------------
@@ -11,7 +11,6 @@
 
 import java.io.IOException;
 
-import org.eclipse.rwt.internal.lifecycle.JSConst;
 import org.eclipse.rwt.lifecycle.*;
 import org.eclipse.swt.SWT;
 import org.eclipse.swt.custom.CCombo;
---------------
-------------
@@ -837,11 +837,6 @@
     if( hHint != SWT.DEFAULT ) {
       height = hHint;
     }
-    // TODO [rst] Workaround for two missing pixels (Ö, p are cut off), revise
-    // TODO [if] Move to fragment. These two pixels are hard-coded in qooxdoo
-    // TextField.js to emulate IE hard-coded margin.
-    // See also: https://bugzilla.mozilla.org/show_bug.cgi?id=73817
-    height += 2;
     // [rh] Fix for bug 306354: take into account that there is now 1px
     // right padding on the client side (see Text.js#_applyElement)
     width += 1;
---------------
-------------
@@ -89,7 +89,7 @@
     writer.newWidget( "org.eclipse.rwt.widgets.Tree" );
     ControlLCAUtil.writeStyleFlags( tree );
     if( ( tree.getStyle() & SWT.NO_SCROLL ) != 0 ) {
-      writer.set( "noScroll", true );
+      writer.set( "hasNoScroll", true );
     }
     if( ( tree.getStyle() & SWT.MULTI ) != 0 ) {
       writer.set( "hasMultiSelection", true );
---------------
-------------
@@ -177,7 +177,6 @@
     Fixture.setUp();
     System.setProperty( IInitialization.PARAM_LIFE_CYCLE, 
                         RWTLifeCycle.class.getName() );
-    LifeCycleServiceHandler.configurer = null;
 
     // registration of adapter factories
     registerAdapterFactories();
---------------
-------------
@@ -85,6 +85,7 @@
 		jsonObject.put("skipBuildPhrase", "[skip ci]");
 		jsonObject.put("cron", "*/1 * * * *");
 		jsonObject.put("useComments", "true");
+		jsonObject.put("useDetailedComments", "false");
 		jsonObject.put("logExcerptLines", "0");
 		jsonObject.put("unstableAs", "");
 		jsonObject.put("testMode", "true");
---------------
-------------
@@ -24,6 +24,7 @@
     edu.isi.pegasus.common.util.VersionTest.class,
     edu.isi.pegasus.common.util.PegasusURLTest.class,
     edu.isi.pegasus.planner.namespace.PegasusTest.class,
+    edu.isi.pegasus.planner.cluster.RuntimeClusteringTest.class,
     edu.isi.pegasus.planner.transfer.mapper.FlatOutputMapperTest.class,
     edu.isi.pegasus.planner.transfer.mapper.HashedOutputMapperTest.class,
     edu.isi.pegasus.planner.transfer.mapper.ReplicaOutputMapperTest.class,
---------------
-------------
@@ -25,7 +25,7 @@
     edu.isi.pegasus.common.util.PegasusURLTest.class,
     edu.isi.pegasus.planner.namespace.PegasusTest.class,
     edu.isi.pegasus.planner.catalog.replica.impl.RegexRCTest.class,
-    //edu.isi.pegasus.planner.catalog.replica.impl.JDBCRCTest.class,
+    edu.isi.pegasus.planner.catalog.replica.impl.JDBCRCTest.class,
     edu.isi.pegasus.planner.cluster.RuntimeClusteringTest.class,
     edu.isi.pegasus.planner.code.generator.condor.style.GliteTest.class,
     edu.isi.pegasus.planner.transfer.mapper.FlatOutputMapperTest.class,
---------------
-------------
@@ -138,6 +138,8 @@
     IndentCell container = cell.indentContainer();
     Rectangle bounds = container.getBounds();
 
+    if (cell.children().isEmpty()) return bounds;
+
     Cell firstLeaf = firstVisibleLeaf(cell);
     if (firstLeaf == null) return null;
 
---------------
-------------
@@ -88,6 +88,8 @@
   }
 
   public void visibilityChanged(SourceCT item, PropertyChangeEvent<Boolean> change) {
+    if (item == root()) return;
+
     if (change.getNewValue()) {
       childAdded(item, false);
     } else {
---------------
-------------
@@ -76,7 +76,7 @@
         @Override
         public void onKeyPressedLowPriority(Cell cell, KeyEvent event) {
           try {
-            if (getSelectedItems().isEmpty()) {
+            if (getSelectedItems().size() <= 1) {
               keyPressedInChild(event);
             }
           } finally {
---------------
-------------
@@ -150,6 +150,7 @@
       Iterator<Position<SourceCT>> positions = nextNewLinePos == null ? toEnd(insertAt.next()) : range(insertAt.next(), nextNewLinePos);
       while (positions.hasNext()) {
         SourceCT part = positions.next().get();
+        if (!myIndentUpdaterSource.isCell(part)) continue;
         Cell cell = myIndentUpdaterSource.getCell(part);
         CellWrapper<TargetT> wrapper = myWrappers.get(cell);
         TargetT item = wrapper.item();
---------------
-------------
@@ -95,7 +95,7 @@
 
     @Override
     public void add(int index, Vector element) {
-      Vector relative = element.add(toRootDelta().get());
+      Vector relative = element.sub(toRootDelta().get());
       myRelativePoints.add(index, relative);
       invalidate();
       firePointsChange();
---------------
-------------
@@ -126,7 +126,7 @@
       if (isLast(index)) {
         selectHome(index);
       } else if (isFirst(index)) {
-        selectEnd(index);
+        selectHome(index);
       } else {
         selectEnd(index - 1);
       }
---------------
-------------
@@ -238,7 +238,7 @@
             if (numericPair == null) {
                 thisPair = categoricalPair;
             }  else {
-                thisPair = (numericPair.getValue1() < categoricalPair.getValue1()) ? numericPair : categoricalPair;
+                thisPair = (numericPair.getValue1() > categoricalPair.getValue1()) ? numericPair : categoricalPair;
             }
             if (bestPair == null || thisPair.getValue1() > bestPair.getValue1()) {
                 bestPair = thisPair;
---------------
-------------
@@ -371,7 +371,7 @@
 
 	long totalBases = 0;
 	for(GenomeLoc loc : locs)
-	    totalBases += loc.getStop() - loc.getStart();
+	    totalBases += loc.size();
 
 	long idealBasesPerPart = totalBases / scatterParts.size();
 	if(idealBasesPerPart == 0)
---------------
-------------
@@ -878,7 +878,7 @@
                     int stop = region.getStop() - windowHeaderStart;
 
                     // make sure the bitset is complete given the region (it might not be in multi-sample mode)
-                    if ( region.getStop() > markedSites.getStartLocation() + markedSites.getVariantSiteBitSet().length )
+                    if ( region.getStop() > markedSites.getStartLocation() + markedSites.getVariantSiteBitSet().length - 1 )
                         markSites(region.getStop());
 
                     CloseVariantRegionResult closeVariantRegionResult = closeVariantRegion(start, stop, knownSnpPositions);
---------------
-------------
@@ -1153,7 +1153,7 @@
     }
 
     private static final List<Allele> NO_CALL_ALLELES = Arrays.asList(Allele.NO_CALL, Allele.NO_CALL);
-    public static final double SUM_GL_THRESH_NOCALL = -0.001; // if sum(gl) is bigger than this threshold, we treat GL's as non-informative and will force a no-call.
+    public static final double SUM_GL_THRESH_NOCALL = -0.1; // if sum(gl) is bigger than this threshold, we treat GL's as non-informative and will force a no-call.
 
     /**
      * subset the Variant Context to the specific set of alleles passed in (pruning the PLs appropriately)
---------------
-------------
@@ -81,7 +81,7 @@
         final int readStart = read.getSoftStart();
         final int readStop = read.getSoftEnd();
         if ( loc == null )
-            loc = parser.createGenomeLoc(read.getReferenceName(), readStart, readStop);
+            loc = parser.createGenomeLoc(read.getReferenceName(), readStart, Math.max(readStop, readStart)); // in case it's all an insertion
         else if ( readStop > loc.getStop() )
             loc = parser.createGenomeLoc(loc.getContig(), loc.getStart(), readStop);
 
---------------
-------------
@@ -374,7 +374,7 @@
         int start = 1;
         int stop = -1;
 
-        final int colonIndex = str.indexOf(":");
+        final int colonIndex = str.lastIndexOf(":");
         if(colonIndex == -1) {
             contig = str.substring(0, str.length());  // chr1
             stop = Integer.MAX_VALUE;
---------------
-------------
@@ -298,7 +298,7 @@
 
             switch (ce.getOperator()) {
                 case I:
-                case S:
+                case S: // TODO -- I don't think that soft clips should be treated the same as inserted bases here. Investigation needed.
                     pos += elementLength;
                     if (pos >= pileupOffset) {
                         return alignmentPos;
---------------
-------------
@@ -47,8 +47,8 @@
         Scanner scanner = new Scanner(indexFile);
 
         while( scanner.hasNext() ) {
-            // Tokenize and validate the index line.
-            String result = scanner.findInLine("([\\w\\s\\.]+)\\t+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)");
+            // Tokenize and validate the index line.                     
+            String result = scanner.findInLine("(.+)\\t+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)");
             if( result == null )
                 throw new PicardException("Found invalid line in index file:" + scanner.nextLine());
             MatchResult tokens = scanner.match();
---------------
-------------
@@ -414,7 +414,7 @@
      * @return vc subcontext
      */
     public VariantContext subContextFromGenotypes(Collection<Genotype> genotypes, Set<Allele> alleles) {
-        return new VariantContext(getSource(), contig, start, stop, alleles, genotypes, getNegLog10PError(), getFilters(), getAttributes());
+        return new VariantContext(getSource(), contig, start, stop, alleles, genotypes, getNegLog10PError(), filtersWereApplied() ? getFilters() : null, getAttributes());
     }
 
 
---------------
-------------
@@ -50,7 +50,7 @@
     @Argument(fullName="numKMeans", shortName="nKM", doc="The number of k-means iterations to perform in order to initialize the means of the Gaussians in the Gaussian mixture model.", required=false)
     public int NUM_KMEANS_ITERATIONS = 30;
     @Argument(fullName="stdThreshold", shortName="std", doc="If a variant has annotations more than -std standard deviations away from mean then don't use it for building the Gaussian mixture model.", required=false)
-    public double STD_THRESHOLD = 8.0;
+    public double STD_THRESHOLD = 14.0;
     @Argument(fullName="qualThreshold", shortName="qual", doc="If a known variant has raw QUAL value less than -qual then don't use it for building the Gaussian mixture model.", required=false)
     public double QUAL_THRESHOLD = 80.0;
     @Argument(fullName="shrinkage", shortName="shrinkage", doc="The shrinkage parameter in variational Bayes algorithm.", required=false)
---------------
-------------
@@ -231,7 +231,7 @@
         int count = 0;
         for (PileupElement p : pileup) {
             if (p.isDeletion() || p.isInsertionAtBeginningOfRead() || BaseUtils.isRegularBase(p.getBase()))
-                count++;
+                count += p.getRepresentativeCount();
         }
 
         return count;
---------------
-------------
@@ -29,7 +29,7 @@
 public class QualByDepth extends InfoFieldAnnotation implements StandardAnnotation, ActiveRegionBasedAnnotation {
 
     public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {
-        if ( stratifiedContexts.size() == 0 )
+        if ( !vc.hasLog10PError() || stratifiedContexts.size() == 0 )
             return null;
 
         final GenotypesContext genotypes = vc.getGenotypes();
---------------
-------------
@@ -828,6 +828,9 @@
 
         vcfWriter.writeHeader(new VCFHeader(headerInfo, sampleSet));
 
+        //now that we have all the VCF headers, initialize the annotations (this is particularly important to turn off RankSumTest dithering in integration tests)
+        annotationEngine.invokeAnnotationInitializationMethods(headerInfo);
+
         try {
             // fasta reference reader to supplement the edges of the reference sequence
             referenceReader = new CachingIndexedFastaSequenceFile(getToolkit().getArguments().referenceFile);
---------------
-------------
@@ -321,7 +321,7 @@
             haplotypeMap.clear();
 
             if (getAlleleListFromVCF) {
-                 for( final VariantContext vc_input : tracker.getValues(UAC.alleles) ) {
+                 for( final VariantContext vc_input : tracker.getValues(UAC.alleles, loc) ) {
                       if( vc_input != null &&
                               allowableTypes.contains(vc_input.getType()) &&
                               ref.getLocus().getStart() == vc_input.getStart()) {
---------------
-------------
@@ -1462,6 +1462,8 @@
                     case EQ:
                     case X:
                     case I:
+                        if ( fromIndex + elementLength > actualReadBases.length )
+                            throw new UserException.MalformedBAM(read, "the CIGAR string is inconsistent with the number of bases in the read");
                         System.arraycopy(actualReadBases, fromIndex, readBases, toIndex, elementLength);
                         System.arraycopy(actualBaseQuals, fromIndex, baseQuals, toIndex, elementLength);
                         fromIndex += elementLength;
---------------
-------------
@@ -239,7 +239,7 @@
                 if ( ! expectedMD5.equals(filemd5sum) ) {
                     // we are going to fail for real in assertEquals (so we are counted by the testing framework).
                     // prepare ourselves for the comparison
-                    System.out.printf("##### Test %s is going fail #####%n", name);
+                    System.out.printf("##### Test %s is going to fail #####%n", name);
                     String pathToExpectedMD5File = getMD5FilePath(expectedMD5, "[No DB file found]");
                     String pathToFileMD5File = getMD5FilePath(filemd5sum, "[No DB file found]");
                     System.out.printf("##### Path to expected   file (MD5=%s): %s%n", expectedMD5, pathToExpectedMD5File);
---------------
-------------
@@ -878,7 +878,7 @@
                     int stop = region.getStop() - windowHeaderStart;
 
                     // make sure the bitset is complete given the region (it might not be in multi-sample mode)
-                    if ( region.getStop() > markedSites.getStartLocation() + markedSites.getVariantSiteBitSet().length )
+                    if ( region.getStop() > markedSites.getStartLocation() + markedSites.getVariantSiteBitSet().length - 1 )
                         markSites(region.getStop());
 
                     CloseVariantRegionResult closeVariantRegionResult = closeVariantRegion(start, stop, knownSnpPositions);
---------------
-------------
@@ -316,6 +316,7 @@
             // if in GENOTYPE_GIVEN_ALLELES mode, we still want to allow the use of a poor allele
             else if ( UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {
                 myAlleles.add(alternateAllele);
+                alleleCountsofMLE.add(AFresult.getAlleleCountsOfMLE()[indexOfAllele-1]);
             }
         }
 
---------------
-------------
@@ -98,6 +98,7 @@
             intervals = IntervalUtils.parseIntervalArguments(genomeLocParser, stringIntervals);
         }
 
+        Collections.sort(intervals);
         return intervals;
     }
 
---------------
-------------
@@ -385,7 +385,7 @@
         // this was very likely unintentional, the user should be informed of this. Note that this is different
         // from the case where intervals == null, which indicates either that there were no interval arguments,
         // or that -L all was specified.
-        if ( intervals != null && intervals.isEmpty() ) {
+        if ( intervals != null && intervals.isEmpty() && argCollection.excludeIntervals != null ) {
             throw new ArgumentException("The given combination of -L and -XL options results in an empty set. " +
                                         "No intervals to process.");
         }
---------------
-------------
@@ -91,6 +91,7 @@
     protected static Logger logger = Logger.getLogger(ParsingEngine.class);
 
     public ParsingEngine( CommandLineProgram clp ) {
+        RodBinding.resetNameCounter();
         parsingMethods.add( ParsingMethod.FullNameParsingMethod );
         parsingMethods.add( ParsingMethod.ShortNameParsingMethod );
 
---------------
-------------
@@ -98,6 +98,7 @@
             intervals = IntervalUtils.parseIntervalArguments(genomeLocParser, stringIntervals);
         }
 
+        Collections.sort(intervals);
         return intervals;
     }
 
---------------
-------------
@@ -227,7 +227,7 @@
      */
     public Long map( final ReferenceContext ref, final GATKSAMRecord originalRead, final RefMetaDataTracker metaDataTracker ) {
 
-        final GATKSAMRecord read = ReadClipper.hardClipAdaptorSequence(originalRead);
+        final GATKSAMRecord read = ReadClipper.hardClipSoftClippedBases( ReadClipper.hardClipAdaptorSequence(originalRead) );
         if( read.isEmpty() ) { return 0L; } // the whole read was inside the adaptor so skip it
 
         RecalUtils.parsePlatformForRead(read, RAC);
---------------
-------------
@@ -298,7 +298,7 @@
     public static Pair<Double,Double> calculatePRecursively(int n, int m, long u, boolean twoSided, ExactMode mode) {
         if ( m > 8 && n > 5 ) { throw new StingException(String.format("Please use the appropriate (normal or sum of uniform) approximation. Values n: %d, m: %d",n,m)); }
         double p = mode == ExactMode.POINT ? cpr(n,m,u) : cumulativeCPR(n,m,u);
-        p *= twoSided ? 2.0 : 1.0;
+        //p *= twoSided ? 2.0 : 1.0;
         double z;
         try {
 
---------------
-------------
@@ -358,7 +358,7 @@
         if (error instanceof RuntimeException)
             this.error = (RuntimeException)error;
         else
-            this.error = new ReviewedStingException("An error occurred during the traversal.", error);
+            this.error = new ReviewedStingException("An error occurred during the traversal.  Message=" + error.getMessage(), error);
 
     }
 
---------------
-------------
@@ -72,7 +72,7 @@
         ReadBackedPileup pileup = stratifiedContext.getBasePileup();
         for ( PileupElement p : pileup ) {
             if ( alleleCounts.containsKey(p.getBase()) )
-                alleleCounts.put(p.getBase(), alleleCounts.get(p.getBase())+1);
+                alleleCounts.put(p.getBase(), alleleCounts.get(p.getBase())+p.getRepresentativeCount());
         }
 
         // we need to add counts in the correct order
---------------
-------------
@@ -152,7 +152,7 @@
         }
     }
 
-    private double calcEpsilon( byte ref, byte read, byte qualB ) {
+    protected double calcEpsilon( byte ref, byte read, byte qualB ) {
         return EPSILONS[ref][read][qualB];
     }
 
---------------
-------------
@@ -207,7 +207,7 @@
             throw new RuntimeException(String.format("BUG: p Reference error is out of bounds (0.0 - 0.01) is allow range %f", pRefError));
         }
 
-        double pTriStateGenotype = heterozyosity * PROB_OF_REFERENCE_ERROR;
+        double pTriStateGenotype = heterozyosity * pRefError;
 //        if ( pTriStateGenotype >= heterozyosity ) {
 //            throw new RuntimeException(String.format("p Tristate genotype %f is greater than the heterozygosity %f", pTriStateGenotype, heterozyosity));
 //        }
---------------
-------------
@@ -1000,7 +1000,7 @@
     public static VariantContext trimAlleles(final VariantContext inputVC, final boolean trimForward, final boolean trimReverse) {
         if ( inputVC == null ) throw new IllegalArgumentException("inputVC cannot be null");
 
-        if ( inputVC.getNAlleles() <= 1 )
+        if ( inputVC.getNAlleles() <= 1 || inputVC.isSNP() )
             return inputVC;
 
         // see whether we need to trim common reference base from all alleles
---------------
-------------
@@ -224,7 +224,7 @@
                 if ( ! expectedMD5.equals(filemd5sum) ) {
                     // we are going to fail for real in assertEquals (so we are counted by the testing framework).
                     // prepare ourselves for the comparison
-                    System.out.printf("##### Test %s is going fail #####%n", name);
+                    System.out.printf("##### Test %s is going to fail #####%n", name);
                     String pathToExpectedMD5File = getMD5FilePath(expectedMD5, "[No DB file found]");
                     String pathToFileMD5File = getMD5FilePath(filemd5sum, "[No DB file found]");
                     System.out.printf("##### Path to expected   file (MD5=%s): %s%n", expectedMD5, pathToExpectedMD5File);
---------------
-------------
@@ -414,7 +414,7 @@
      * @return vc subcontext
      */
     public VariantContext subContextFromGenotypes(Collection<Genotype> genotypes, Set<Allele> alleles) {
-        return new VariantContext(getSource(), contig, start, stop, alleles, genotypes, getNegLog10PError(), getFilters(), getAttributes());
+        return new VariantContext(getSource(), contig, start, stop, alleles, genotypes, getNegLog10PError(), filtersWereApplied() ? getFilters() : null, getAttributes());
     }
 
 
---------------
-------------
@@ -1000,7 +1000,7 @@
     public static VariantContext trimAlleles(final VariantContext inputVC, final boolean trimForward, final boolean trimReverse) {
         if ( inputVC == null ) throw new IllegalArgumentException("inputVC cannot be null");
 
-        if ( inputVC.getNAlleles() <= 1 )
+        if ( inputVC.getNAlleles() <= 1 || inputVC.isSNP() )
             return inputVC;
 
         // see whether we need to trim common reference base from all alleles
---------------
-------------
@@ -136,7 +136,7 @@
         VariantContext annotated = vcToAnnotate;
         final GenomeLoc loc = getLoc(vcToAnnotate);
         for ( final Map.Entry<RodBinding<VariantContext>, String> overlapBinding : overlapBindings.entrySet() ) {
-            annotated = annotateOverlap(tracker.getValues(overlapBinding.getKey(), loc), overlapBinding.getValue(), vcToAnnotate);
+            annotated = annotateOverlap(tracker.getValues(overlapBinding.getKey(), loc), overlapBinding.getValue(), annotated);
         }
 
         return annotated;
---------------
-------------
@@ -256,7 +256,7 @@
             // Naive algorithm: find all elements in current contig for proper schedule creation.
             List<GenomeLoc> lociInContig = new LinkedList<GenomeLoc>();
             for(GenomeLoc locus: loci) {
-                if(dataSource.getHeader().getSequence(locus.getContig()).getSequenceIndex() == lastReferenceSequenceLoaded)
+                if(!GenomeLoc.isUnmapped(locus) && dataSource.getHeader().getSequence(locus.getContig()).getSequenceIndex() == lastReferenceSequenceLoaded)
                     lociInContig.add(locus);
             }
 
---------------
-------------
@@ -64,7 +64,7 @@
     protected int windowSize = 10;
 
     @Argument(fullName="mismatchFraction", shortName="mismatch", doc="fraction of base qualities needing to mismatch for a position to have high entropy; to disable set to <= 0 or > 1", required=false)
-    protected double mismatchThreshold = 0.15;
+    protected double mismatchThreshold = 0.0;
 
     @Argument(fullName="minReadsAtLocus", shortName="minReads", doc="minimum reads at a locus to enable using the entropy calculation", required=false)
     protected int minReadsAtLocus = 4;
---------------
-------------
@@ -136,7 +136,7 @@
         VariantContext annotated = vcToAnnotate;
         final GenomeLoc loc = getLoc(vcToAnnotate);
         for ( final Map.Entry<RodBinding<VariantContext>, String> overlapBinding : overlapBindings.entrySet() ) {
-            annotated = annotateOverlap(tracker.getValues(overlapBinding.getKey(), loc), overlapBinding.getValue(), vcToAnnotate);
+            annotated = annotateOverlap(tracker.getValues(overlapBinding.getKey(), loc), overlapBinding.getValue(), annotated);
         }
 
         return annotated;
---------------
-------------
@@ -66,7 +66,7 @@
                 return new Pair<GenomeLoc, String>(context.getLocation(), (SEQUENOM ? refBase.concat("[-/"+variant.getAltBasesFWD()+"]") : refBase.concat(variant.getAltBasesFWD())));
             } else if ( variant.isSNP() ) {
                 basesSeen++;
-                return new Pair<GenomeLoc, String>(context.getLocation(), (rod.getName().startsWith("snpmask") ? "N" : ("[" + refBase + "/" + variant.getAltBasesFWD() + "]")));
+                return new Pair<GenomeLoc, String>(context.getLocation(), (rod.getName().startsWith("snpmask") ? "N" : (SEQUENOM ? "[" + refBase + "/" + variant.getAltBasesFWD() + "]" : variant.getAltBasesFWD())));
             }
         }
 
---------------
-------------
@@ -550,8 +550,7 @@
             if (vc.hasAttribute(VCFConstants.DEPTH_KEY))
                 depth += Integer.valueOf(vc.getAttributeAsString(VCFConstants.DEPTH_KEY));
 
-            // TODO -- REVERT CHANGE
-            if (rsIDs.isEmpty() && vc.hasID()) rsIDs.add(vc.getID());
+            if ( vc.hasID() && ! vc.getID().equals(VCFConstants.EMPTY_ID_FIELD) ) rsIDs.add(vc.getID());
 
             if (mergeInfoWithMaxAC && vc.hasAttribute(VCFConstants.ALLELE_COUNT_KEY)) {
                 String rawAlleleCounts = vc.getAttributeAsString(VCFConstants.ALLELE_COUNT_KEY);
---------------
-------------
@@ -258,6 +258,6 @@
    * @return {@code true} if the cache contains changes to be analyzed, else {@code false}
    */
   public boolean hasWork() {
-    return oldLength > 0 && newLength > 0;
+    return oldLength > 0 || newLength > 0;
   }
 }
---------------
-------------
@@ -518,6 +518,8 @@
         reportError(StaticWarningCode.CAST_TO_NON_TYPE, typeName, typeName.getName());
       } else if (isTypeNameInIsExpression(node)) {
         reportError(StaticWarningCode.TYPE_TEST_NON_TYPE, typeName, typeName.getName());
+      } else if (isTypeNameTargetInRedirectedConstructor(node)) {
+        reportError(StaticWarningCode.REDIRECT_TO_NON_CLASS, typeName, typeName.getName());
       } else if (isTypeNameInTypeArgumentList(node)) {
         reportError(StaticTypeWarningCode.NON_TYPE_AS_TYPE_ARGUMENT, typeName, typeName.getName());
       } else {
---------------
-------------
@@ -240,6 +240,7 @@
     token = token.getNext();
     while (token != null) {
       tail = tail.setNext(token.copy());
+      token = token.getNext();
     }
     return head;
   }
---------------
-------------
@@ -424,7 +424,7 @@
       ClassElement classElement = constructorElement.getEnclosingElement();
       FieldElement[] elements = classElement.getFields();
       for (FieldElement field : elements) {
-        if (!field.isFinal() && !field.isConst()) {
+        if (!field.isFinal() && !field.isConst() && !field.isSynthetic()) {
           errorReporter.reportError(
               CompileTimeErrorCode.CONST_CONSTRUCTOR_WITH_NON_FINAL_FIELD,
               node);
---------------
-------------
@@ -78,7 +78,7 @@
     }
     String pkgName;
     String relPath;
-    int index = path.indexOf(File.separatorChar);
+    int index = path.indexOf('/');
     if (index == -1) {
       // No slash
       pkgName = path;
---------------
-------------
@@ -4014,7 +4014,7 @@
         beginFinalDeclaration();
         consume(peek(0));
         DartTypeNode type = null;
-        if (peek(1) == Token.IDENTIFIER || peek(1) == Token.LT) {
+        if (peek(1) == Token.IDENTIFIER || peek(1) == Token.LT || peek(1) == Token.PERIOD) {
           // We know we have a type.
           type = parseTypeAnnotation();
         }
---------------
-------------
@@ -277,7 +277,7 @@
 
   }
 
-  public static String PACKAGE_VERSION_EXPRESSION = "(\\d+\\.){2}\\d+([\\+-]([\\.a-zA-Z0-9-])*)?";
+  public static String PACKAGE_VERSION_EXPRESSION = "(\\d+\\.){2}\\d+([\\+-]([\\.a-zA-Z0-9-\\+])*)?";
   public static String PATTERN_PUBSPEC_NAME_LINE = "(?m)^(?:(?!--|').|'(?:''|[^'])*')*(name:.*)$";
 
   public static String VERSION_CONTSTRAINTS_EXPRESSION = "([=]{0,1}[<>]?)|([<>]?[=]{0,1})(\\d+\\.){2}\\d+([\\+-]([\\.a-zA-Z0-9-])*)?";
---------------
-------------
@@ -139,6 +139,7 @@
       // and the inserted characters does not change that original token
       // For example given "a; c;" and user types "b" such that "a;b c;
       // firstToken was ";" and this code advances it to "b" since "b" is the first new token
+      tokenMap.put(originalStream, firstToken);
       if (lastToken == firstToken) {
         lastToken = lastToken.getNext();
       }
---------------
-------------
@@ -53,7 +53,7 @@
       return false;
     }
     Iterator<Map.Entry<String, Type>> firstIterator = firstTypes.entrySet().iterator();
-    Iterator<Map.Entry<String, Type>> secondIterator = firstTypes.entrySet().iterator();
+    Iterator<Map.Entry<String, Type>> secondIterator = secondTypes.entrySet().iterator();
     while (firstIterator.hasNext()) {
       Map.Entry<String, Type> firstEntry = firstIterator.next();
       Map.Entry<String, Type> secondEntry = secondIterator.next();
---------------
-------------
@@ -649,7 +649,6 @@
     }
     // positional argument
     {
-      // TODO(scheglov) not implemented yet in Resolver 
       ParameterElement parameter = expression.getParameterElement();
       if (parameter != null) {
         return parameter.getDisplayName();
---------------
-------------
@@ -100,7 +100,7 @@
 
       File packOverrideDir = options.getPackageOverrideDirectory();
       if (packOverrideDir != null) {
-        File root = new File(packOverrideDir, container.getLocation().toString());
+        File root = new File(packOverrideDir, container.getLocation().toOSString());
         return new File[] {new File(root, DartCore.PACKAGES_DIRECTORY_NAME)};
       }
 
---------------
-------------
@@ -5040,6 +5040,8 @@
     boolean warnedUnreachable = false;
     while (true) {
       switch (peek(0)) {
+        case CLASS:
+          // exit loop to report error condition
         case CASE:
         case DEFAULT:
         case RBRACE:
---------------
-------------
@@ -345,6 +345,7 @@
           index = 0;
         }
         queue.add(index, new AnalyzeContextTask(this, savedContext));
+        queue.notifyAll();
       }
     }
   }
---------------
-------------
@@ -52,6 +52,7 @@
 
   // Pseudo keywords:
   ABSTRACT("abstract", true),
+  AS("as", true),
   ASSERT("assert", true),
   CALL("call", true),
   //DYNAMIC("Dynamic", true),
---------------
-------------
@@ -1516,7 +1516,8 @@
    */
   private void reportGetterOrSetterNotFound(PrefixedIdentifier node, SimpleIdentifier identifier,
       String typeName) {
-    Type targetType = getType(node);
+    // This method is only invoked when the prefixed identifier is effectively a property access.
+    Type targetType = getType(node.getPrefix());
     if (targetType != null && doesClassDeclareNoSuchMethod(targetType.getElement())) {
       return;
     }
---------------
-------------
@@ -1057,7 +1057,8 @@
     }
     ClassElementImpl classElement = (ClassElementImpl) element;
     MethodElement method = classElement.lookUpMethod("noSuchMethod", resolver.getDefiningLibrary());
-    if (method == null) {
+    // if no method found, or if the method found is defined in Object, return false
+    if (method == null || method.getEnclosingElement().getSupertype() == null) {
       return false;
     }
     return true;
---------------
-------------
@@ -274,7 +274,7 @@
   }
 
   public static LibraryElementImpl library(AnalysisContext context, String libraryName) {
-    String fileName = libraryName + ".dart";
+    String fileName = "/" + libraryName + ".dart";
     FileBasedSource source = new FileBasedSource(
         context.getSourceFactory().getContentCache(),
         createFile(fileName));
---------------
-------------
@@ -4264,7 +4264,7 @@
     if (!currentToken.getType().isIncrementOperator()) {
       return operand;
     }
-    if (operand instanceof FunctionExpressionInvocation) {
+    if (operand instanceof Literal || operand instanceof FunctionExpressionInvocation) {
       reportError(ParserErrorCode.MISSING_ASSIGNABLE_SELECTOR);
     }
     Token operator = getAndAdvance();
---------------
-------------
@@ -402,7 +402,7 @@
 
     /**
      * If the configuration is such that we are tracking just one branch of one repository
-     * return that branch specifier (in the form of something like "origin/master"
+     * return that branch specifier (in the form of something like "origin/master" or a SHA1-hash
      *
      * Otherwise return null.
      */
---------------
-------------
@@ -31,7 +31,6 @@
      */
     public String mergeStrategy = MergeCommand.Strategy.DEFAULT.toString();
 
-    @Exported
     public RemoteConfig getMergeRemote() {
         return mergeRemote;
     }
---------------
-------------
@@ -42,7 +42,7 @@
         setAuthor(johnDoe);
         setCommitter(johnDoe);
         workspace = new FilePath(workDir);
-        git = new GitAPI("git", workspace, listener, envVars);
+        git = new GitAPI("git", workspace, listener, envVars, null);
         git.init();
     }
 
---------------
-------------
@@ -4,5 +4,5 @@
 
 @WebService
 public interface OrderEndpoint {
-    public String order(String partName, String amount, String customerName);
+    public String order(String partName, int amount, String customerName);
 }
---------------
-------------
@@ -89,7 +89,7 @@
             plot.setGrid( true );
             plot.setColour( "grid", 0x8000ff00 );
             plot.setColour( "ticks", Color.GREEN.getRGB() );
-            plot.setColour( "text", Color.BLACK.getRGB() );
+            plot.setColour( "textlab", Color.BLACK.getRGB() );
             plot.grid();
 
             /* Make a panel which will cope with redrawing it as required. */
---------------
-------------
@@ -82,6 +82,7 @@
 		this.routeResolver = routeResolver;
 		this.serializationProvider = serializationProvider;
 	    createCorrelationId();
+        this.queryStringMap = new HashMap<String, String>();
 		parseQueryString(request);
 		determineEffectiveHttpMethod(request);
 	}
---------------
-------------
@@ -82,6 +82,7 @@
 		this.routeResolver = routeResolver;
 		this.serializationProvider = serializationProvider;
 	    createCorrelationId();
+        this.queryStringMap = new HashMap<String, String>();
 		parseQueryString(request);
 		determineEffectiveHttpMethod(request);
 	}
---------------
-------------
@@ -579,7 +579,7 @@
             }
 
             // ticket:3529
-            else if (/*(bec.getCurrentGroupId() < 0) &&*/
+            else if ((bec.getCurrentGroupId() < 0) &&
                     (isAdmin || bec.getMemberOfGroupsList()
                         .contains(sourceGroupId))) {
                 newDetails.setGroup(source.getGroup());
---------------
-------------
@@ -49,7 +49,6 @@
 import ome.system.Principal;
 import ome.system.Roles;
 import ome.system.ServiceFactory;
-import omero.model.IObject;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
---------------
-------------
@@ -280,7 +280,7 @@
             @Transactional(readOnly = false)
             public Object doWork(Session session, ServiceFactory sf) {
 
-                SqlAction sql = (SqlAction) sf.getContext().getBean("sqlAction");
+                SqlAction sql = (SqlAction) sf.getContext().getBean("simpleSqlAction");
 
                 File f = null;
                 RepoFile file = null;
---------------
-------------
@@ -137,7 +137,7 @@
         this.mock("executorMock").expects(test.once()).method("execute").will(test.returnValue(true));
         this.mock("executorMock").expects(test.once()).method("execute").will(test.returnValue(Collections.EMPTY_LIST));
         */
-        blitz = new BlitzConfiguration(id, ring, mgr, ss, ex);
+        blitz = new BlitzConfiguration(id, ring, mgr, ss, ex, 10000);
         this.sm = (SessionManagerI) blitz.getBlitzManager();
         this.sm.setApplicationContext(ctx);
         this.ctx.addApplicationListener(this.sm);
---------------
-------------
@@ -579,7 +579,7 @@
             }
 
             // ticket:3529
-            else if ((bec.getCurrentGroupId() < 0) &&
+            else if (/*(bec.getCurrentGroupId() < 0) &&*/
                     (isAdmin || bec.getMemberOfGroupsList()
                         .contains(sourceGroupId))) {
                 newDetails.setGroup(source.getGroup());
---------------
-------------
@@ -91,7 +91,7 @@
     /** Query to load the number of annotations per plate. */
     final static String loadCountsPlates = "select p from Plate p "
             + "left outer join fetch p.annotationLinksCountPerOwner " 
-            + "in (:list)";
+            + "where p in (:list)";
     
     /**
      * Implemented as speficied by the {@link IContainer} I/F
---------------
-------------
@@ -131,7 +131,7 @@
         commentPanel = GuiCommonElements.addMainPanel(this, commentTable, 10,10,10,10, debug);
 
         String message = "Thank you for taking the time to send us your comments. \n\n" +
-                "Your feedback will be used to futher the developmment of the " +
+                "Your feedback will be used to further the developmment of the " +
                 "importer and improve our software. Any personal details you provide are" +
                 " purely optional, and will only be used for development purposes.";
 
---------------
-------------
@@ -292,6 +292,7 @@
         Image i = new ImageI();
         i.getDetails().setOwner( e );
         i.setName( rstring(name) );
+        i.setAcquisitionDate( rtime(0) );
         i = push(i);
         return i;
     }
---------------
-------------
@@ -188,7 +188,7 @@
 		String startUntilOpenBraces = "^[^\\{]*\\{";
 		String or = "|";
 		String betweenBraces = "\\}[^\\{]*\\{";
-		String closeBracesUntilEnd = "\\}[^\\{]*$";
+		String closeBracesUntilEnd = "\\}[^\\{\\}]*$";
 
 		return uri.split(startUntilOpenBraces + or + betweenBraces + or + closeBracesUntilEnd);
 	}
---------------
-------------
@@ -52,7 +52,7 @@
 		return this.method;
 	}
 
-	public String urlFor(Object... params) {
+	public String urlFor(Object params) {
 		return null;
 	}
 
---------------
-------------
@@ -13,7 +13,6 @@
 import java.util.Map;
 
 import br.com.caelum.vraptor.ioc.Component;
-import br.com.caelum.vraptor.view.XmlSerializerTest.Order;
 
 /**
  * Basic xml serialization system.
---------------
-------------
@@ -192,7 +192,7 @@
 	private String[] extractParameters(String uri) {
 		String startUntilOpenBraces = "^[^\\{]*\\{";
 		String or = "|";
-		String betweenBraces = "\\*?\\}[^\\{]*\\{";
+		String betweenBraces = "\\*?\\}[^\\{\\}]*\\{";
 		String closeBracesUntilEnd = "\\*?\\}[^\\{\\}]*$";
 
 		return uri.split(startUntilOpenBraces + or + betweenBraces + or + closeBracesUntilEnd);
---------------
-------------
@@ -76,7 +76,7 @@
 		String base = originalPattern.replaceAll("\\.\\*", "");
 		for (String key : parameters) {
 			Object result = new Evaluator().get(params, key);
-			base = base.replace("{" + key + "}", result == null ? "" : result.toString());
+			base = base.replaceAll("\\{" + key + "\\*?\\}", result == null ? "" : result.toString());
 		}
 		return base;
 	}
---------------
-------------
@@ -30,6 +30,7 @@
 import br.com.caelum.vraptor.ComponentRegistry;
 import br.com.caelum.vraptor.ioc.ApplicationScoped;
 import br.com.caelum.vraptor.ioc.Stereotype;
+import br.com.caelum.vraptor.ioc.Component;
 
 import java.util.Collection;
 
---------------
-------------
@@ -50,7 +50,7 @@
 		String patternUri = originalPattern
 			.replaceAll("\\{([^\\}]+?)\\*\\}", "(.*)")
 			.replaceAll("\\{([^\\}]+?)\\}", "([^/]*)");
-		Matcher matcher = Pattern.compile("\\{(.+?)\\}").matcher(originalPattern);
+		Matcher matcher = Pattern.compile("\\{([^\\}]+?)\\}").matcher(originalPattern);
 		while(matcher.find()) {
 			parameters.add(matcher.group(1).replace("*", ""));
 		}
---------------
-------------
@@ -14,7 +14,7 @@
 
     @Configuration
     public static Option[] felixConfiguration() {
-        return options(felix(), scanPom("mvn:de.deepamehta/deepamehta3-felix/0.4.5-SNAPSHOT/pom"));
+        return options(felix(), scanPom("mvn:de.deepamehta/deepamehta3-felix/0.4.5/pom"));
     }
 
 }
---------------
-------------
@@ -124,7 +124,7 @@
 				int panelNr = this.panelOrder.get(ofs);
 				
 				int[] transformedBuffer = 
-					RotateBuffer.transformImage(super.getBufferForScreen(panelNr), displayOptions.get(panelNr),
+					RotateBuffer.transformImage(super.getBufferForScreen(ofs), displayOptions.get(panelNr),
 							Lpd6803.NR_OF_LED_HORIZONTAL, Lpd6803.NR_OF_LED_VERTICAL);
 				
 				if (lpd6803.sendRgbFrame((byte)panelNr, transformedBuffer, colorFormat.get(panelNr))) {
---------------
-------------
@@ -54,7 +54,7 @@
                 param[1] = UUID.randomUUID().toString();
             }
             
-            MessageProcessor.processMsg(param, false);
+            MessageProcessor.processMsg(param, false, null);
         }
     }
 
---------------
-------------
@@ -26,7 +26,7 @@
         
         List<String> pathArray = new ArrayList<String>();
         Iterables.addAll(pathArray, Splitter.on("/").split(path));
-        for (int i = pathArray.size() -1; i > -1; i--){
+        for (int i = pathArray.size() -1; i > 0; i--){
             framePath = Joiner.on("/").join(pathArray.subList(0, i));
             framePath += "/" + FRAME_NAME;
             if (!framePath.startsWith("/")){
---------------
-------------
@@ -60,7 +60,7 @@
     public Enum resolveEnum(AnnotationMap annotationMap, Class paramType, RequestContext rc) {
         WebParam webParam = annotationMap.get(WebParam.class);
         String val = rc.getParam(webParam.value());
-        return ObjectUtil.getValue(val, paramType, null);
+        return (Enum)ObjectUtil.getValue(val, paramType, null);
     }
     // --------- /Primary Type Resolvers --------- //
 
---------------
-------------
@@ -396,6 +396,7 @@
             if (!wallet.completeTx(req)) // Let wallet handle adding additional inputs/fee as necessary.
                 throw new ValueOutOfRangeException("Unable to complete transaction - unable to pay required fee");
             feePaidForPayment = req.fee;
+            log.info("Calculated fee is {}", feePaidForPayment);
             if (feePaidForPayment.compareTo(bestValueToMe) >= 0)
                 throw new ValueOutOfRangeException(String.format("Had to pay more in fees (%s) than the channel was worth (%s)",
                         feePaidForPayment, bestValueToMe));
---------------
-------------
@@ -325,7 +325,7 @@
 
     @Override
     public long getEarliestKeyCreationTime() {
-        return seed.getCreationTimeSeconds();
+        return seed != null ? seed.getCreationTimeSeconds() : Utils.currentTimeSeconds();
     }
 
     @Override
---------------
-------------
@@ -46,6 +46,7 @@
         this.addr = addr;
         this.port = port;
         this.protocolVersion = protocolVersion;
+        this.services = BigInteger.ZERO;
     }
     
     public void bitcoinSerializeToStream(OutputStream stream) throws IOException {
---------------
-------------
@@ -75,7 +75,7 @@
         warn = rez2._2();
 
         Term rez3 = new PreferAvoidVisitor().apply(rez2._1().right().get());
-        rez2 = new AmbFilter().apply(rez.right().get());
+        rez2 = new AmbFilter().apply(rez3);
         warn = new AmbFilter().mergeWarnings(rez2._2(), warn);
 
         return new Tuple2<>(Right.apply(rez2._1().right().get()), warn);
---------------
-------------
@@ -1,3 +1,4 @@
+// Copyright (c) 2014 K Team. All Rights Reserved.
 package org.kframework.backend.java.util;
 
 import java.util.Collections;
---------------
-------------
@@ -1,3 +1,4 @@
+// Copyright (c) 2013-2015 K Team. All Rights Reserved.
 package org.kframework.unparser;
 
 import org.kframework.definition.Module;
---------------
-------------
@@ -1,3 +1,5 @@
+// Copyright (c) 2015 K Team. All Rights Reserved.
+
 package org.kframework.kore.convertors;
 
 import static org.kframework.Collections.immutable;
---------------
-------------
@@ -27,7 +27,7 @@
 	public static String KDEF = USER_DIR;
 	// programs
 	public static String PGM_DIR = null; //USER_DIR;
-	public static List<String> EXTENSIONS = new LinkedList<String>();
+	public static List<String> EXTENSIONS = null; //new LinkedList<String>();
 	// optional
 	public static boolean PDF = true;
 	public static String RESULTS_FOLDER = null; //USER_DIR;
---------------
-------------
@@ -1022,7 +1022,7 @@
             for(ProducedType refinedSatisfiedType : satRefinedTP){
                 // if we found it, remove it from the second list to not match it again
                 if(satisfiedType.isExactly(refinedSatisfiedType)){
-                    satRefinedTP.remove(satRefinedTP);
+                    satRefinedTP.remove(refinedSatisfiedType);
                     continue OUT;
                 }
             }
---------------
-------------
@@ -256,7 +256,7 @@
     }
     
     @Test
-    public void testNstMethodReturningInner_fail(){
+    public void testNstMethodReturningInner(){
         compareWithJavaSource("nesting/MethodReturningInner");
     }
 
---------------
-------------
@@ -137,7 +137,7 @@
     @Test
     public void testBug1083() {
         assertErrors("bug10xx/Bug1083",
-                new CompilerError(24, "ambiguous reference to overloaded method or class: there must be exactly one overloaded declaration of BigInteger that accepts the given argument types)"));
+                new CompilerError(24, "ambiguous reference to overloaded method or class: there must be exactly one overloaded declaration of BigInteger that accepts the given argument types ()"));
     }
     
     @Test
---------------
-------------
@@ -985,6 +985,7 @@
     }
     
     @Test
+    @Ignore
     public void testBug1953() {
         compareWithJavaSource("bug19xx/Bug1953");
     }
---------------
-------------
@@ -459,7 +459,7 @@
         if (pkg.getNameAsString().isEmpty()) {
             around("a class='link' href='index.html'", "default package");
         } else {
-            around("a class='link' href='" + tool.getObjectUrl(module, pkg) + "'", pkg.getNameAsString());
+            around("a class='link' href='" + tool.getObjectUrl(getFromObject(), pkg) + "'", pkg.getNameAsString());
         }
         close("td");
 
---------------
-------------
@@ -156,7 +156,7 @@
     public void testImpImportWildcardSinglePass(){
         List<String> options = new LinkedList<String>();
         options.add("-src");
-        options.add(path+"/import_/src");
+        options.add(getPackagePath()+"/import_/src");
         CeyloncTaskImpl task = getCompilerTask(options, "import_/src/pkg/File.ceylon", "import_/src/pkg/sub/ConcreteDirectory.ceylon");
         Assert.assertTrue(task.call());
         task = getCompilerTask(options, "import_/src/pkg/File.ceylon", "import_/src/pkg/sub/ConcreteDirectory.ceylon");
---------------
-------------
@@ -119,7 +119,7 @@
 
 
     @Test
-    public void testMdlHTTPMixedCompilation() throws IOException{
+    public void testMdlHTTPMixedCompilation_fail() throws IOException{
         // Compile the first module in its own repo 
         File repo = makeRepo();
 
---------------
-------------
@@ -88,7 +88,7 @@
                 JarFile jarFile = new JarFile(originalJarFile);
                 Enumeration<JarEntry> entries = jarFile.entries();
                 while(entries.hasMoreElements()){
-                    JarEntry entry = entries.nextElement();                    
+                    JarEntry entry = entries.nextElement();
                     // skip the old entry if we overwrote it
                     if(writtenClasses.contains(entry.getName()))
                         continue;
---------------
-------------
@@ -62,7 +62,7 @@
     private final Module moduleDescriptor;
 
     public ModuleDescriptorReader(String moduleName, File srcDir) {
-        RepositoryManagerBuilder builder = new RepositoryManagerBuilder(new NullLogger());
+        RepositoryManagerBuilder builder = new RepositoryManagerBuilder(new NullLogger(), false);
         RepositoryManager repoManager = builder.buildRepository();
         VFS vfs = new VFS();
         Context context = new Context(repoManager, vfs);
---------------
-------------
@@ -383,7 +383,7 @@
         Annotation deprecated = Util.findAnnotation(decl, "deprecated");
         if (deprecated != null) {
             open("div class='deprecated section'");
-            String text = "__Deprecated:__ ";
+            String text = "<span class='title'>Deprecated: </span>";
             if (!deprecated.getPositionalArguments().isEmpty()) {
                 String reason = deprecated.getPositionalArguments().get(0);
                 if (reason != null) {
---------------
-------------
@@ -46,6 +46,7 @@
 
 			if (satisfied) {
 				ifStatement.getRight().render(self, writer, context);
+				break;
 			}
 		}
 
---------------
-------------
@@ -128,7 +128,7 @@
 
         }
 
-        if (member != null) {
+        if (object != null && member != null) {
             if (argumentValues == null) {
                 argumentValues = getArgumentValues(self, context);
             }
---------------
-------------
@@ -450,7 +450,7 @@
       groupSet.setCreateTime(attributeDef.getCreatedOnDb());
       groupSet.setDepth(0);
       groupSet.setMemberAttrDefId(attributeDef.getId());
-      groupSet.setOwnerStemId(attributeDef.getId());
+      groupSet.setOwnerAttrDefId(attributeDef.getId());
       groupSet.setParentId(groupSet.getId());
       groupSet.setFieldId(field.getUuid());
       
---------------
-------------
@@ -145,7 +145,8 @@
         final URL url = this.toURL(env, name);
         String content;
         try {
-            content = IOUtils.toString(url.openStream());
+            content = IOUtils.toString(url.openStream()).replaceAll("\\r", "");
+            // content = IOUtils.toString(url.openStream());
         } catch (java.io.IOException ex) {
             throw new IllegalStateException("Failed to read license", ex);
         }
---------------
-------------
@@ -195,7 +195,7 @@
     private List<File> files(final Environment env) {
         final List<File> files = new ArrayList<File>();
         final IOFileFilter filter = new WildcardFileFilter("*.java");
-        final File sources = new File(env.basedir(), "");
+        final File sources = new File(env.basedir(), "src/main/java");
         if (sources.exists()) {
             files.addAll(
                 FileUtils.listFiles(
---------------
-------------
@@ -16,7 +16,7 @@
     private static final String IP =
             "((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|";
 
-    private static final String FQDN = "(([A-Za-z0-9]([A-Za-z0-9\\-\\.]{0,61}[A-Za-z0-9])?)*[A-Za-z]))";
+    private static final String FQDN = "(?=^.{1,254}$)(^(((?!-)[a-zA-Z0-9-]{1,63}(?<!-))|((?!-)[a-zA-Z0-9-]{1,63}(?<!-)\\.)+[a-zA-Z0-9]{2,63})))";
 
     private static final String PATH = "\\:/(.*?/|.*?\\\\)?([^\\./|^\\.\\\\]+)(?:\\.([^\\\\]*)|)";
 
---------------
-------------
@@ -23,7 +23,7 @@
      * Default validation result is success with no message.
      * This constructor is private, it is only used to create a 'valid' result. Please use {@link ValidationResult#VALID}
      */
-    public ValidationResult() {
+    private ValidationResult() {
         message = null;
     }
 
---------------
-------------
@@ -38,7 +38,7 @@
 
     @Override
     public boolean validate(String text) {
-        text = text.trim().toLowerCase();
+        text = text.trim();
         for (String os : map.values()) {
             if (os.equals(text)) {
                 return true;
---------------
-------------
@@ -711,7 +711,7 @@
                 }
                 if (refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) {
                     innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME,
-                            SearchObjects.VDC_USER_OBJ_NAME, useTags));
+                            SearchObjects.VDC_USER_OBJ_NAME, true));
                     refObjList.remove(SearchObjects.VDC_USER_OBJ_NAME);
                 }
                 if (refObjList.contains(SearchObjects.VDS_OBJ_NAME)) {
---------------
-------------
@@ -933,7 +933,7 @@
                                     tableNameWithOutTags, primeryKey,
                                     syntax.getSearchFrom(), innerQuery);
                 }
-            } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() == 0) {
+            } else if ((primeryKey.equals("vmt_guid") || primeryKey.equals("vm_pool_id")) && wherePhrase.length() == 0) {
                 inQuery = StringFormat
                         .format("(SELECT * FROM %1$s ",
                                 tableNameWithOutTags);
---------------
-------------
@@ -37,7 +37,7 @@
         }
 
         // If the quota is in use by ether VM or image - return false
-        if (getDbFacade().getQuotaDAO().isQuotaInUse(quota)) {
+        if (getQuotaDAO().isQuotaInUse(quota)) {
             addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IN_USE_BY_VM_OR_DISK);
             return false;
         }
---------------
-------------
@@ -162,4 +162,9 @@
      * Predefined image group for testing.
      */
     protected static final Guid IMAGE_GROUP_ID = new Guid("1b26a52b-b60f-44cb-9f46-3ef333b04a35");
+
+    /**
+     * Predefined floating disk for testing.
+     */
+    protected static final Guid FLOATING_DISK_ID = new Guid("1b26a52b-b60f-44cb-9f46-3ef333b04a36");
 }
---------------
-------------
@@ -110,6 +110,11 @@
     protected static final Guid IMAGE_ID = new Guid("42058975-3d5e-484a-80c1-01c31207f578");
 
     /**
+     * Predefined image on a VM template for testing.
+     */
+    protected static final Guid TEMPLATE_IMAGE_ID = new Guid("52058975-3d5e-484a-80c1-01c31207f578");
+
+    /**
      * Predefined image group for testing.
      */
     protected static final Guid IMAGE_GROUP_ID = new Guid("1b26a52b-b60f-44cb-9f46-3ef333b04a35");
---------------
-------------
@@ -63,7 +63,7 @@
                 addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
             } else {
                 oldVmDevice =
-                        getVmDeviceDao().get(new VmDeviceId(_oldDisk.getId(), getVmId()));
+                        getVmDeviceDao().get(new VmDeviceId(_oldDisk.getDisk().getId(), getVmId()));
                 if (getVm().getstatus() != VMStatus.Up || getParameters().getDiskInfo().getPlugged() == null) {
                     retValue = checkCanPerformRegularUpdate();
                 } else {
---------------
-------------
@@ -67,4 +67,13 @@
      * Predefined quota with general and specific limitations.
      */
     protected static final Guid QUOTA_SPECIFIC_AND_GENERAL = new Guid("88296e00-0cad-4e5a-9291-008a7b7f4401");
+
+    /**
+     * Predefined VM for testing with the following properties :
+     * <ul>
+     * <li>VM name: rhel5-pool-57</li>
+     * <li>Vds group: rhel6.iscsi (b399944a-81ab-4ec5-8266-e19ba7c3c9d1)</li>
+     * <li>Based on template: 1 (1b85420c-b84c-4f29-997e-0eb674b40b79)</li></ul>
+     */
+    protected static final Guid VM_RHEL5_POOL_57 = new Guid("77296e00-0cad-4e5a-9299-008a7b6f4355");
 }
---------------
-------------
@@ -23,6 +23,7 @@
     public GlusterBrickDaoDbFacadeImpl() {
         super("GlusterBrick");
         setProcedureNameForGet("GetGlusterBrickById");
+        setProcedureNameForRemove("DeleteGlusterVolumeBrick");
     }
 
     @Override
---------------
-------------
@@ -974,7 +974,7 @@
         } catch (NumberFormatException e) {
             throw new IllegalArgumentException("Bad format: " + strCpu, e);
         }
-        if (strPin[1].matches("\\^?(\\d(\\-\\d)?)(,\\^?((\\d(\\-\\d)?)))*")) {
+        if (strPin[1].matches("\\^?(\\d+(\\-\\d+)?)(,\\^?((\\d+(\\-\\d+)?)))*")) {
             pin.setCpuSet(strPin[1]);
         } else {
             throw new IllegalArgumentException("Bad format: " + strPin[1]);
---------------
-------------
@@ -91,7 +91,7 @@
             return false;
         if (value != null ? !value.equals(that.value) : that.value != null)
             return false;
-		if (values != null ? !values.equals(that.value) : that.values != null)
+		if (values != null ? !values.equals(that.values) : that.values != null)
 			return false;
 
         return true;
---------------
-------------
@@ -678,6 +678,9 @@
 		return transport.getObject(Attachment.class, attachmentID);
 	}
 
+	/*
+	 * It does not work at all. It requires authentication!
+	 */
 	/**
 	 * Downloads the content of an {@link org.redmine.ta.beans.Attachment} from
 	 * the Redmine server.
---------------
-------------
@@ -4,7 +4,7 @@
 import java.text.SimpleDateFormat;
 import java.util.Date;
 
-// side note... can you please STOP CHANGING FREAKING DATE FORMATS already? please?
+// side note... can you PLEASE stop changing date formats already? please?
 // I submitted a Redmine feature request to read current date format from the server: http://www.redmine.org/issues/19354
 public final class RedmineDateParser {
     /**
---------------
-------------
@@ -91,7 +91,7 @@
             return false;
         if (value != null ? !value.equals(that.value) : that.value != null)
             return false;
-		if (values != null ? !values.equals(that.value) : that.values != null)
+		if (values != null ? !values.equals(that.values) : that.values != null)
 			return false;
 
         return true;
---------------
-------------
@@ -758,7 +758,7 @@
             }
         }
 
-        return new ElasticSearchDatastore(clusterName, hostname, port, clusterName, indexName, tableDefs);
+        return new ElasticSearchDatastore(name, hostname, port, clusterName, indexName, tableDefs);
     }
 
     private Datastore createDatastore(String name, JsonDatastoreType datastoreType) {
---------------
-------------
@@ -160,6 +160,7 @@
 
 	static List<String> tokenize(String s) {
 		List<String> ret = new LinkedList<String>();
+		if (s == null) return ret;
 		boolean word = false;
 		StringBuilder token = null;
 		int len = s.length();
---------------
-------------
@@ -69,7 +69,7 @@
 
 	@SuppressWarnings("deprecation")
 	public static int getWeekday(Date date) {
-		return date.getDay();
+		return date.getDay() + 1;
 	}
 
 	@SuppressWarnings("deprecation")
---------------
-------------
@@ -85,6 +85,7 @@
 		jsonObject.put("skipBuildPhrase", "[skip ci]");
 		jsonObject.put("cron", "*/1 * * * *");
 		jsonObject.put("useComments", "true");
+		jsonObject.put("useDetailedComments", "false");
 		jsonObject.put("logExcerptLines", "0");
 		jsonObject.put("unstableAs", "");
 		jsonObject.put("testMode", "true");
---------------
-------------
@@ -151,7 +151,7 @@
 
       if (tier.name != null && breaks_tier_name != null) {
         if (tier.name.equals(breaks_tier_name)) {
-          tones_tier = tier;
+          breaks_tier = tier;
         }
       } else if (tier.name != null && tier.name.equals("breaks")) {
         breaks_tier = tier;
---------------
-------------
@@ -69,7 +69,7 @@
 				boolean splitted = false;
 				for(String splitter : splitters){
 					// forward check for splitter
-					if(splitter.compareTo(str.substring(i, Math.min(i+splitter.length(), str.length()-1)))==0){
+					if(splitter.compareTo(str.substring(i, Math.min(i+splitter.length(), str.length())))==0){
 						splits.add(curString);
 						if(includeSplitter==true){
 							splits.add(splitter);
---------------
-------------
@@ -1390,7 +1390,7 @@
                 }
             }
         }
-        log.trace("fixTaskDirs found expectedWithTask {} expectedMissingTask {} unexpectedWithTask {} ");
+        log.trace("fixTaskDirs found expectedWithTask {} expectedMissingTask {} unexpectedWithTask {} ", expectedHostsWithTask, expectedHostsMissingTask, unexpectedHostsWithTask);
         if (deleteOrphansOnly) {
             // If we're only deleting orphans, ignore any expected hosts missing the task
             expectedHostsMissingTask = new HashSet<>();
---------------
-------------
@@ -56,7 +56,7 @@
 
 		int firstQuote = word.indexOf('"');
 
-		if (firstQuote > -1)
+		if (firstQuote > -1 && firstQuote < word.length() - 2)
 		{
 			if (isLegalPrefix(word.substring(0, firstQuote)))
 			{
---------------
-------------
@@ -256,7 +256,7 @@
                     }
 
                     appendCurrentChar = true;
-                } else if (!Character.isSpaceChar(c) && isRecognizedException(wordBuffer, length, c)) {
+                } else if (c != suffixForExactMatch && !Character.isSpaceChar(c) && isRecognizedException(wordBuffer, length, c)) {
                     startedDoingCustomToken = length;
                     tokenType |= TokenType.Custom;
                     appendCurrentChar = true;
---------------
-------------
@@ -159,7 +159,7 @@
         final int failCount = getFailCount();
         int score = (totalCount == 0)
                 ? 100
-                : (int) (100.0 * Math.max(0.0, Math.min(0.0, 1.0 - (scaleFactor * failCount) / totalCount)));
+                : (int) (100.0 * Math.max(0.0, Math.min(1.0, 1.0 - (scaleFactor * failCount) / totalCount)));
         Localizable description, displayName = Messages._AbstractTestResultAction_getDisplayName();
         if (totalCount == 0) {
         	description = Messages._AbstractTestResultAction_zeroTestDescription(displayName);
---------------
-------------
@@ -72,7 +72,7 @@
    * Set the current action being executed
    */
   public void setAction(String action) {
-
+    this.action = action;
   }
 
 }
---------------
-------------
@@ -23,7 +23,6 @@
 import org.neo4j.graphdb.Direction;
 import org.neo4j.graphdb.Node;
 import org.neo4j.graphdb.RelationshipType;
-//todo  then tests (incl BOTH), then rel extr. strategies overhaul, then different weights per relationship, checks that tx manager is in place when 0 returned (is anything cached at all? if not, does the node really have 0?)
 
 /**
  * {@link FullRelationshipCounter} that counts matching relationships by first trying to look them up in cached
---------------
-------------
@@ -106,7 +106,7 @@
     public static DDRRecord getDDRRecord(String id, String accountId) throws Exception {
 
         JacksonDBCollection<DDRRecord, String> coll = getCollection();
-        DDRRecord ddrRecord = coll.findOneById(id);
+        DDRRecord ddrRecord = id != null ? coll.findOneById(id) : null;
         if (ddrRecord != null && ddrRecord.getAccountId() != null && !ddrRecord.getAccountId().equals(accountId)) {
             throw new Exception(String.format("DDR record: %s is not owned by account: %s", id, accountId));
         }
---------------
-------------
@@ -1460,7 +1460,7 @@
      * @throws IllegalArgumentException if name is already used
      */
     protected void checkNameNotExists(String name) {
-        if(catalog.get(name)!=null)
+        if(catalog.get(name+".type")!=null)
             throw new IllegalArgumentException("Name already used: "+name);
     }
 
---------------
-------------
@@ -849,6 +849,7 @@
                     crc |= crc32.getValue();
 
                     log.getDataInput(logSize, size).readFully(b);
+                    logSize+=size;
                 } else if (ins == WAL_SKIP_REST_OF_BLOCK) {
                     logSize += SLICE_SIZE - (logSize & SLICE_SIZE_MOD_MASK);
                 } else {
---------------
-------------
@@ -263,7 +263,7 @@
                 artifact.version = vscaladocVersion;
                 scalaJars = new BasicArtifact[]{artifact};
             }
-            isScala271 = (new VersionNumber("2.7.1").compareTo(new VersionNumber(scalaVersion)) > -1);
+            isScala271 = (new VersionNumber("2.7.1").compareTo(new VersionNumber(scalaVersion)) < 0);
             JavaCommand jcmd = getScalaCommand();
             if  (!isScala271){
                 jcmd.addArgs("-Ydoc");
---------------
-------------
@@ -492,6 +492,7 @@
         JdbcSqlStat sqlStat = statement.getSqlStat();
 
         if (sqlStat != null) {
+            sqlStat.decrementExecutingCount();
             sqlStat.error(error);
             sqlStat.addExecuteTime(statement.getLastExecuteType(), statement.isFirstResultSet(), nanos);
             statement.setLastExecuteTimeNano(nanos);
---------------
-------------
@@ -35,7 +35,7 @@
                      "   WHERE RowNumber BETWEEN ? AND ?";
 
         String expect = "SELECT *" +
-        		"\nFROM (SELECT ROW_NUMBER() OVER () ORDER BY FAlertDate DESC, FAlertLevel, FAlertType AS RowNumber, *" +
+        		"\nFROM (SELECT ROW_NUMBER() OVER (ORDER BY FAlertDate DESC, FAlertLevel, FAlertType) AS RowNumber, *" +
         		"\n\tFROM monitor_business" +
         		"\n\tWHERE FRemoveAlert = ?" +
         		"\n\t) temp_table" +
---------------
-------------
@@ -492,6 +492,7 @@
         JdbcSqlStat sqlStat = statement.getSqlStat();
 
         if (sqlStat != null) {
+            sqlStat.decrementExecutingCount();
             sqlStat.error(error);
             sqlStat.addExecuteTime(statement.getLastExecuteType(), statement.isFirstResultSet(), nanos);
             statement.setLastExecuteTimeNano(nanos);
---------------
-------------
@@ -89,7 +89,7 @@
     }
 
     @SuppressWarnings("resource")
-    private void collectSql() {
+    public void collectSql() {
         Set<Object> dataSources = DruidDataSourceStatManager.getInstances().keySet();
 
         List<DruidDataSourceStatValue> statValueList = new ArrayList<DruidDataSourceStatValue>(dataSources.size());
---------------
-------------
@@ -56,7 +56,7 @@
         }
         
         for (int i = 0; i < method.getParameterTypes().length; ++i) {
-            if (method.getParameterTypes()[i].getName().equals(other.method.getParameterTypes()[i].getName())) {
+            if (!method.getParameterTypes()[i].getName().equals(other.method.getParameterTypes()[i].getName())) {
                 return false;
             }
         }
---------------
-------------
@@ -302,7 +302,7 @@
      *
      * @param cfs
      * @param ranges Ranges that the repair was carried out on
-     * @param validatedForRepair SSTables containing the repaired ranges
+     * @param validatedForRepair SSTables containing the repaired ranges. Should be referenced before passing them.
      * @throws InterruptedException, ExecutionException, IOException
      */
     public void performAnticompaction(ColumnFamilyStore cfs,
---------------
-------------
@@ -272,7 +272,7 @@
 
     public long maxTimestamp()
     {
-        long maxTimestamp = Long.MIN_VALUE;
+        long maxTimestamp = getMarkedForDeleteAt();
         for (IColumn column : columns)
             maxTimestamp = Math.max(maxTimestamp, column.maxTimestamp());
         return maxTimestamp;
---------------
-------------
@@ -58,7 +58,6 @@
 
         public Builder(ColumnFamily cf,
                        ByteBuffer key,
-                       DataOutput output)
                        DataOutput output,
                        boolean fromStream)
         {
---------------
-------------
@@ -675,7 +675,6 @@
         {
             if (!hasIndexes && !new Bounds<>(sstable.first.token, sstable.last.token).intersects(ranges))
             {
-                cfs.getDataTracker().replaceReaders(Arrays.asList(sstable), Collections.<SSTableReader>emptyList());
                 cfs.getDataTracker().markCompactedSSTablesReplaced(Arrays.asList(sstable), Collections.<SSTableReader>emptyList(), OperationType.CLEANUP);
                 continue;
             }
---------------
-------------
@@ -35,7 +35,7 @@
 
     public static final ISerializer<DeletionTime> serializer = new Serializer();
 
-    DeletionTime(long markedForDeleteAt, int localDeletionTime)
+    public DeletionTime(long markedForDeleteAt, int localDeletionTime)
     {
         this.markedForDeleteAt = markedForDeleteAt;
         this.localDeletionTime = localDeletionTime;
---------------
-------------
@@ -378,7 +378,7 @@
         submitUserDefined(cfs, descriptors, getDefaultGcBefore(cfs));
     }
 
-    private Future<Object> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
+    Future<Object> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
     {
         Callable<Object> callable = new Callable<Object>()
         {
---------------
-------------
@@ -587,7 +587,7 @@
     {
         return metadata.cfType == ColumnFamilyType.Standard
                ? Column.serializer()
-               : SuperColumn.serializer(getColumnComparator());
+               : SuperColumn.serializer(metadata.subcolumnComparator);
     }
 
     /**
---------------
-------------
@@ -376,7 +376,7 @@
         ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));
         int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);
         CfDef cfDef = getCfDef(columnFamily);
-        boolean isSuper = cfDef.comparator_type.equals("Super");
+        boolean isSuper = cfDef.column_type.equals("Super");
         
         byte[] superColumnName = null;
         ByteBuffer columnName;
---------------
-------------
@@ -95,7 +95,7 @@
         return udpAddr_;
     }
 
-    public static IPartitioner getPartitioner() {
+    public static IPartitioner<?> getPartitioner() {
         return partitioner_;
     }
 
---------------
-------------
@@ -468,7 +468,7 @@
             return;
 
         IndexClause clause = new IndexClause();
-        String columnFamily = statement.getChild(0).getText();
+        String columnFamily = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
         // ^(CONDITIONS ^(CONDITION $column $value) ...)
         Tree conditions = statement.getChild(1);
         
---------------
-------------
@@ -199,6 +199,7 @@
         {
             int startIndex = (int) (section.left / parameters.chunkLength());
             int endIndex = (int) (section.right / parameters.chunkLength());
+            endIndex = section.right % parameters.chunkLength() == 0 ? endIndex - 1 : endIndex;
             for (int i = startIndex; i <= endIndex; i++)
             {
                 long offset = i * 8;
---------------
-------------
@@ -367,7 +367,7 @@
 
     public ColumnStats getColumnStats()
     {
-        long maxTimestampSeen = Long.MIN_VALUE;
+        long maxTimestampSeen = getMarkedForDeleteAt();
         StreamingHistogram tombstones = new StreamingHistogram(SSTable.TOMBSTONE_HISTOGRAM_BIN_SIZE);
 
         for (IColumn column : columns)
---------------
-------------
@@ -16,6 +16,7 @@
  * <p>Company: Dexels BV</p>
  * @author Arjen Schoneveld
  * @version $Id$
+ * @deprecated But still used for the financial forms, I think
  */
 
 public class ExecuteScript extends FunctionInterface {
---------------
-------------
@@ -91,7 +91,7 @@
     }
 
     public void testFindSurrounding5() throws Exception {
-        String contents = "foo().foo()";
+        String contents = "foo() .foo()";
         Region initialRegion = new Region(contents.indexOf('f'), 1);
         Region expectedRegion = new Region(contents.indexOf("foo"), "foo".length());
         GroovyCompilationUnit unit = checkRegion(contents, initialRegion, expectedRegion);
---------------
-------------
@@ -213,7 +213,7 @@
     }
     
     // Should be java.util.List<java.lang.String>
-    public void testInferList2() throws Exception {
+    public void testInferList2() throws Throwable {
         String contents = "def x = [] << \"\"\nx";
         int start = contents.lastIndexOf("x");
         int end = start + "x".length();
---------------
-------------
@@ -52,7 +52,7 @@
 
     /** Pattern to find {.*} occurrences that do not match {[0-9]+} so to prevent MessageFormat from crashing.
      */
-    private static final Pattern INVALID_FORMAT_ELEMENT = Pattern.compile("\\Q{\\E[\\D^}]+\\Q}\\E");
+    private static final Pattern INVALID_FORMAT_ELEMENT = Pattern.compile("\\{[^}0-9]+\\}");
 
     /**
      * Private constructor to avoid instantiation.
---------------
-------------
@@ -212,6 +212,8 @@
                 if (end >= 0 && path.indexOf("/../", end) != 0) {
                     path = path.substring(0, end) + path.substring(i + 3);
                     i = 0;
+                } else if (end == 0) {
+                    break;
                 }
             } else
                 i = i + 3;
---------------
-------------
@@ -581,7 +581,7 @@
             if (channel.isConnected()) {
 
                 ChannelBuffer b = null;
-                if (f != null && f.getRequest().getStreamData() != null) {
+                if (f != null && f.getRequest().getFile() == null) {
                     b = f.getNettyRequest().getContent();
                 }
 
---------------
-------------
@@ -3,7 +3,6 @@
 
 import com.ning.http.client.RandomAccessBody;
 
-import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileNotFoundException;
---------------
-------------
@@ -232,7 +232,7 @@
             return httpProvider.execute(request, handler);
 
         } else {
-            FilterContext<T> fc = new FilterContext.FilterContextBuilder<>().asyncHandler(handler).request(request).build();
+            FilterContext<T> fc = new FilterContext.FilterContextBuilder<T>().asyncHandler(handler).request(request).build();
             try {
                 fc = preProcessRequest(fc);
             } catch (Exception e) {
---------------
-------------
@@ -170,7 +170,7 @@
             AsyncHttpProviderUtils.validateSupportedScheme(originalUri);
 
             StringBuilder builder = new StringBuilder();
-            builder.append(originalUri.getScheme()).append("://").append(originalUri.getAuthority());
+            builder.append(originalUri.getScheme()).append("://").append(originalUri.getRawAuthority());
             if (isNonEmpty(originalUri.getRawPath())) {
                 builder.append(originalUri.getRawPath());
             } else {
---------------
-------------
@@ -711,7 +711,7 @@
         Throwable cause = e.getCause();
 
         if (log.isDebugEnabled())
-            log.debug("I/O Exception during read or doConnect: ", e.getCause());
+            log.debug("I/O Exception during read or doConnect: ", cause);
         if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
             NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
 
---------------
-------------
@@ -426,7 +426,7 @@
                     nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sb.length()));
                     nettyRequest.setContent(ChannelBuffers.copiedBuffer(sb.toString().getBytes()));
 
-                    if (request.getHeaders().getHeaderValues(Headers.CONTENT_TYPE) == null
+                    if (request.getHeaders().getHeaderValues(Headers.CONTENT_TYPE).isEmpty()
                             && request.getHeaders().getHeaderValue(Headers.CONTENT_TYPE) == null) {
                         nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE,"application/x-www-form-urlencoded");
                     }
---------------
-------------
@@ -298,7 +298,6 @@
                             .parseWWWAuthenticateHeader(wwwAuth)
                             .setUri(URI.create(request.getUrl()).getPath())
                             .setMethodName(request.getMethod())
-                            .setScheme(realm.getAuthScheme())
                             .setUsePreemptiveAuth(true)
                             .build();
                     RequestBuilder builder = new RequestBuilder(request);
---------------
-------------
@@ -946,6 +946,9 @@
 
                     if (future.incrementAndGetCurrentRedirectCount() < config.getMaxRedirects()) {
 
+                        // We must allow 401 handling again.
+                        future.getAndSetAuth(false);
+
                         String location = response.getHeader(HttpHeaders.Names.LOCATION);
                         if (location.startsWith("/")) {
                             location = AsyncHttpProviderUtils.getBaseUrl(future.getURI()) + location;
---------------
-------------
@@ -137,7 +137,7 @@
 					 * criteria restriction?
 					 */
 					// Check if ILog-object has acceptable learningObjectType
-					if (ELearningObjectType.fromLogMiningType(log).toString().equals(type))
+					if (ELearningObjectType.fromLogMiningType(log).toString().toUpperCase().equals(type))
 					{
 						typeOk = true;
 						break;
---------------
-------------
@@ -16,7 +16,7 @@
 		    .withFixture(FixtureDatumFactoriesForAssets.units())
 		    .withFixture(FixtureDatumFactoriesForAssets.propertyActors())
 			.withFixture(FixtureDatumFactoriesForJoda.dates())
-			.exercise(new Property(), FilterSet.excluding("container","units","propertyActorsRepo"));
+			.exercise(new Property(), FilterSet.excluding("container","units","propertyActorsRepo", "properties"));
 	}
 
 }
---------------
-------------
@@ -68,7 +68,7 @@
     /**
      * Internal connection used to collect extraction results.
      */
-    private RepositoryConnection conn;
+    protected RepositoryConnection conn;
 
     /**
      * The latest generated report.
---------------
-------------
@@ -119,6 +119,10 @@
         }
         response.setContentType(outputMediaType);
         response.setStatus(200);
+        // TODO - nigh: #14 for the moment UTF-8 has been set as the default output encoding. To fix this,
+        // should be implemented an improved report from the runner.extract that set the output encoding
+        // equals to the input one
+        response.setCharacterEncoding("UTF-8");
         response.getOutputStream().write(byteOutStream.toByteArray());
     }
 
---------------
-------------
@@ -107,7 +107,7 @@
         } catch (RDFHandlerException ex) {
             throw new IllegalStateException("Unexpected exception.", ex);
         } catch (RDFParseException ex) {
-            throw new ExtractionException("Error while parsing RDF document.", ex, extractionResult);
+//            throw new ExtractionException("Error while parsing RDF document.", ex, extractionResult);
         }
     }
 
---------------
-------------
@@ -93,7 +93,7 @@
                 RDFUtils.uri("http://purl.org/dc/01/name"),
                 RDFUtils.literal("Departments")
         );
-        assertStatementsSize(null, null, null, 8);
+        assertStatementsSize(null, null, null, 6);
         logger.debug(dumpHumanReadableTriples());
     }
 
---------------
-------------
@@ -26,7 +26,7 @@
         for (String _pair : pairs) {
             String[] pair = _pair.split("=");
             qry.put(Global.decodeURIComponent(pair[0]),
-                    pair.length > 0 ? Global.decodeURIComponent(pair[1]) : "");
+                    pair.length > 1 ? Global.decodeURIComponent(pair[1]) : "");
         }
         return qry;
     }
---------------
-------------
@@ -11,7 +11,7 @@
 
     <Interface, Concrete extends Interface> Container addInstance(Class<Interface> anInterface, Concrete instance);
 
-    <Type> Container addActivator(Class<Type> aClass, Activator<Type> activator);
+    <Type, ExtendsType extends Type> Container addActivator(Class<Type> aClass, Activator<ExtendsType> activator);
 
     <Type, AnActivator extends Activator<Type>> Container addActivator(Class<Type> aClass, Class<AnActivator> activator);
 
---------------
-------------
@@ -252,7 +252,7 @@
                         this.addDerivedKeyElement(secondRefList);
                     } else if (!secondEncrParts.isEmpty()) {
                         //Encrypt, get hold of the ref list and add it
-                        secondRefList = ((WSSecEncrypt)encr).encryptForRef(null, encrParts);
+                        secondRefList = ((WSSecEncrypt)encr).encryptForRef(null, secondEncrParts);
                         this.addDerivedKeyElement(secondRefList);
                     }
                 }
---------------
-------------
@@ -145,6 +145,8 @@
         message = transform(message);
         if (writer != null) {
             writer.println(message);
+            // Flush the writer to make sure the message is wrote
+            writer.flush();
         } else if (getLogger().isLoggable(Level.INFO)) {
             getLogger().info(message);
         }
---------------
-------------
@@ -434,7 +434,7 @@
         }
         
         AbstractToken sigToken = wrapper.getToken();
-        if (sbinding.isProtectTokens() && (sigToken instanceof X509Token)) {
+        if (sbinding.isProtectTokens() && (sigToken instanceof X509Token) && isRequestor()) {
             parts += "{Element}{" + WSSConstants.NS_XMLENC + "}EncryptedKey;";
         }
         
---------------
-------------
@@ -61,6 +61,8 @@
     A128GCM(JoseConstants.A128GCM_ALGO, "AES/GCM/NoPadding", 128),
     A192GCM(JoseConstants.A192GCM_ALGO, "AES/GCM/NoPadding", 192),
     A256GCM(JoseConstants.A256GCM_ALGO, "AES/GCM/NoPadding", 256),
+    //TODO: default to "AES/CBC/PKCS5Padding" if Cipher "AES/CBC/PKCS7Padding" 
+    // can not be initialized, apparently Java 8 has decided to settle on PKCS5Padding only 
     A128CBC_HS256(JoseConstants.A128CBC_HS256_ALGO, "AES/CBC/PKCS7Padding", 128),
     A192CBC_HS384(JoseConstants.A192CBC_HS384_ALGO, "AES/CBC/PKCS7Padding", 192),
     A256CBC_HS512(JoseConstants.A256CBC_HS512_ALGO, "AES/CBC/PKCS7Padding", 256);
---------------
-------------
@@ -46,7 +46,7 @@
             location = "schemas/oasis-200401-wss-wssecurity-secext-1.0.xsd";
         } else if ("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd".equals(s)) {
             location = "schemas/oasis-200401-wss-wssecurity-utility-1.0.xsd";
-        } else if ("http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/ws-securitypolicy-1.2.xsd".equals(s)) {
+        } else if ("http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702".equals(s)) {
             location = "schemas/ws-securitypolicy-1.2.xsd";
         }
         if (location != null) {
---------------
-------------
@@ -44,6 +44,6 @@
 
     @Override
     public void writeObject(final Object object, final MessageWriter writer, final Context context) {
-        writer.writeValue(object.toString());
+    	writer.writeValue(((BigDecimal) object).toPlainString());
     }
 }
---------------
-------------
@@ -73,6 +73,7 @@
             PKIXBuilderParameters pkixParams = new PKIXBuilderParameters(trustAnchors, selector);
             pkixParams.addCertStore(CertStore.getInstance("Collection", intermediateParams));
             pkixParams.addCertStore(CertStore.getInstance("Collection", certificateParams));
+            pkixParams.setRevocationEnabled(false);
             CertPathBuilder builder = CertPathBuilder.getInstance("PKIX");
             builder.build(pkixParams);
         } catch (InvalidAlgorithmParameterException e) {
---------------
-------------
@@ -174,7 +174,6 @@
             this.add(targetPrincipal.getName(), targetRealm, identities);
             this.add(sourcePrincipal.getName(), sourceRealm, identities);
         }
-        System.out.println("Cache content: " + this.cache.toString());
         return targetPrincipal;
     }
     
---------------
-------------
@@ -45,4 +45,5 @@
   protected ILaunchManager getLaunchManager() {
     return DebugPlugin.getDefault().getLaunchManager();
   }
+
 }
---------------
-------------
@@ -36,7 +36,7 @@
         throw new AssertionError();
     }
 
-    public static final long ONE_YEAR = 365*86400*1000;
+    public static final long ONE_YEAR = 365L*86400L*1000L;
    /**
     * Formats a date object, using the default time zone for this host
     * @param d date object to be formatted
---------------
-------------
@@ -478,7 +478,7 @@
     if (resolveResult instanceof JSParameter && isInjectable(resolveResult)) {
       final String name = ((JSParameter)resolveResult).getName();
       final JSTypeSource source = JSTypeSourceFactory.createTypeSource(resolveResult);
-      final JSType type = JSNamedType.createType(name, source, JSContext.INSTANCE);
+      final JSType type = JSNamedType.createType(name, source, JSContext.UNKNOWN);
       evaluator.addType(type, resolveResult);
     }
     return false;
---------------
-------------
@@ -183,7 +183,6 @@
         VirtualFile file = root.findFileByRelativePath(filePathInSource);
 
       PsiFile psiFile = PsiManager.getInstance(project).findFile(file);
-      DumbService.getInstance(project).waitForSmartMode();
 
       return psiFile;
     }
---------------
-------------
@@ -181,7 +181,7 @@
       if (start >= 0) {
         final JSDocumentationUtils.DocTag docTag = JSDocumentationUtils.getDocTag(line.substring(start));
         if (docTag != null) {
-          param = docTag.matchValue;
+          param = docTag.matchValue != null ? docTag.matchValue : param;
           if (attributes.length() > 0) attributes.append(",");
           attributes.append(docTag.matchName);
         }
---------------
-------------
@@ -67,7 +67,7 @@
     Collections.addAll(INTERESTING_METHODS, "service", "factory", "value", "constant", "provider");
 
     INJECTABLE_METHODS.addAll(INTERESTING_METHODS);
-    Collections.addAll(INJECTABLE_METHODS, CONTROLLER, DIRECTIVE, MODULE);
+    Collections.addAll(INJECTABLE_METHODS, CONTROLLER, DIRECTIVE, MODULE, "config", "run");
 
     INDEXERS.put(DIRECTIVE, AngularDirectivesIndex.KEY);
     NAME_CONVERTERS.put(DIRECTIVE, new Function<String, String>() {
---------------
-------------
@@ -72,7 +72,7 @@
 
           if (element instanceof DartCallExpression) {
             DartCallExpression expression = (DartCallExpression)element;
-            if (DartUnitRunConfigurationProducer.isTest(expression)) {
+            if (DartUnitRunConfigurationProducer.isTest(expression) || DartUnitRunConfigurationProducer.isGroup(expression)) {
               if (nameMatches(expression, nodes[nodes.length - 1])) {
                 boolean matches = true;
                 for (int i = nodes.length - 2; i >= 0 && matches; --i) {
---------------
-------------
@@ -51,7 +51,7 @@
   protected StrutsFacet myFacet;
 
   @NonNls
-  private static final String SOURCE_PATH = "/src";
+  protected static final String SOURCE_PATH = "/src";
 
   protected Class<T> getModuleFixtureBuilderClass() {
     //noinspection unchecked
---------------
-------------
@@ -5,5 +5,5 @@
  * Date: 8/9/12
  */
 public class CucumberJavaTestUtil {
-  public static final String RELATED_TEST_DATA_PATH = "\\contrib\\cucumber-java\\testData\\";
+  public static final String RELATED_TEST_DATA_PATH = "/contrib/cucumber-java/testData/";
 }
---------------
-------------
@@ -79,7 +79,7 @@
   }
 
   public static MarkedQUnitModuleStructure newDefaultModule() {
-    return new MarkedQUnitModuleStructure(true, 0, "Default", null);
+    return new MarkedQUnitModuleStructure(true, 0, "Default Module", null);
   }
 
   public static MarkedQUnitModuleStructure newRegularModule(@NotNull Annotation startAnnotation) {
---------------
-------------
@@ -37,7 +37,7 @@
      * Public constructor.
      */
     public LastNameRandomizer() {
-        super(ResourceBundle.getBundle("io/github/benas/jpopulator/data/data").getString("firstNames").split(","));
+        super(ResourceBundle.getBundle("io/github/benas/jpopulator/data/data").getString("lastNames").split(","));
     }
 
 }
---------------
-------------
@@ -79,7 +79,7 @@
 				
 		Sample platformUnit = run.getPlatformUnit();
 		
-		if (sampleService.sampleIsPlatformUnit(platformUnit)) {
+		if (sampleService.isPlatformUnit(platformUnit)) {
 			// isPlatformUnit?
 			logger.debug("platform unit: " + platformUnit.getName());
 		} else {
---------------
-------------
@@ -42,7 +42,7 @@
      * Pattern for windows is a uri that can be 1024 characters long
      * @see <a href="http://blogs.windows.com/windows_phone/b/wpdev/archive/2013/10/22/recommended-practices-for-using-microsoft-push-notification-service-mpns.aspx?Redirected=true">Windows developer blog</a>
      */
-    private static final Pattern WINDOWS_DEVICE_TOKEN = Pattern.compile("https://.{0,1024}");
+    private static final Pattern WINDOWS_DEVICE_TOKEN = Pattern.compile("https?://.{0,1024}");
 
     /**
      * The SimplePush token is an URI. While we strongly recommend https, it is in theory possible that users of the
---------------
-------------
@@ -1,3 +1,19 @@
+/**
+ * JBoss, Home of Professional Open Source
+ * Copyright Red Hat, Inc., and individual contributors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.jboss.aerogear.unifiedpush.utils;
 
 import javax.enterprise.context.ApplicationScoped;
---------------
-------------
@@ -252,7 +252,7 @@
 			type = ( (Method) member ).getGenericReturnType();
 		}
 		else if ( member instanceof Constructor<?> ) {
-			type = ( (Constructor<?>) member ).getDeclaringClass();
+			type = member.getDeclaringClass();
 		}
 		//TODO HV-571 change log method name
 		else {
---------------
-------------
@@ -133,9 +133,7 @@
     String actionMountpoint = action.getPath();
     String[] params = path.substring(actionMountpoint.length()).split("/");
 
-    // first param is empty (because of leading slash), therefore start with
-    // index 1
-    for (int i = 1; i < params.length; i++) {
+    for (int i = 0; i < params.length; i++) {
       urlparams.add(params[i]);
     }
 
---------------
-------------
@@ -101,6 +101,7 @@
     try {
       DocumentBuilder docBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
       Document doc = docBuilder.newDocument();
+      doc.setXmlStandalone(true);
       Element root = doc.createElement("greetings");
       doc.appendChild(root);
       for (Map.Entry<String, String> greeting : greetings.entrySet()) {
---------------
-------------
@@ -54,7 +54,7 @@
   private static final Pattern pathInspector = Pattern.compile("^(.*)/(work|index|live|[0-9]*)(_[a-zA-Z]+)?\\.([a-zA-Z0-9]+)$");
 
   /** Regular expression for /path/to/resource/de/html */
-  private static final Pattern segmentInspector = Pattern.compile("^(/([a-zA-Z0-9\\-\\,\\.\\;/_%^#^\\?])*+)+$");
+  private static final Pattern segmentInspector = Pattern.compile("^(/([a-zA-Z0-9\\-\\,\\.\\:\\;\\(\\)/_~!\\$&\\*'\\+=@%^#^\\?])*+)+$");
 
   /** The default request flavor */
   private final RequestFlavor defaultFlavor = RequestFlavor.ANY;
---------------
-------------
@@ -95,6 +95,7 @@
     this.pageXml = pageXml;
     this.headerXml = headerXml;
     this.previewXml = previewXml;
+    this.page = new PageImpl(uri);
   }
 
   /**
---------------
-------------
@@ -58,7 +58,7 @@
         int end = displayString.length();
         for (int i = 0; i < displayString.length(); i++) {
             char c = displayString.charAt(i);
-            if (!isJavaIdentifierPart(c) && c != '.') {
+            if (!(isJavaIdentifierPart(c) || c == '@' || c == '{' || c == '}') && c != '.') {
                 end = i;
                 break;
             }
---------------
-------------
@@ -77,7 +77,7 @@
                         if (wordBoundaryFound && !Character.isUpperCase(c1))
                             continue;
 
-                        wordBoundaryFound = false;
+                        // wordBoundaryFound = false;
                         int[] copy = Arrays.copyOf(s, s.length + 1);
                         copy[i] = j;
                         next.add(copy);
---------------
-------------
@@ -45,7 +45,7 @@
                 result.put(entry.getKey(), list);
             }
         }
-        return result;
+        return sortByDate(result);
     }
 
     public static List<IFeedMessage> updateMessages(Entry<FeedDescriptor, List<IFeedMessage>> entry) {
---------------
-------------
@@ -1,3 +1,13 @@
+/**
+ * Copyright (c) 2010, 2013 Darmstadt University of Technology.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Olav Lenz - initial API and implementation
+ */
 package org.eclipse.recommenders.internal.models.rcp;
 
 import static com.google.common.base.Optional.*;
---------------
-------------
@@ -54,7 +54,7 @@
 public class JavaProjectFixture {
 
     public static String findClassName(final CharSequence source) {
-        Pattern p = Pattern.compile(".*class\\s+(\\w+).*", Pattern.DOTALL);
+        Pattern p = Pattern.compile(".*?class\\s+(\\w+).*", Pattern.DOTALL);
         Matcher matcher = p.matcher(source);
         if (!matcher.matches()) {
             p = Pattern.compile(".*interface\\s+(\\w+).*", Pattern.DOTALL);
---------------
-------------
@@ -62,7 +62,7 @@
 
     @Override
     public boolean visit(final MethodInvocation node) {
-        if (receiverExpressionMatchesVarname(node.getExpression()) || isReceiverThis(node)) {
+        if (receiverExpressionMatchesVarname(node.getExpression()) || (isThis() && isReceiverThis(node))) {
             final IMethodBinding b = node.resolveMethodBinding();
             registerMethodCallOnReceiver(b);
         }
---------------
-------------
@@ -35,7 +35,7 @@
       ByteArrayInputStream bytesIn = new ByteArrayInputStream(src, srcOffset, srcLength);
       GZIPInputStream gzip = new GZIPInputStream(bytesIn);
       int curOff = dstOff;
-      while (true) {
+      while (curOff < dst.length - dstOff) {
         int amtRead = gzip.read(dst, curOff, dst.length - curOff);
         if (amtRead == -1) {
           break;
---------------
-------------
@@ -1,7 +1,7 @@
 /*
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
  *
- * Copyright (c) 2006-2011 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006-2012 Oracle and/or its affiliates. All rights reserved.
  *
  * The contents of this file are subject to the terms of either the GNU
  * General Public License Version 2 only ("GPL") or the Common Development
---------------
-------------
@@ -198,7 +198,7 @@
                 
                 if ((existingProp == null) || !unescapedValue.equals(existingProp.getValue())) {
                     data.put(escapedName, property.get("value"));
-                    if (canSaveDesc) {
+                    if (canSaveDesc && (description != null)) {
                         data.put(escapedName + ".description", description);
                     }
                 }
---------------
-------------
@@ -1,7 +1,7 @@
 /*
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
  *
- * Copyright (c) 1997-2012 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997-2013 Oracle and/or its affiliates. All rights reserved.
  *
  * The contents of this file are subject to the terms of either the GNU
  * General Public License Version 2 only ("GPL") or the Common Development
---------------
-------------
@@ -310,7 +310,7 @@
         ConfigParser parser = new ConfigParser(habitat);
         URL fileUrl = null;
         try {
-            fileUrl = new URL("file://" + filePath);
+            fileUrl = new File(filePath).toURI().toURL();
         } catch (MalformedURLException e) {
             // should not happen
             // TODO Auto-generated catch block
---------------
-------------
@@ -710,6 +710,7 @@
                 if(jtr.hasNext()) {
                     itr.set(jtr.next());    // replace
                     last = itr.nextIndex();
+                    removed.add(child);
                 } else {
                     itr.remove();   // remove
                     removed.add(child);
---------------
-------------
@@ -69,6 +69,7 @@
     }
 
     void addDefiningURI(URI uri) {
+        definingURIs.add(uri);
         try {
             File file = new File(uri);
 //            assert(file.exists()) : file + " does not exist";
---------------
-------------
@@ -710,6 +710,7 @@
                 if(jtr.hasNext()) {
                     itr.set(jtr.next());    // replace
                     last = itr.nextIndex();
+                    removed.add(child);
                 } else {
                     itr.remove();   // remove
                     removed.add(child);
---------------
-------------
@@ -710,6 +710,7 @@
                 if(jtr.hasNext()) {
                     itr.set(jtr.next());    // replace
                     last = itr.nextIndex();
+                    removed.add(child);
                 } else {
                     itr.remove();   // remove
                     removed.add(child);
---------------
-------------
@@ -710,6 +710,7 @@
                 if(jtr.hasNext()) {
                     itr.set(jtr.next());    // replace
                     last = itr.nextIndex();
+                    removed.add(child);
                 } else {
                     itr.remove();   // remove
                     removed.add(child);
---------------
-------------
@@ -69,6 +69,7 @@
     }
 
     void addDefiningURI(URI uri) {
+        definingURIs.add(uri);
         try {
             File file = new File(uri);
 //            assert(file.exists()) : file + " does not exist";
---------------
-------------
@@ -62,6 +62,16 @@
  *       implements PayBy {}
  * </pre>
  * 
+ * <p>
+ * An extension of AnnotationLiteral must do two things:<OL>
+ * <LI>Must have the target annotation as its generic type</LI>
+ * <LI>Must implement the target type</LI>
+ * </OL>
+ * </p>
+ * In particular, in-line anonymous extensions of AnnotationLiteral will not
+ * work because in-line anonymous extensions of AnnotationLiteral cannot implement
+ * the target annotation
+ * 
  * @author jwells
  * 
  * @param <T> the annotation type
---------------
-------------
@@ -62,6 +62,16 @@
  *       implements PayBy {}
  * </pre>
  * 
+ * <p>
+ * An extension of AnnotationLiteral must do two things:<OL>
+ * <LI>Must have the target annotation as its generic type</LI>
+ * <LI>Must implement the target type</LI>
+ * </OL>
+ * </p>
+ * In particular, in-line anonymous extensions of AnnotationLiteral will not
+ * work because in-line anonymous extensions of AnnotationLiteral cannot implement
+ * the target annotation
+ * 
  * @author jwells
  * 
  * @param <T> the annotation type
---------------
-------------
@@ -72,7 +72,7 @@
 	private void addAxis(PVector start, PVector end, PVector preStart) {
 		PVector axis = PVector.sub(start, end);
 		axis.normalize();
-		rotate(axis,Math.PI/2);
+		axis = rotate(axis,Math.PI/2);
 		float project1 = axis.dot(start);
 		float projectpre = axis.dot(preStart);
 		assert project1 != projectpre : "Polygon must be convex!";
---------------
-------------
@@ -68,6 +68,9 @@
                 while (it.hasNext()) {
                     encodeObject(encoder, it.next(), false);
                 }
+                
+                // Make sure we pop the node we just pushed -- needed for fix to CAY-597.
+                encoder.pop();
             }
         }
         else {
---------------
-------------
@@ -41,7 +41,6 @@
 
     public static final String TEST_ACCESS_STACK = "TestStack";
     public static final String MULTI_TIER_ACCESS_STACK = "MultiTierStack";
-    public static final String QUALIFIED_ACCESS_STACK = "QualifiedStack";
 
     protected AccessStack accessStack;
 
---------------
-------------
@@ -91,7 +91,6 @@
     objRef.set(viewResponse);
     multigetRef.set(oper);
     status = s;
-    notifyListeners();
   }
 
   @Override
---------------
-------------
@@ -3163,7 +3163,7 @@
             } else if (origValue instanceof Fragments) {
                 result.set(privateCreator, tag, (Fragments) origValue);
             } else {
-                result.set(privateCreator, tag, vrs[i], origValue);
+                result.set(privateCreator, tag, vrs[j], origValue);
             }
         }
         return result;
---------------
-------------
@@ -277,7 +277,7 @@
             }
             else if (listedNode instanceof ListNode)
             {
-                convertListNode(writer, (ListNode)listedNode, offset);
+                convertListNode(writer, (ListNode)listedNode, offset + 1);
                 endOfMapOrList = true;
             }
             else
---------------
-------------
@@ -259,7 +259,7 @@
      */
     public boolean isMsgField(String msgType, int field) {
         Set fields = (Set) messageFields.get(msgType);
-        return fields != null & fields.contains(new Integer(field));
+        return fields != null && fields.contains(new Integer(field));
     }
 
     private void addHeaderField(int field, boolean required) {
---------------
-------------
@@ -78,7 +78,8 @@
        }
 
        //start at midpoint
-       int mid = (rare * ((2 * diplotypes) - rare)) / (2 * diplotypes);
+       //cast to long and back to int to avoid overflow at large numbers
+       int mid = (int) (((long) rare * ((2 * diplotypes) - rare)) / (2 * diplotypes));
 
        //check to ensure that midpoint and rare alleles have same parity
        if (((rare & 1) ^ (mid & 1)) != 0) {
---------------
-------------
@@ -1,5 +1,5 @@
 /**********************************************************************
- * Copyright 2008, 2012 Technical University Berlin, Germany and others.
+ * Copyright (c) 2008, 2014 Technical University Berlin, Germany and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
---------------
-------------
@@ -2470,7 +2470,7 @@
     		commentIndentationLevel = this.column - 1;
     	} else {
 			if (onFirstColumn &&
-					(!this.formatter.preferences.comment_format_line_comment_starting_on_first_column ||
+					((includesLineComments && !this.formatter.preferences.comment_format_line_comment_starting_on_first_column) ||
 					 this.formatter.preferences.never_indent_line_comments_on_first_column)
     			) {
 	   			commentIndentationLevel = this.column - 1;
---------------
-------------
@@ -663,6 +663,9 @@
 				if (staticFieldInfo == FlowInfo.DEAD_END) {
 					this.staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);
 					staticFieldInfo = FlowInfo.initial(this.maxFieldCount).setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
+				} else {
+					// make null info from static field visible for non-static @NonNull fields, too.
+					nonStaticFieldInfo.addNullInfoFrom(staticFieldInfo);
 				}
 			} else {
 				if ((nonStaticFieldInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0)
---------------
-------------
@@ -4588,7 +4588,7 @@
 	// Version that just answers based on inference kind (at 1.8+) when available.
 	public int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, InvocationSite site) {
 		if (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8 && method instanceof ParameterizedGenericMethodBinding) {
-			int inferenceKind = InferenceContext18.CHECK_STRICT;
+			int inferenceKind = InferenceContext18.CHECK_UNKNOWN;
 			InferenceContext18 context = null;
 			if (site instanceof Invocation) {
 				Invocation invocation = (Invocation) site;
---------------
-------------
@@ -163,7 +163,7 @@
 			MethodBinding currentMethod = ifcMethods[i];
 			if (currentMethod.isStatic())
 				continue;
-			if (areParametersEqual(original, currentMethod.original())) {
+			if (doesMethodOverride(original, currentMethod)) {
 				result.add(currentMethod);
 				return; // at most one method is overridden from any supertype
 			}
---------------
-------------
@@ -958,8 +958,8 @@
 			}
 			if (ambiguous != null)
 				return ambiguous;
-			if (visibleField != null && !visibleField.declaringClass.canBeSeenBy(this)) // double check that interface is visible
-				return new ProblemFieldBinding(visibleField, visibleField.declaringClass, fieldName, ProblemReasons.ReceiverTypeNotVisible);
+			//if (visibleField != null && !visibleField.declaringClass.canBeSeenBy(this)) // double check that interface is visible
+			//	return new ProblemFieldBinding(visibleField, visibleField.declaringClass, fieldName, ProblemReasons.ReceiverTypeNotVisible);
 		}
 
 		if (visibleField != null)
---------------
-------------
@@ -1137,7 +1137,7 @@
 			doTextInsert(endPos, " ", getEditGroup(children[children.length - 1])); //$NON-NLS-1$
 		} else if (isAllRemove) {
 			try {
-				int nextPos= getScanner().getNextStartOffset(endPos, true); // to the next token
+				int nextPos= getScanner().getNextStartOffset(endPos, false); // to the next token
 				doTextRemove(endPos, nextPos - endPos, getEditGroup(children[children.length - 1]));
 				return nextPos;
 			} catch (CoreException e) {
---------------
-------------
@@ -211,6 +211,7 @@
 											case '%':
 											case '&':
 											case '\'':
+											case ':':
 											case '-':
 											case '<' :
 											case '>':
---------------
-------------
@@ -104,7 +104,6 @@
 			.set(
 				CompilerOptions.DeadCode
 				|CompilerOptions.Tasks
-				|CompilerOptions.UnclosedCloseable
 				|CompilerOptions.NullSpecInsufficientInfo
 				|CompilerOptions.RedundantNullAnnotation);
 		// default errors IF AnnotationBasedNullAnalysis is enabled:
---------------
-------------
@@ -86,7 +86,7 @@
 		CompilerOptions compilerOptions = currentScope.compilerOptions();
 		if (!compilerOptions.includeNullInfoFromAsserts) {
 			// keep just the initializations info, don't include assert's null info
-			return flowInfo.addInitializationsFrom(assertInfo.nullInfoLessUnconditionalCopy());
+			return flowInfo.mergedWith(assertInfo.nullInfoLessUnconditionalCopy());
 		}
 		return flowInfo.mergedWith(assertInfo.nullInfoLessUnconditionalCopy()).
 			addInitializationsFrom(assertWhenTrueInfo.discardInitializationInfo());
---------------
-------------
@@ -59,7 +59,6 @@
 	}
 
 	@Override
-	@AllowedAnonymous
 	public UserProteinList getUserProteinListById(long listId) {
 		try {
 			return proteinListDao.getUserProteinListById(listId);
---------------
-------------
@@ -367,7 +367,7 @@
 
 		long start = System.currentTimeMillis();
 		Set<String> accessions = new LinkedHashSet<String>();
-		Query query = buildQuery("entry", "simple_ids", queryRequest);
+		Query query = buildQuery("entry", "simple", queryRequest);
 		SearchResult result;
 		try {
 			result = executeQuery(query);
---------------
-------------
@@ -65,7 +65,7 @@
 			Node entryNode = b.get(x);
 			if (entryNode == null) {
 				qExec.close();
-				throw new NextProtException("Bind your protein result to a variable called ?entry. Example: \"?entry :classifiedWith term:KW-0813.\"");
+				throw new NextProtException("Bind your protein result to a variable called ?entry. Example: \"?entry :classifiedWith cv:KW-0813.\"");
 			} else if (entryNode.toString().indexOf(ENTRY_SUFFIX_URI) == -1) {
 				qExec.close();
 				throw new NextProtException("Any entry found in the output, however was found: " + entryNode.toString());
---------------
-------------
@@ -344,6 +344,7 @@
             int size = inputBuffer.readInt32();
             buffer.writeInt(size);
             buffer.write(inputBuffer.readBytes(size - 4));
+            reader.setState(BSONReader.State.TYPE);
         } else {
             super.pipe(reader);
         }
---------------
-------------
@@ -54,7 +54,7 @@
     }
 
     public String toString(){
-        return "{ \"$ref\" : \"" + _ns + "\", \"$id\" : " + _id + " }";
+        return "{ \"$ref\" : \"" + _ns + "\", \"$id\" : \"" + _id + "\" }";
     }
 
     final Object _id;
---------------
-------------
@@ -1287,7 +1287,7 @@
         
         List<DBObject> pipelineOps = new ArrayList<DBObject>();
         pipelineOps.add(firstOp);
-        pipelineOps.addAll(Arrays.asList(additionalOps));
+        Collections.addAll(pipelineOps, additionalOps);
         command.put( "pipeline", pipelineOps );
         
         CommandResult res = _db.command( command );
---------------
-------------
@@ -733,7 +733,7 @@
             throw new JsonParseException("JSON reader expected a string but found '%s'.", valueToken.getValue());
         }
         verifyToken(")");
-        String[] patterns = {"yyyy-MM-dd", "yyyy-MM-dd'T'hh:mm:ssz", "yyyy-MM-dd'T'hh:mm:ss.SSSz"};
+        String[] patterns = {"yyyy-MM-dd", "yyyy-MM-dd'T'HH:mm:ssz", "yyyy-MM-dd'T'HH:mm:ss.SSSz"};
 
         SimpleDateFormat format = new SimpleDateFormat(patterns[0], Locale.ENGLISH);
         ParsePosition pos = new ParsePosition(0);
---------------
-------------
@@ -52,7 +52,7 @@
     }
 
     @Override
-    protected boolean skipField(String key) {
+    protected boolean skipField(final String key) {
         return key.equals(ID_FIELD_NAME);
     }
 
---------------
-------------
@@ -74,6 +74,7 @@
      * @return the object removed
      */
     public Object removeField( String key ){
+        _keys.remove(key);
         return remove( key );
     }
 
---------------
-------------
@@ -45,7 +45,7 @@
 
         final DBCollection coll = _db.getCollectionFromString(_ns);
 
-        _pointedTo = coll.find(_id);
+        _pointedTo = coll.findOne(_id);
         _loadedPointedTo = true;
         return _pointedTo;
     }
---------------
-------------
@@ -242,7 +242,7 @@
                 name += "_";
             name += s + "_";
             Object val = keys.get( s );
-            if ( val instanceof Number )
+            if ( val instanceof Number || val instanceof String )
                 name += val.toString().replace( ' ' , '_' );
         }
         return name;
---------------
-------------
@@ -383,6 +383,8 @@
                 case 'r': special = '\r'; break;
                 case 't': special = '\t'; break;
                 case 'b': special = '\b'; break;
+                case '"': special = '\"'; break;
+                case '\\': special = '\\'; break;
                 }
                 
                 if ( special != 0 ){
---------------
-------------
@@ -1884,7 +1884,7 @@
         assigment.accept(this);
         StringConcatenation _builder_4 = new StringConcatenation();
         String _xifexpression = null;
-        boolean _needsReturnValue = this._aSTFlattenerUtils.needsReturnValue(assigment);
+        boolean _needsReturnValue = this._aSTFlattenerUtils.needsReturnValue(node);
         if (_needsReturnValue) {
           _xifexpression = tempVarName;
         }
---------------
-------------
@@ -35,7 +35,6 @@
 		try {
 			final IXtextDocument document = XtextDocumentUtil.get(sourceViewer);
 			if (document != null) {
-				System.out.println("region " + region);
 				document.modify(new UnitOfWork<Object>() {
 					public Object exec(XtextResource resource) throws Exception {
 						// TODO replace with partial parsing which doesn't work reliable yet
---------------
-------------
@@ -41,7 +41,7 @@
 	protected class ExpandRuleCalls implements Function<ISerState, Pda<ISerState, RuleCall>> {
 		@Override
 		public Pda<ISerState, RuleCall> apply(ISerState input) {
-			if (GrammarUtil.isUnassignedParserRuleCall(input.getGrammarElement()))
+			if (GrammarUtil.isUnassignedEObjectRuleCall(input.getGrammarElement()))
 				return getContextPDA((((RuleCall) input.getGrammarElement()).getRule()));
 			return null;
 		}
---------------
-------------
@@ -98,7 +98,7 @@
 		content.append("Bundle-ManifestVersion: 2\n");
 		content.append("Bundle-Name: " + projectName + "\n");
 		content.append("Bundle-Vendor: My Company\n");
-		content.append("Bundle-Version: 1.0.0\n");
+		content.append("Bundle-Version: 1.0.0.qualifier\n");
 		content.append("Bundle-SymbolicName: " + projectName + "; singleton:=true\n");
 		if (null != activatorClassName) {
 			content.append("Bundle-Activator: " + activatorClassName + "\n");
---------------
-------------
@@ -78,6 +78,7 @@
 	CompilerBug451814Test.class,
 	CompilerBug452821Test.class,
 	CompilerBug455317Test.class,
+	CompilerBug456883Test.class,
 	CompilerBug457333Test.class,
 	CompilerBug457346Test.class,
 	CompilerBug457539Test.class,
---------------
-------------
@@ -634,7 +634,7 @@
 	 * @param object used for dispatching
 	 */
 	protected void _computeTypes(XStringLiteral object, ITypeComputationState state) {
-		if (object.getValue().length() != 1) {
+		if (object.getValue() != null && object.getValue().length() != 1) {
 			LightweightTypeReference result = getTypeForName(String.class, state);
 			state.acceptActualType(result);
 		} else {
---------------
-------------
@@ -634,7 +634,7 @@
 	 * @param object used for dispatching
 	 */
 	protected void _computeTypes(XStringLiteral object, ITypeComputationState state) {
-		if (object.getValue().length() != 1) {
+		if (object.getValue() != null && object.getValue().length() != 1) {
 			LightweightTypeReference result = getTypeForName(String.class, state);
 			state.acceptActualType(result);
 		} else {
---------------
-------------
@@ -338,8 +338,6 @@
 	
 	@Check
 	public void checkEnumLiteralIsValid(EnumLiteralDeclaration decl) {
-		EnumRule rule = GrammarUtil.containingEnumRule(decl);
-		guard(rule.getType().getMetamodel() instanceof GeneratedMetamodel);
 		if("".equals(decl.getLiteral().getValue()))
 			error("Enum literal must not be an empty string.", XtextPackage.ENUM_LITERAL_DECLARATION__LITERAL);
 	}
---------------
-------------
@@ -21,6 +21,7 @@
 	public final static String RICH_STRING_LITERAL_PARTITION = "__rich_string";
 	public static final String[] SUPPORTED_TOKEN_TYPES = new String[] { 
 		COMMENT_PARTITION, 
+		SL_COMMENT_PARTITION, 
 		STRING_LITERAL_PARTITION, 
 		RICH_STRING_LITERAL_PARTITION,
 		IDocument.DEFAULT_CONTENT_TYPE 
---------------
-------------
@@ -23,8 +23,7 @@
 
     public void testCommentOnEof() throws Exception {
         with(ReferenceGrammarStandaloneSetup.class);
-        // TODO: remove \n and make test succeed
-        String model = "//comment\n";
+        String model = "//comment";
         EList<LeafNode> leafNodes = getRootNode(model).getLeafNodes();
         assertEquals(1, leafNodes.size());
         EObject grammarElement = leafNodes.get(0).getGrammarElement();
---------------
-------------
@@ -120,7 +120,7 @@
 
 	protected String compileToJavaCode(String xtendCode) {
 		try {
-			final String text = "package foo class Test { def Object foo() {" + xtendCode + "} }";
+			final String text = "package foo class Test { def Object foo() throws Exception {" + xtendCode + "} }";
 			final XtendFile file = parseHelper.parse(text);
 			validationHelper.assertNoErrors(file);
 			JvmGenericType inferredType = associations.getInferredType(file.getXtendClass());
---------------
-------------
@@ -166,7 +166,7 @@
 			return clazz;
 		} catch(ClassNotFoundException exception) {
 			int index = name.lastIndexOf('.');
-			if (index == -1) {
+			if (index <= 0) {
 				throw exception;
 			}
 			String baseName = name.substring(0, index);
---------------
-------------
@@ -188,7 +188,7 @@
 			ITreeAppendable debugAppendable = appendable.trace(forLoop, true);
 			internalToJavaStatement(expression, debugAppendable, true);
 			String variableName = null;
-			if (forLoop.getAfter() != null || forLoop.getSeparator() != null || forLoop.getAfter() != null) {
+			if (forLoop.getBefore() != null || forLoop.getSeparator() != null || forLoop.getAfter() != null) {
 				variableName = debugAppendable.declareSyntheticVariable(forLoop, "_hasElements");
 				debugAppendable.newLine();
 				debugAppendable.append("boolean ");
---------------
-------------
@@ -1884,7 +1884,7 @@
         assigment.accept(this);
         StringConcatenation _builder_4 = new StringConcatenation();
         String _xifexpression = null;
-        boolean _needsReturnValue = this._aSTFlattenerUtils.needsReturnValue(assigment);
+        boolean _needsReturnValue = this._aSTFlattenerUtils.needsReturnValue(node);
         if (_needsReturnValue) {
           _xifexpression = tempVarName;
         }
---------------
-------------
@@ -120,7 +120,7 @@
 
 	protected String compileToJavaCode(String xtendCode) {
 		try {
-			final String text = "package foo class Test { def Object foo() {" + xtendCode + "} }";
+			final String text = "package foo class Test { def Object foo() throws Exception {" + xtendCode + "} }";
 			final XtendFile file = parseHelper.parse(text);
 			validationHelper.assertNoErrors(file);
 			JvmGenericType inferredType = associations.getInferredType(file.getXtendClass());
---------------
-------------
@@ -78,6 +78,7 @@
 	CompilerBug451814Test.class,
 	CompilerBug452821Test.class,
 	CompilerBug455317Test.class,
+	CompilerBug456883Test.class,
 	CompilerBug457333Test.class,
 	CompilerBug457346Test.class,
 	CompilerBug457539Test.class,
---------------
-------------
@@ -235,6 +235,7 @@
 		projectFactory.addProjectNatures(JavaCore.NATURE_ID, "org.eclipse.pde.PluginNature",
 				XtextProjectHelper.NATURE_ID);
 		projectFactory.addRequiredBundles(newArrayList(
+				"com.google.inject",
 				"org.eclipse.xtext.xbase.lib", 
 				"org.eclipse.xtend2.lib",
 				"org.junit4"));
---------------
-------------
@@ -41,7 +41,7 @@
 	protected class ExpandRuleCalls implements Function<ISerState, Pda<ISerState, RuleCall>> {
 		@Override
 		public Pda<ISerState, RuleCall> apply(ISerState input) {
-			if (GrammarUtil.isUnassignedParserRuleCall(input.getGrammarElement()))
+			if (GrammarUtil.isUnassignedEObjectRuleCall(input.getGrammarElement()))
 				return getContextPDA((((RuleCall) input.getGrammarElement()).getRule()));
 			return null;
 		}
---------------
-------------
@@ -257,7 +257,7 @@
 		if (!declaredConstructor) {
 			JvmConstructor constructor = typesFactory.createJvmConstructor();
 			target.getMembers().add(constructor);
-			associator.associatePrimary(source, constructor);
+			associator.associate(source, constructor);
 			constructor.setSimpleName(source.getName());
 			constructor.setVisibility(JvmVisibility.PUBLIC);
 		}
---------------
-------------
@@ -40,6 +40,7 @@
 	Bug448017Test.class,
 	Bug450911Test.class,
 	Bug453271Test.class,
+	Bug458611Test.class,
 	MemberFeatureCallProposalsTest.class
 })
 public class ContentAssistSuite {
---------------
-------------
@@ -886,7 +886,7 @@
 							if (declaredConstraint instanceof JvmUpperBound) {
 								for(JvmTypeConstraint actualConstraint: reference.getConstraints()) {
 									if (actualConstraint instanceof JvmUpperBound) {
-										outerVisit(declaredConstraint.getTypeReference(), new ResolveInfo(actualConstraint.getTypeReference(), ResolveInfoKind.UPPER, param.hint));
+										outerVisit(declaredConstraint.getTypeReference(), new ResolveInfo(actualConstraint.getTypeReference(), allowWildcardResolutions ? ResolveInfoKind.WC_UPPER : ResolveInfoKind.UPPER, param.hint));
 									}
 								}
 							} else {
---------------
-------------
@@ -87,7 +87,7 @@
 	
 	protected boolean allowsSimpleName(String qualifiedName, String simpleName) {
 		return equal(qualifiedName, thisTypeQualifiedName) 
-				|| JAVA_LANG_PACK.matcher(qualifiedName).matches() 
+				|| (JAVA_LANG_PACK.matcher(qualifiedName).matches() && !CodeGenUtil.isJavaLangType(thisTypeSimpleName)) 
 				|| equal(qualifiedName, simpleName);
 	}
 	
---------------
-------------
@@ -464,7 +464,7 @@
 		}));
 		Collections.sort(sortMe, new Comparator<XImportDeclaration>() {
 			public int compare(XImportDeclaration o1, XImportDeclaration o2) {
-				return o1.getImportedTypeName().compareTo(o2.getImportedTypeName());
+				return o1.getImportedName().compareTo(o2.getImportedName());
 			}
 		});
 		return sortMe;
---------------
-------------
@@ -134,7 +134,7 @@
 			if (result.length() != 0)
 				throw new ValueConverterWithValueException("Illegal character in identifier '" + result + "' (" + identifier + ")", node, result, null);
 			else
-				throw new ValueConverterException("Illegal character in identifier '" + identifier + "'", node, null);
+				throw new ValueConverterWithValueException("Illegal character in identifier '" + identifier + "'", node, null, null);
 		}
 		return result;
 	}
---------------
-------------
@@ -93,7 +93,7 @@
 					break;
 				}
 			}
-			end = Math.max(end, actual.getCurrent().getStopIndex());
+			end = Math.max(end, actual.getCurrent().getStopIndex()+1);
 			// the first pair of tokens which are not equal between previous and
 			// current text determines the start offset
 			start = Math.min(start, actual.getCurrent().getStartIndex());
---------------
-------------
@@ -75,7 +75,7 @@
 		if (eObject instanceof JvmGenericType) {
 			JvmGenericType genericType = (JvmGenericType) eObject;
 			if (genericType.isInterface())
-				userData.put(SIGNATURE_HASH_KEY, Boolean.TRUE.toString());
+				userData.put(IS_INTERFACE, Boolean.TRUE.toString());
 		}
 	}
 }
---------------
-------------
@@ -30,7 +30,7 @@
 	protected int multilineTokenType = -1;
 
 	@Inject
-	protected void initializeMultilineTokenType(@Named(LexerUIBindings.HIGHLIGHTING) ITokenDefProvider tokenDefProvider) {
+	public void setTokenDefProvider(@Named(LexerUIBindings.HIGHLIGHTING) ITokenDefProvider tokenDefProvider) {
 		Map<Integer, String> tokenDefMap = tokenDefProvider.getTokenDefMap();
 		Set<Entry<Integer, String>> entrySet = tokenDefMap.entrySet();
 		for(Entry<Integer, String> entry : entrySet){
---------------
-------------
@@ -120,7 +120,7 @@
 
 	protected String compileToJavaCode(String xtendCode) {
 		try {
-			final String text = "package foo class Test { def Object foo() {" + xtendCode + "} }";
+			final String text = "package foo class Test { def Object foo() throws Exception {" + xtendCode + "} }";
 			final XtendFile file = parseHelper.parse(text);
 			validationHelper.assertNoErrors(file);
 			JvmGenericType inferredType = associations.getInferredType(file.getXtendClass());
---------------
-------------
@@ -93,7 +93,7 @@
 					break;
 				}
 			}
-			end = Math.max(end, actual.getCurrent().getStopIndex());
+			end = Math.max(end, actual.getCurrent().getStopIndex()+1);
 			// the first pair of tokens which are not equal between previous and
 			// current text determines the start offset
 			start = Math.min(start, actual.getCurrent().getStartIndex());
---------------
-------------
@@ -93,7 +93,7 @@
 	}
 	
 	protected boolean isAccessibleXtextProject(IProject p) {
-		return p != null && XtextProjectHelper.hasNature(p) && XtextProjectHelper.hasNature(p);
+		return p != null && XtextProjectHelper.hasNature(p);
 	}
 	
 	protected IWorkspaceRoot getWorkspaceRoot() {
---------------
-------------
@@ -235,6 +235,7 @@
 		projectFactory.addProjectNatures(JavaCore.NATURE_ID, "org.eclipse.pde.PluginNature",
 				XtextProjectHelper.NATURE_ID);
 		projectFactory.addRequiredBundles(newArrayList(
+				"com.google.inject",
 				"org.eclipse.xtext.xbase.lib", 
 				"org.eclipse.xtend2.lib",
 				"org.junit4"));
---------------
-------------
@@ -96,8 +96,6 @@
 			sourceFile = compilationFileProvider.getFile(sourceURI, context.getBuiltProject());
 			if (sourceFile == null)
 				return;
-			if (sourceFile.isDerived())
-				return;
 			if (sourceFile.exists() && hasErrors(sourceFile))
 				return;
 			if (!sourceFile.exists() && delta.getNew() != null)
---------------
-------------
@@ -44,7 +44,7 @@
 	}
 
 	public JvmIdentifiableElement getFeature() {
-		throw new UnsupportedOperationException();
+		return null;
 	}
 
 	public List<LightweightTypeReference> getTypeArguments() {
---------------
-------------
@@ -172,7 +172,7 @@
 			ILeafNode node, final IHyperlinkAcceptor acceptor) {
 		IResolvedTypes resolveTypes = typeResolver.resolveTypes(resource);
 		final LightweightTypeReference type = resolveTypes.getActualType(typedElement);
-		if (type != null && !type.isUnknown()) {
+		if (type != null && !type.isUnknown() && type.getType() != null) {
 			createHyperlinksTo(resource, new Region(node.getOffset(), node.getLength()), type.getType(), new IHyperlinkAcceptor() {
 				@Override
 				public void accept(IHyperlink hyperlink) {
---------------
-------------
@@ -108,6 +108,8 @@
 			String text = linkingHelper.getCrossRefNodeAsString(node, true);
 			QualifiedName qn = qualifiedNameConverter.toQualifiedName(text);
 			URI targetURI = EcoreUtil.getURI(target);
+			if (target.eResource() != null && target.eResource().getResourceSet() != null)
+				targetURI = target.eResource().getResourceSet().getURIConverter().normalize(targetURI);
 			for (IEObjectDescription desc : scope.getElements(qn))
 				if (desc.getEObjectURI().equals(targetURI))
 					return tokenUtil.serializeNode(node);
---------------
-------------
@@ -96,8 +96,6 @@
 			sourceFile = compilationFileProvider.getFile(sourceURI, context.getBuiltProject());
 			if (sourceFile == null)
 				return;
-			if (sourceFile.isDerived())
-				return;
 			if (sourceFile.exists() && hasErrors(sourceFile))
 				return;
 			if (!sourceFile.exists() && delta.getNew() != null)
---------------
-------------
@@ -172,7 +172,7 @@
 			ILeafNode node, final IHyperlinkAcceptor acceptor) {
 		IResolvedTypes resolveTypes = typeResolver.resolveTypes(resource);
 		final LightweightTypeReference type = resolveTypes.getActualType(typedElement);
-		if (type != null && !type.isUnknown()) {
+		if (type != null && !type.isUnknown() && type.getType() != null) {
 			createHyperlinksTo(resource, new Region(node.getOffset(), node.getLength()), type.getType(), new IHyperlinkAcceptor() {
 				@Override
 				public void accept(IHyperlink hyperlink) {
---------------
-------------
@@ -49,6 +49,9 @@
 		if (javaProject.exists()) {
 			IPackageFragmentRoot[] allPackageFragmentRoots = javaProject.getAllPackageFragmentRoots();
 			for (IPackageFragmentRoot packageFragmentRoot : allPackageFragmentRoots) {
+				// prevents MalFormedURIException after executing the NewXtextProjectWizard
+				if (!packageFragmentRoot.isOpen())
+					packageFragmentRoot.open(null);
 				IResource correspondingResource = packageFragmentRoot.getCorrespondingResource();
 				if ((correspondingResource != null && correspondingResource instanceof IFile)
 						|| packageFragmentRoot instanceof JarPackageFragmentRoot) {
---------------
-------------
@@ -35,7 +35,6 @@
 		try {
 			final IXtextDocument document = XtextDocumentUtil.get(sourceViewer);
 			if (document != null) {
-				System.out.println("region " + region);
 				document.modify(new UnitOfWork<Object>() {
 					public Object exec(XtextResource resource) throws Exception {
 						// TODO replace with partial parsing which doesn't work reliable yet
---------------
-------------
@@ -120,7 +120,7 @@
 
 	protected String compileToJavaCode(String xtendCode) {
 		try {
-			final String text = "package foo class Test { def Object foo() {" + xtendCode + "} }";
+			final String text = "package foo class Test { def Object foo() throws Exception {" + xtendCode + "} }";
 			final XtendFile file = parseHelper.parse(text);
 			validationHelper.assertNoErrors(file);
 			JvmGenericType inferredType = associations.getInferredType(file.getXtendClass());
---------------
-------------
@@ -23,8 +23,7 @@
 
     public void testCommentOnEof() throws Exception {
         with(ReferenceGrammarStandaloneSetup.class);
-        // TODO: remove \n and make test succeed
-        String model = "//comment\n";
+        String model = "//comment";
         EList<LeafNode> leafNodes = getRootNode(model).getLeafNodes();
         assertEquals(1, leafNodes.size());
         EObject grammarElement = leafNodes.get(0).getGrammarElement();
---------------
-------------
@@ -484,7 +484,7 @@
     /** {@inheritDoc} */
     @Override
     public int indexOf(Object object) {
-        if(mode != STRICT_SORT_ORDER || comparator == null) return source.indexOf(object);
+        if(mode != STRICT_SORT_ORDER || comparator == null) return super.indexOf(object);
 
         // use the fact that we have sorted data to quickly locate a position
         // at which we can begin a linear search for an object that .equals(object)
---------------
-------------
@@ -584,6 +584,8 @@
                 for(Node<E> child = possibleAncestor.firstChild(); child != null; child = child.siblingAfter) {
                     child.parent = inserted;
                 }
+                // mark the ancestor as obsolete
+                possibleAncestor.element = null;
 
                 return inserted;
 
---------------
-------------
@@ -82,7 +82,7 @@
      * @param source the {@link EventList} containing duplicates to remove
      * @param comparator the {@link Comparator} used to determine equality
      */
-    public UniqueList(EventList<E> source, Comparator<E> comparator) {
+    public UniqueList(EventList<E> source, Comparator<? super E> comparator) {
         this(new SortedList<E>(source, comparator), (Void) null);
     }
 
---------------
-------------
@@ -513,7 +513,7 @@
     /** {@inheritDoc} */
     @Override
     public int lastIndexOf(Object object) {
-        if(mode != STRICT_SORT_ORDER || comparator == null) return source.lastIndexOf(object);
+        if(mode != STRICT_SORT_ORDER || comparator == null) return super.lastIndexOf(object);
 
         // use the fact that we have sorted data to quickly locate a position
         // at which we can begin a linear search for an object that .equals(object)
---------------
-------------
@@ -62,7 +62,7 @@
     private final DatasetChangeEvent immutableChangeEvent = new DatasetChangeEvent(this, this);
 
     /** a single column key for each and every row */
-    private static final List<Integer> COLUMN_KEYS = Collections.singletonList(0);
+    private static final List<Integer> COLUMN_KEYS = Collections.singletonList(new Integer(0));
 
     /** the Calculations providing the values of this CategoryDataset */
     private final ObservableElementList<Calculation<? extends Number>> calculations = new ObservableElementList<Calculation<? extends Number>>(new BasicEventList<Calculation<? extends Number>>(), GlazedLists.beanConnector(Calculation.class));
---------------
-------------
@@ -247,7 +247,7 @@
         int logicalColumnCountBefore = logicalColumnCount();
         int logicalRowCountBefore = logicalRowCount();
 
-        gridComponents.add(new CellComponents());
+        gridComponents.add(index, new CellComponents());
 
         fixCellCount(logicalRowCountBefore, logicalColumnCountBefore);
     }
---------------
-------------
@@ -337,7 +337,7 @@
                 updates.commitEvent();
 
                 // fire the changes to ListSelectionListeners
-                if(minSelectionIndexBefore != 0 && maxSelectionIndexBefore != 0) {
+                if(minSelectionIndexBefore != -1 && maxSelectionIndexBefore != -1) {
                     int minSelectionIndexAfter = getMinSelectionIndex();
                     int maxSelectionIndexAfter = getMaxSelectionIndex();
                     int changeStart = minSelectionIndexBefore;
---------------
-------------
@@ -79,6 +79,7 @@
         // open a channel and bind
         ServerSocketChannel serverChannel = ServerSocketChannel.open();
         ServerSocket serverSocket = serverChannel.socket();
+        serverSocket.setReuseAddress(false); // fix for Apple JVM bug 3922515
         InetSocketAddress listenAddress = new InetSocketAddress(listenPort);
         serverSocket.bind(listenAddress);
         
---------------
-------------
@@ -408,6 +408,7 @@
         checkFilterList = null;
         tableHandler = null;
         selection = null;
+        source = null;
     }
 
     /**
---------------
-------------
@@ -134,7 +134,7 @@
      * where some member lists are DebugLists and thus must share an identical
      * publisher and locks in order to participate in the CompositeList.
      */
-    public DebugList<E> createNewDebugList() {
+    public <E> DebugList<E> createNewDebugList() {
         return new DebugList<E>(getPublisher(), debugReadWriteLock);
     }
 
---------------
-------------
@@ -51,7 +51,6 @@
 import org.opennms.netmgt.model.OnmsAlarmCollection;
 import org.opennms.netmgt.model.alarm.AlarmSummaryCollection;
 import org.opennms.web.api.Authentication;
-import org.opennms.netmgt.model.alarm.AlarmSummaryCollection;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.context.annotation.Scope;
 import org.springframework.stereotype.Component;
---------------
-------------
@@ -36,6 +36,8 @@
 import org.opennms.netmgt.provision.support.AsyncClientConversation.ResponseValidator;
 import org.opennms.netmgt.provision.support.codec.HttpProtocolCodecFactory;
 
+@Component
+@Scope("prototype")
 public class HttpDetector extends AsyncBasicDetector<LineOrientedRequest, HttpStatusResponse> {
     
     private static String DEFAULT_URL="/";
---------------
-------------
@@ -62,7 +62,7 @@
      * This recursively substitutes occurrences ${property.name} in initialString with the value of 
      * the property property.name taken from the supplied properties object. If 
      * property.name is not defined in properties that the substitution is not done. 
-     * @param initialString the string to preform the substitions in
+     * @param initialString the string to perform the substitutions in
      * @param properties the properties to take the values from
      * @return The string with appropriate substitutions made.
      */
---------------
-------------
@@ -54,7 +54,6 @@
  */
 public class DefaultAckService implements AckService {
     
-    //@Autowired
     private AcknowledgmentDao m_ackDao;
     
     public void processAcks(Collection<OnmsAcknowledgment> acks) {
---------------
-------------
@@ -108,6 +108,7 @@
         getServletContext().addInitParameter("contextConfigLocation", 
                 "classpath:/org/opennms/web/rest/applicationContext-test.xml " +
                 "classpath:/META-INF/opennms/applicationContext-commonConfigs.xml " +
+                "classpath:/META-INF/opennms/applicationContext-soa.xml " +
                 "classpath*:/META-INF/opennms/component-service.xml " +
                 "classpath*:/META-INF/opennms/component-dao.xml " +
                 "classpath:/META-INF/opennms/applicationContext-reportingCore.xml " +
---------------
-------------
@@ -51,7 +51,7 @@
     protected XMLGregorianCalendar m_dateStamp;
     
     @XmlAttribute(name="foreign-source")
-    protected String m_foreignSource;
+    protected String m_foreignSource = "imported:";
     
     @XmlAttribute(name="last-import")
     protected XMLGregorianCalendar m_lastImport;
---------------
-------------
@@ -115,6 +115,7 @@
             LOG.info("Loading the configuration file.");
             VacuumdConfigFactory.init();
             getEventManager().addEventListener(this, EventConstants.RELOAD_VACUUMD_CONFIG_UEI);
+            getEventManager().addEventListener(this, EventConstants.RELOAD_DAEMON_CONFIG_UEI);
 
             initializeDataSources();
         } catch (Throwable ex) {
---------------
-------------
@@ -68,7 +68,7 @@
  */
 public class CastorUtils {
     private static final CastorExceptionTranslator CASTOR_EXCEPTION_TRANSLATOR = new CastorExceptionTranslator();
-    private static final boolean PRESERVE_WHITESPACE = false;
+    public static final boolean PRESERVE_WHITESPACE = false;
 
     /** Private constructor since this class only has static methods (so far). */
     private CastorUtils() {
---------------
-------------
@@ -157,6 +157,7 @@
      */
     public void startServer() throws Exception {
         setServerThread(new Thread(getRunnable(), this.getClass().getSimpleName()));
+        getServerThread().setDaemon(true);
         getServerThread().start();
     }
     
---------------
-------------
@@ -137,6 +137,7 @@
 			log().debug("Retrieved ticket state : " + otrsToOpenNMSState(ticketWithArticles.getTicket().getStateID()));
 			
 			// add all the article details from the OTRS ticket
+			// this is not strictly essential as we have no way of viewing this atm.
 			
 			String opennmsTicketDetails = "";
 
---------------
-------------
@@ -207,6 +207,7 @@
             m_socket = new Socket();
             m_socket.setTcpNoDelay(true);
             m_socket.connect(new InetSocketAddress(getAddress(), getPort()), getTimeout());
+            m_socket.setSoTimeout(getTimeout());
             
             m_reader = new BufferedReader(new InputStreamReader(m_socket.getInputStream()));
             m_writer = m_socket.getOutputStream();
---------------
-------------
@@ -36,6 +36,8 @@
 import org.opennms.netmgt.provision.support.AsyncClientConversation.ResponseValidator;
 import org.opennms.netmgt.provision.support.codec.HttpProtocolCodecFactory;
 
+@Component
+@Scope("prototype")
 public class HttpDetector extends AsyncBasicDetector<LineOrientedRequest, HttpStatusResponse> {
     
     private static String DEFAULT_URL="/";
---------------
-------------
@@ -51,7 +51,7 @@
     protected XMLGregorianCalendar m_dateStamp;
     
     @XmlAttribute(name="foreign-source")
-    protected String m_foreignSource;
+    protected String m_foreignSource = "imported:";
     
     @XmlAttribute(name="last-import")
     protected XMLGregorianCalendar m_lastImport;
---------------
-------------
@@ -634,7 +634,6 @@
             }
             regex.appendTail(tempStringBuff);
             sqlRule = tempStringBuff.toString();
-            System.err.println("sqlRule = " + sqlRule);
             return "WHERE " + sqlRule;
         }
         return "";
---------------
-------------
@@ -224,7 +224,7 @@
     
     
     public OnmsIpInterface updateIpInterfaceAttributes(Integer nodeId, OnmsIpInterface scannedIface) {
-        if (scannedIface.getSnmpInterface() != null) {
+        if (scannedIface.getSnmpInterface() != null && scannedIface.getSnmpInterface().getIfIndex() != null) {
             scannedIface.setSnmpInterface(updateSnmpInterfaceAttributes(nodeId, scannedIface.getSnmpInterface()));
         }
         
---------------
-------------
@@ -255,7 +255,7 @@
                     return false;
                 }
             } else {
-                log().warn("passedThresholdFilters: can't find value of " + attr + " for resource " + resource);
+                log().warn("passedThresholdFilters: can't find value of " + f.getField() + " for resource " + resource);
             }
         }
         return false;
---------------
-------------
@@ -137,6 +137,7 @@
 			log().debug("Retrieved ticket state : " + otrsToOpenNMSState(ticketWithArticles.getTicket().getStateID()));
 			
 			// add all the article details from the OTRS ticket
+			// this is not strictly essential as we have no way of viewing this atm.
 			
 			String opennmsTicketDetails = "";
 
---------------
-------------
@@ -51,7 +51,6 @@
 import org.opennms.netmgt.model.OnmsAlarmCollection;
 import org.opennms.netmgt.model.alarm.AlarmSummaryCollection;
 import org.opennms.web.api.Authentication;
-import org.opennms.netmgt.model.alarm.AlarmSummaryCollection;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.context.annotation.Scope;
 import org.springframework.stereotype.Component;
---------------
-------------
@@ -54,7 +54,6 @@
  */
 public class DefaultAckService implements AckService {
     
-    //@Autowired
     private AcknowledgmentDao m_ackDao;
     
     public void processAcks(Collection<OnmsAcknowledgment> acks) {
---------------
-------------
@@ -302,7 +302,7 @@
                     sb.append(" LINE1:var#0000ff:\"").append(v.getId()).append("\" \\\n");
                     sb.append(" GPRINT:var:AVERAGE:\"Avg\\\\: %8.2lf %s\" \\\n");
                     sb.append(" GPRINT:var:MIN:\"Min\\\\: %8.2lf %s\" \\\n");
-                    sb.append(" GPRINT:var:MAX:\"Max\\\\: %8.2lf %s\\n\"");
+                    sb.append(" GPRINT:var:MAX:\"Max\\\\: %8.2lf %s\\\\n\"");
                     sb.append("\n\n");
                     PrefabGraph graph = new PrefabGraph(name, descr, new String[] { alias }, sb.toString(), new String[0], new String[0], order++, new String[] { resourceType }, descr, null, null, new String[0]);
                     graphs.add(graph);
---------------
-------------
@@ -207,6 +207,7 @@
             m_socket = new Socket();
             m_socket.setTcpNoDelay(true);
             m_socket.connect(new InetSocketAddress(getAddress(), getPort()), getTimeout());
+            m_socket.setSoTimeout(getTimeout());
             
             m_reader = new BufferedReader(new InputStreamReader(m_socket.getInputStream()));
             m_writer = m_socket.getOutputStream();
---------------
-------------
@@ -138,6 +138,7 @@
     @Test
     public void submenuAlphabeticalOrderTest() {
         CommandManager cmdManager = new CommandManager();
+        cmdManager.addOrUpdateGroupOrder("File", Arrays.asList("new", "additions"));
         cmdManager.onBind(getTestOperation(), getProps("File", "Operation1?group=new", ""));
         cmdManager.onBind(getTestOperation(), getProps("File", "Operation3", ""));
         cmdManager.onBind(getTestOperation(), getProps("File", "Operation4", ""));
---------------
-------------
@@ -634,7 +634,6 @@
             }
             regex.appendTail(tempStringBuff);
             sqlRule = tempStringBuff.toString();
-            System.err.println("sqlRule = " + sqlRule);
             return "WHERE " + sqlRule;
         }
         return "";
---------------
-------------
@@ -266,7 +266,7 @@
 
         // Only consider alarms that are above severity NORMAL
         // {@see org.opennms.netmgt.model.OnmsSeverity}
-        criteria.add(Restrictions.gt("severityId", 3));
+        criteria.add(Restrictions.gt("severity", OnmsSeverity.NORMAL));
 
         // TODO Figure out how to query by parameters (maybe necessary)
 
---------------
-------------
@@ -36,6 +36,8 @@
 import org.opennms.netmgt.provision.support.AsyncClientConversation.ResponseValidator;
 import org.opennms.netmgt.provision.support.codec.HttpProtocolCodecFactory;
 
+@Component
+@Scope("prototype")
 public class HttpDetector extends AsyncBasicDetector<LineOrientedRequest, HttpStatusResponse> {
     
     private static String DEFAULT_URL="/";
---------------
-------------
@@ -255,7 +255,7 @@
                     return false;
                 }
             } else {
-                log().warn("passedThresholdFilters: can't find value of " + attr + " for resource " + resource);
+                log().warn("passedThresholdFilters: can't find value of " + f.getField() + " for resource " + resource);
             }
         }
         return false;
---------------
-------------
@@ -23,7 +23,7 @@
         selenium.type("name=j_password", "admin");
         selenium.click("name=Login");
         selenium.waitForPageToLoad("30000");
-        selenium.click("link=admin");
+        selenium.click("link=Admin");
         selenium.waitForPageToLoad("30000");
     }
 
---------------
-------------
@@ -54,7 +54,7 @@
 	List m_earlyArrival = new ArrayList();
 	List m_lateBloomers = new ArrayList();
 
-	long m_expectedDiff = 1000;;
+	long m_expectedDiff = 1000;
 
 	/**
 	 */
---------------
-------------
@@ -137,7 +137,7 @@
             "GROUP BY node.id, node.label " +
             "ORDER BY max(outage.ifLostService) DESC, node.label ASC, node.id ASC"
         );
-        if (rows == 0) {
+        if (rows == 0 || outages.size() < rows) {
             return outages;
         } else {
             return outages.subList(0, rows);
---------------
-------------
@@ -207,6 +207,7 @@
             m_socket = new Socket();
             m_socket.setTcpNoDelay(true);
             m_socket.connect(new InetSocketAddress(getAddress(), getPort()), getTimeout());
+            m_socket.setSoTimeout(getTimeout());
             
             m_reader = new BufferedReader(new InputStreamReader(m_socket.getInputStream()));
             m_writer = m_socket.getOutputStream();
---------------
-------------
@@ -60,8 +60,6 @@
 
     public void afterPropertiesSet() throws Exception {
         Assert.notNull(m_configResource, "The configurationDir property must be set");
-        // ensure that this is a file resource since we need to save to it
-        m_configResource.getFile();
         
         if (m_configResource.exists()) {
             m_settings = PropertiesLoaderUtils.loadProperties(m_configResource);
---------------
-------------
@@ -54,7 +54,6 @@
  */
 public class DefaultAckService implements AckService {
     
-    //@Autowired
     private AcknowledgmentDao m_ackDao;
     
     public void processAcks(Collection<OnmsAcknowledgment> acks) {
---------------
-------------
@@ -148,6 +148,7 @@
         event.createTime = onmsEvent.getEventCreateTime();
         event.description = onmsEvent.getEventDescr();
         event.dpName = onmsEvent.getDistPoller() != null ? onmsEvent.getDistPoller().getName() : "";
+        event.eventDisplay = Boolean.valueOf(onmsEvent.getEventDisplay().equals("Y"));
         event.forward = onmsEvent.getEventForward();
         event.host = onmsEvent.getEventHost();
         event.id = onmsEvent.getId();
---------------
-------------
@@ -137,6 +137,7 @@
 			log().debug("Retrieved ticket state : " + otrsToOpenNMSState(ticketWithArticles.getTicket().getStateID()));
 			
 			// add all the article details from the OTRS ticket
+			// this is not strictly essential as we have no way of viewing this atm.
 			
 			String opennmsTicketDetails = "";
 
---------------
-------------
@@ -62,7 +62,7 @@
      * This recursively substitutes occurrences ${property.name} in initialString with the value of 
      * the property property.name taken from the supplied properties object. If 
      * property.name is not defined in properties that the substitution is not done. 
-     * @param initialString the string to preform the substitions in
+     * @param initialString the string to perform the substitutions in
      * @param properties the properties to take the values from
      * @return The string with appropriate substitutions made.
      */
---------------
-------------
@@ -115,6 +115,7 @@
                 "classpath:/org/opennms/web/rest/applicationContext-mockEventProxy.xml " +
                 "classpath:/applicationContext-jersey-test.xml " +
                 "classpath:/META-INF/opennms/applicationContext-reporting.xml " +
+                "classpath:/META-INF/opennms/applicationContext-mock-usergroup.xml " +
                 "classpath:/META-INF/opennms/applicationContext-minimal-conf.xml " +
                 "/WEB-INF/applicationContext-spring-security.xml " +
                 "/WEB-INF/applicationContext-jersey.xml");
---------------
-------------
@@ -62,7 +62,7 @@
      * This recursively substitutes occurrences ${property.name} in initialString with the value of 
      * the property property.name taken from the supplied properties object. If 
      * property.name is not defined in properties that the substitution is not done. 
-     * @param initialString the string to preform the substitions in
+     * @param initialString the string to perform the substitutions in
      * @param properties the properties to take the values from
      * @return The string with appropriate substitutions made.
      */
---------------
-------------
@@ -100,7 +100,7 @@
             throw new IllegalArgumentException("maxVarsPerPdu < 1");
         }
 
-        pduBuilder.addOid(m_ids[m_nextColumnIndex]);
+        pduBuilder.addOid(m_lastOid[m_nextColumnIndex]);
         pduBuilder.setNonRepeaters(0);
         pduBuilder.setMaxRepetitions(getMaxRepetitions());
         
---------------
-------------
@@ -269,7 +269,7 @@
         String addedNode = setTreeFieldsAndSave("nodeEditForm", text("nodeLabel", nodeLabel));
 
         // add an interface
-        clickElementByXPath("//a[contains(@href, '" + addedNode + "') and text() = '[Add Interface]']");
+        clickElementByXPath("//a[contains(@href, '" + addedNode + "') and text() = '[Add Interface for Scanning]']");
 
         // set the ipAddr to ::1 and set snmpPrimary to 'P' and save
         setTreeFieldsAndSave("nodeEditForm", text("ipAddr", "::1"), option("snmpPrimary", "P"));
---------------
-------------
@@ -60,8 +60,6 @@
 
     public void afterPropertiesSet() throws Exception {
         Assert.notNull(m_configResource, "The configurationDir property must be set");
-        // ensure that this is a file resource since we need to save to it
-        m_configResource.getFile();
         
         if (m_configResource.exists()) {
             m_settings = PropertiesLoaderUtils.loadProperties(m_configResource);
---------------
-------------
@@ -163,7 +163,7 @@
      */
     public static InetAddress getInetAddress(final String dottedNotation) {
         try {
-            return InetAddress.getByName(dottedNotation);
+            return dottedNotation == null? null : InetAddress.getByName(dottedNotation);
         } catch (final UnknownHostException e) {
             throw new IllegalArgumentException("Invalid IPAddress " + dottedNotation);
         }
---------------
-------------
@@ -63,7 +63,7 @@
         
         m_pollCount++;
         if (m_pollCount % m_repetitions == 0) {
-        	m_currentStatus = (m_currentStatus.isDown() ? PollStatus.up(100+m_pollCount) : PollStatus.down("pollCount is "+m_pollCount));
+        	m_currentStatus = (m_currentStatus.isDown() ? PollStatus.up(100.0+m_pollCount) : PollStatus.down("pollCount is "+m_pollCount));
         }
         
         return status;
---------------
-------------
@@ -100,7 +100,7 @@
             throw new IllegalArgumentException("maxVarsPerPdu < 1");
         }
 
-        pduBuilder.addOid(m_ids[m_nextColumnIndex]);
+        pduBuilder.addOid(m_lastOid[m_nextColumnIndex]);
         pduBuilder.setNonRepeaters(0);
         pduBuilder.setMaxRepetitions(getMaxRepetitions());
         
---------------
-------------
@@ -51,7 +51,7 @@
     protected XMLGregorianCalendar m_dateStamp;
     
     @XmlAttribute(name="foreign-source")
-    protected String m_foreignSource;
+    protected String m_foreignSource = "imported:";
     
     @XmlAttribute(name="last-import")
     protected XMLGregorianCalendar m_lastImport;
---------------
-------------
@@ -244,7 +244,7 @@
         RequisitionNode node = m_accessService.getNode(foreignSource, foreignId);
         
         if (node == null) {
-            throw getException(Response.Status.NOT_FOUND, "Foreign source '" + foreignSource + "' not found.");
+            throw getException(Response.Status.NOT_FOUND, "Node with Foreign ID '" + foreignId +"' and Foreign source '" + foreignSource + "' not found.");
         }
         return node;
         
---------------
-------------
@@ -63,7 +63,7 @@
         
         m_pollCount++;
         if (m_pollCount % m_repetitions == 0) {
-        	m_currentStatus = (m_currentStatus.isDown() ? PollStatus.up(100+m_pollCount) : PollStatus.down("pollCount is "+m_pollCount));
+        	m_currentStatus = (m_currentStatus.isDown() ? PollStatus.up(100.0+m_pollCount) : PollStatus.down("pollCount is "+m_pollCount));
         }
         
         return status;
---------------
-------------
@@ -634,7 +634,6 @@
             }
             regex.appendTail(tempStringBuff);
             sqlRule = tempStringBuff.toString();
-            System.err.println("sqlRule = " + sqlRule);
             return "WHERE " + sqlRule;
         }
         return "";
---------------
-------------
@@ -63,7 +63,7 @@
         
         m_pollCount++;
         if (m_pollCount % m_repetitions == 0) {
-        	m_currentStatus = (m_currentStatus.isDown() ? PollStatus.up(100+m_pollCount) : PollStatus.down("pollCount is "+m_pollCount));
+        	m_currentStatus = (m_currentStatus.isDown() ? PollStatus.up(100.0+m_pollCount) : PollStatus.down("pollCount is "+m_pollCount));
         }
         
         return status;
---------------
-------------
@@ -100,7 +100,7 @@
             throw new IllegalArgumentException("maxVarsPerPdu < 1");
         }
 
-        pduBuilder.addOid(m_ids[m_nextColumnIndex]);
+        pduBuilder.addOid(m_lastOid[m_nextColumnIndex]);
         pduBuilder.setNonRepeaters(0);
         pduBuilder.setMaxRepetitions(getMaxRepetitions());
         
---------------
-------------
@@ -255,7 +255,7 @@
                     return false;
                 }
             } else {
-                log().warn("passedThresholdFilters: can't find value of " + attr + " for resource " + resource);
+                log().warn("passedThresholdFilters: can't find value of " + f.getField() + " for resource " + resource);
             }
         }
         return false;
---------------
-------------
@@ -106,7 +106,8 @@
         size--;
         int pos2 = pos;
         // now work back up the chain from pos to pos0;
-        while (pos >= pos0) {
+        // Note: because of the mask, the pos can be actually less than pos0, thus using != operator instead of >=
+        while (pos != pos0) {
             pos = (pos - ENTRY_SIZE) & capacityMask2;
             int key2 = bytes.readInt(pos + KEY);
             if (key2 == key) {
---------------
-------------
@@ -231,7 +231,7 @@
                     bytes.storePositionAndSize(store, pos * smallEntrySize, smallEntrySize);
                     K key2 = getKey();
                     if (equals(key, key2)) {
-                        if (ifAbsent)
+                        if (ifAbsent && !ifPresent)
                             return;
                         foundSmall = true;
                         break;
---------------
-------------
@@ -412,7 +412,7 @@
             if (csKey) {
                 sbKey.setLength(0);
                 bytes.readUTFΔ(sbKey);
-                return (K) sbKey;
+                return (K) sbKey.toString();
             }
             return (K) bytes.readObject();
         }
---------------
-------------
@@ -106,7 +106,8 @@
         size--;
         int pos2 = pos;
         // now work back up the chain from pos to pos0;
-        while (pos >= pos0) {
+        // Note: because of the mask, the pos can be actually less than pos0, thus using != operator instead of >=
+        while (pos != pos0) {
             pos = (pos - ENTRY_SIZE) & capacityMask2;
             int key2 = bytes.readInt(pos + KEY);
             if (key2 == key) {
---------------
-------------
@@ -31,7 +31,7 @@
 		this.parentEl = parentEl;
 		this.name = name;
 		
-		Element child = (Element) DOMUtil.getFirstChildByTagNameNS(this.parentEl, NamespaceConstants.XFORMS_NS, this.name);
+		Element child = (Element) DOMUtil.findFirstChildNS(this.parentEl, NamespaceConstants.XFORMS_NS, this.name);
 		if (child != null) {
 			valueChild = new ValueChild(child, model);
 			attrValue = null;
---------------
-------------
@@ -221,7 +221,7 @@
 
     public URI getXsltURI(String xsltPath, String xsltDefault) throws URISyntaxException {
         String resolvePath = getRealPath(xsltPath + xsltDefault, servletContext);
-        String pathToXSLDirectory = resolvePath.substring(0, resolvePath.lastIndexOf("/"));
+        String pathToXSLDirectory = resolvePath.substring(0, resolvePath.lastIndexOf(File.separator));
         return new File(pathToXSLDirectory).toURI().resolve(new URI(xsltDefault));
     }
 
---------------
-------------
@@ -814,7 +814,7 @@
             for (int index = 0; index < count; index++) {
                 Element xformsInstance = instanceElements.get(index);
                 createInstanceObject(xformsInstance);
-                if(Config.getInstance().getProperty("betterform.debug-allowed").equals("true")){
+                if(isReady() && Config.getInstance().getProperty("betterform.debug-allowed").equals("true")){
                     Map contextInfo = new HashMap(1);
                     contextInfo.put("modelId",XFormsElement.getXFormsAttribute((Element) xformsInstance.getParentNode(),"id"));
                     contextInfo.put("instanceId",XFormsElement.getXFormsAttribute(xformsInstance,"id"));
---------------
-------------
@@ -93,6 +93,6 @@
     public Set<MessageOutput> getMessageOutputs() {
         Set<MessageOutput> runningOutputs = new HashSet<>(this.runningMessageOutputs.values());
         runningOutputs.add(defaultMessageOutput);
-        return ImmutableSet.copyOf(this.runningMessageOutputs.values());
+        return ImmutableSet.copyOf(runningOutputs);
     }
 }
---------------
-------------
@@ -47,7 +47,7 @@
 
     public static byte[] gzipCompress(String what) throws IOException {
         // GZIP compress message.
-        ByteArrayInputStream compressMe = new ByteArrayInputStream(what.getBytes());
+        ByteArrayInputStream compressMe = new ByteArrayInputStream(what.getBytes("UTF-8"));
         ByteArrayOutputStream compressedMessage = new ByteArrayOutputStream();
         GZIPOutputStream out = new GZIPOutputStream(compressedMessage);
         for (int c = compressMe.read(); c != -1; c = compressMe.read()) {
---------------
-------------
@@ -61,7 +61,7 @@
     public static final String FIELD_TIMESTAMP = "timestamp";
     public static final String FIELD_STREAMS = "streams";
 
-    private static final Pattern VALID_KEY_CHARS = Pattern.compile("^[\\w\\.\\-]*$");
+    private static final Pattern VALID_KEY_CHARS = Pattern.compile("^[\\w\\.\\-@]*$");
 
     public static final ImmutableSet<String> RESERVED_FIELDS = ImmutableSet.of(
             // ElasticSearch fields.
---------------
-------------
@@ -155,7 +155,7 @@
         }
 
         // Remove original from message?
-        if (cursorStrategy.equals(CursorStrategy.CUT) && !targetField.equals(sourceField)) {
+        if (cursorStrategy.equals(CursorStrategy.CUT) && !targetField.equals(sourceField) && !Message.RESERVED_FIELDS.contains(sourceField)) {
             StringBuilder sb = new StringBuilder(field);
 
             sb.delete(result.getBeginIndex(), result.getEndIndex());
---------------
-------------
@@ -67,7 +67,7 @@
     // Pattern for parsing lat,lng strings.
     private static final String _doublePattern = "-{0,1}\\d+(\\.\\d+){0,1}";
 
-    private static final Pattern _latLonPattern = Pattern.compile("\\D*(" + _doublePattern
+    private static final Pattern _latLonPattern = Pattern.compile("[^[\\d&&[-|+|.]]]*(" + _doublePattern
             + ")(\\s*,\\s*|\\s+)(" + _doublePattern + ")\\D*");
     
     private static final Pattern _headingPattern = Pattern.compile("\\D*heading=("
---------------
-------------
@@ -67,7 +67,7 @@
     // Pattern for parsing lat,lng strings.
     private static final String _doublePattern = "-{0,1}\\d+(\\.\\d+){0,1}";
 
-    private static final Pattern _latLonPattern = Pattern.compile("\\D*(" + _doublePattern
+    private static final Pattern _latLonPattern = Pattern.compile("[^[\\d&&[-|+|.]]]*(" + _doublePattern
             + ")(\\s*,\\s*|\\s+)(" + _doublePattern + ")\\D*");
     
     private static final Pattern _headingPattern = Pattern.compile("\\D*heading=("
---------------
-------------
@@ -161,8 +161,6 @@
 	/**
 	 * Construct from a Coordinate. 
 	 * 
-	 * Deprecated.
-	 * 
 	 * @param e
 	 * @param p
 	 * @param pref
---------------
-------------
@@ -27,7 +27,7 @@
     private BigDecimal big = BigDecimal.ONE;
 
     @Convert
-    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd.MM.yyyy", timezone = "CET")
+    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd.MM.yyyy", timezone = "EET")
     private Date date2;
 
     public SamplePojo() {
---------------
-------------
@@ -32,6 +32,7 @@
                 list.add(item);
             }
         };
+        importStream(inputStream, handler);
         return list;
     }
 
---------------
-------------
@@ -1863,7 +1863,7 @@
     public ProposalDevelopmentDocument getProposalDocument() {
         if (proposalDocument == null) {
             proposalDocument = new ProposalDevelopmentDocument();
-        } else if (proposalDocument.getDocumentHeader() != null && !proposalDocument.getDocumentHeader().hasWorkflowDocument()) {
+        } else if (proposalDocument.getDocumentHeader() != null && proposalDocument.getDocumentNumber() != null && !proposalDocument.getDocumentHeader().hasWorkflowDocument()) {
             proposalDocument.getDocumentHeader().setWorkflowDocument(WorkflowDocumentFactory.loadDocument(GlobalVariables.getUserSession().getPrincipalId(), proposalDocument.getDocumentNumber()));
         }
 
---------------
-------------
@@ -62,7 +62,7 @@
         persistableBusinessObjectValuesFinder.setKeyAttributeName(getKeyAttributeName());
         persistableBusinessObjectValuesFinder.setLabelAttributeName(getLabelAttributeName());
         persistableBusinessObjectValuesFinder.getKeyValues();
-        assertEquals(testKeyValues.size(), persistableBusinessObjectValuesFinder.getKeyValues().size());
+        assertEquals("expected:\n" + testKeyValues + "\nactual:\n" + persistableBusinessObjectValuesFinder.getKeyValues(), testKeyValues.size(), persistableBusinessObjectValuesFinder.getKeyValues().size());
         for (int i=0; i<testKeyValues.size(); i++) {
             assertEquals(testKeyValues.get(i).getValue(), persistableBusinessObjectValuesFinder.getKeyLabel(testKeyValues.get(i).getKey().toString()));
         }
---------------
-------------
@@ -610,6 +610,6 @@
 
     @Override
     public void afterPropertiesSet() throws Exception {
-        formMappingService.registerForm(new FormMappingInfo(getNamespace(), getGeneratorName(), getFormName(), getStylesheet().getURL().getPath(), getSortIndex(), false));
+        formMappingService.registerForm(new FormMappingInfo(getNamespace(), getGeneratorName(), getFormName(), getStylesheet().getURL().toString(), getSortIndex(), false));
     }
 }
---------------
-------------
@@ -29,7 +29,7 @@
 public enum ProposalPersonFixture {
     INVESTIGATOR_SPLIT_ADDS_TO_ONE_HUNDRED("000000003", PRINCIPAL_INVESTIGATOR_ROLE),
     PHILIP_CO_INVESTIGATOR("000000002", CO_INVESTIGATOR_ROLE),
-    BRYAN_CO_INVESTIGATOR("000000006", CO_INVESTIGATOR_ROLE),
+    BRYAN_CO_INVESTIGATOR("000000005", CO_INVESTIGATOR_ROLE),
     ANDY_KEY_PERSON("000000006", KEY_PERSON_ROLE);
 
     private ProposalPerson person;
---------------
-------------
@@ -29,7 +29,7 @@
 public enum ProposalPersonFixture {
     INVESTIGATOR_SPLIT_ADDS_TO_ONE_HUNDRED("000000003", PRINCIPAL_INVESTIGATOR_ROLE),
     PHILIP_CO_INVESTIGATOR("000000002", CO_INVESTIGATOR_ROLE),
-    BRYAN_CO_INVESTIGATOR("000000006", CO_INVESTIGATOR_ROLE),
+    BRYAN_CO_INVESTIGATOR("000000005", CO_INVESTIGATOR_ROLE),
     ANDY_KEY_PERSON("000000006", KEY_PERSON_ROLE);
 
     private ProposalPerson person;
---------------
-------------
@@ -139,7 +139,7 @@
             
         // The user cannot delete the last Aggregator on a proposal.
             
-        else if (!hasAggregator(editRoles) && isLastAggregator(username, proposalUserRolesList)) {
+        else if (hasAggregator(editRoles) && isLastAggregator(username, proposalUserRolesList)) {
             isValid = false;
             getGlobalVariableService().getMessageMap().putErrorForSectionId(Constants.PERMISSION_PROPOSAL_USERS_COLLECTION_ID_KEY, KeyConstants.ERROR_LAST_AGGREGATOR);
         }
---------------
-------------
@@ -1863,7 +1863,7 @@
     public ProposalDevelopmentDocument getProposalDocument() {
         if (proposalDocument == null) {
             proposalDocument = new ProposalDevelopmentDocument();
-        } else if (proposalDocument.getDocumentHeader() != null && !proposalDocument.getDocumentHeader().hasWorkflowDocument()) {
+        } else if (proposalDocument.getDocumentHeader() != null && proposalDocument.getDocumentNumber() != null && !proposalDocument.getDocumentHeader().hasWorkflowDocument()) {
             proposalDocument.getDocumentHeader().setWorkflowDocument(WorkflowDocumentFactory.loadDocument(GlobalVariables.getUserSession().getPrincipalId(), proposalDocument.getDocumentNumber()));
         }
 
---------------
-------------
@@ -62,7 +62,7 @@
         persistableBusinessObjectValuesFinder.setKeyAttributeName(getKeyAttributeName());
         persistableBusinessObjectValuesFinder.setLabelAttributeName(getLabelAttributeName());
         persistableBusinessObjectValuesFinder.getKeyValues();
-        assertEquals(testKeyValues.size(), persistableBusinessObjectValuesFinder.getKeyValues().size());
+        assertEquals("expected:\n" + testKeyValues + "\nactual:\n" + persistableBusinessObjectValuesFinder.getKeyValues(), testKeyValues.size(), persistableBusinessObjectValuesFinder.getKeyValues().size());
         for (int i=0; i<testKeyValues.size(); i++) {
             assertEquals(testKeyValues.get(i).getValue(), persistableBusinessObjectValuesFinder.getKeyLabel(testKeyValues.get(i).getKey().toString()));
         }
---------------
-------------
@@ -33,7 +33,7 @@
         return reviewerTypeCode;
     }
 
-    public void setreviewerTypeCode(String reviewerTypeCode) {
+    public void setReviewerTypeCode(String reviewerTypeCode) {
         this.reviewerTypeCode = reviewerTypeCode;
     }
 
---------------
-------------
@@ -33,7 +33,7 @@
         return reviewerTypeCode;
     }
 
-    public void setreviewerTypeCode(String reviewerTypeCode) {
+    public void setReviewerTypeCode(String reviewerTypeCode) {
         this.reviewerTypeCode = reviewerTypeCode;
     }
 
---------------
-------------
@@ -97,6 +97,8 @@
                 ,@UnitTestFile(filename = "classpath:sql/dml/load_ynq_explanation_type.sql", delimiter = ";")
                 ,@UnitTestFile(filename = "classpath:sql/dml/load_ynq.sql", delimiter = ";")
                 ,@UnitTestFile(filename = "classpath:sql/dml/LOAD_RATE_CLASS_TYPE.SQL", delimiter = ";")
+                ,@UnitTestFile(filename = "classpath:sql/dml/load_s2s_submission_type.sql", delimiter = ";")
+                ,@UnitTestFile(filename = "classpath:sql/dml/load_s2s_revision_type.sql", delimiter = ";")
             }
         )
     )
---------------
-------------
@@ -97,6 +97,8 @@
                 ,@UnitTestFile(filename = "classpath:sql/dml/load_ynq_explanation_type.sql", delimiter = ";")
                 ,@UnitTestFile(filename = "classpath:sql/dml/load_ynq.sql", delimiter = ";")
                 ,@UnitTestFile(filename = "classpath:sql/dml/LOAD_RATE_CLASS_TYPE.SQL", delimiter = ";")
+                ,@UnitTestFile(filename = "classpath:sql/dml/load_s2s_submission_type.sql", delimiter = ";")
+                ,@UnitTestFile(filename = "classpath:sql/dml/load_s2s_revision_type.sql", delimiter = ";")
             }
         )
     )
---------------
-------------
@@ -303,6 +303,7 @@
             }
             else if (rolodexId != null && proposalPersonBiography.getRolodexId() != null
                     && proposalPersonBiography.getRolodexId().toString().equals(rolodexId.toString())
+                    && proposalPersonBiography.getPropPerDocType() != null
                     && documentType.equals(proposalPersonBiography.getPropPerDocType().getCode())) {
                 personBiographyFound = true;
             }
---------------
-------------
@@ -303,6 +303,7 @@
             }
             else if (rolodexId != null && proposalPersonBiography.getRolodexId() != null
                     && proposalPersonBiography.getRolodexId().toString().equals(rolodexId.toString())
+                    && proposalPersonBiography.getPropPerDocType() != null
                     && documentType.equals(proposalPersonBiography.getPropPerDocType().getCode())) {
                 personBiographyFound = true;
             }
---------------
-------------
@@ -871,7 +871,7 @@
 		List<Host> hostsByHostname = getFacilitiesManagerBl().getHostsByHostname(sess, hostname);
 
 		//need to remove those hosts, which are not from facilities of this facility admin
-		if(AuthzResolver.isAuthorized(sess, Role.FACILITYADMIN)) {
+		if(!AuthzResolver.hasRole(sess.getPerunPrincipal(), Role.PERUNADMIN) && AuthzResolver.hasRole(sess.getPerunPrincipal(), Role.FACILITYADMIN)) {
 			//get all complementary facilities for this perunPrincipal
 			List<Facility> authorizedFacilities = new ArrayList<>();
 			List<PerunBean> complementaryObjects =  AuthzResolver.getComplementaryObjectsForRole(sess, Role.FACILITYADMIN);
---------------
-------------
@@ -251,7 +251,7 @@
     try {
       return jdbc.query("select " + UsersManagerImpl.userMappingSelectQuery + " from groups_members join members on members.id=member_id join " +
           "users on members.user_id=users.id where group_id=? order by "+Compatibility.orderByBinary("users.last_name")+", " +
-          Compatibility.orderByBinary("users.first_name")+")", UsersManagerImpl.USER_MAPPER, group.getId());
+          Compatibility.orderByBinary("users.first_name"), UsersManagerImpl.USER_MAPPER, group.getId());
     } catch(RuntimeException ex) {
       throw new InternalErrorException(ex);
     }
---------------
-------------
@@ -523,7 +523,7 @@
 	 * @return value of the property
 	 */
 	public static String getPropertyFromConfiguration(String propertyName) throws InternalErrorException {
-		log.trace("Entering getPropertyFromConfiguration: propertyName='" +  propertyName + "'");
+		log.trace("Entering getPropertyFromConfiguration: propertyName='" + propertyName + "'");
 		notNull(propertyName, "propertyName");
 
 		if(BeansUtils.properties == null) {
---------------
-------------
@@ -5182,6 +5182,8 @@
 	}
 
 	public Attribute convertEmptyStringIntoNullInAttrValue(PerunSession sess, Attribute attributeToConverting) {
+		//if attributeToConverting has already null value, return it
+		if(attributeToConverting.getValue() == null) return attributeToConverting;
 		String testAttributeType = attributeToConverting.getType();
 		if (testAttributeType.equals(String.class.getName()) && attributeToConverting.getValue().equals("")) {
 			attributeToConverting.setValue(null);
---------------
-------------
@@ -66,7 +66,6 @@
                     .xpath("github-repo/text()").get(0)
             )
         );
-        final Coordinates coords = repo.coordinates();
         if (!repo.stars().starred()) {
             repo.stars().star();
         }
---------------
-------------
@@ -92,7 +92,7 @@
         throw this.flash().redirect(
             this.uriInfo().getBaseUriBuilder()
                 .clone()
-                .path(StandRs.class)
+                .path(AclRs.class)
                 .build(name),
             String.format("Stand `%s` successfully created", name),
             Level.INFO
---------------
-------------
@@ -244,9 +244,9 @@
      * Validate rultor config YAML according to schema.
      * @param yml Rultor YAML config
      * @return Validation result message, empty list means validation succeeded.
-     * @todo #561:30min Implement validation using Kwalify library enable
-     *  rejectsEmptyYaml and rejectsYamlWithout(Release/Deploy/Merge) tests and
-     *  remove UnusedFormalParameter suppress below.
+     * @todo #570:30min Implement validation using Kwalify library enable
+     *  tests in GitHubProfileValidationTest and remove UnusedFormalParameter
+     *  suppress below.
      */
     @SuppressWarnings("PMD.UnusedFormalParameter")
     private List<String> validate(final String yml) {
---------------
-------------
@@ -99,7 +99,7 @@
             )
         );
         final String body;
-        if (false /*this.home.hasBody()*/) {
+        if (this.home.hasBody()) {
             body = this.home.body();
         } else {
             body = "";
---------------
-------------
@@ -86,7 +86,7 @@
         final Req req;
         if (comment.body().trim().startsWith(prefix)) {
             req = this.origin.understand(comment, home);
-        } else if (comment.body().trim().contains(prefix)) {
+        } else if (comment.body().contains(prefix)) {
             new Answer(comment).post(
                 String.format(
                     QnReferredTo.PHRASES.getString("QnReferredTo.mentioned"),
---------------
-------------
@@ -172,7 +172,7 @@
             resp = Response.ok().entity(
                 new XSLT(
                     this.render(
-                        new JaxbBundle("container"),
+                        new JaxbBundle("div"),
                         this.stand().pulses().tail(uid).iterator().next()
                     ).element(),
                     this.getClass().getResourceAsStream("fetch.xsl")
---------------
-------------
@@ -160,7 +160,7 @@
         boolean success = false;
         try {
             success ^= snapshot.xml()
-                .nodes(String.format("//tag[label='%s' and level='INFO']", tag))
+                .nodes(String.format("//tag[label='%s' and level='FINE']", tag))
                 .isEmpty();
         } catch (ImpossibleModificationException ex) {
             Logger.warn(this, ExceptionUtils.getRootCauseMessage(ex));
---------------
-------------
@@ -169,6 +169,7 @@
      * Post this JSON to the right stand.
      * @param json JSON to process
      * @throws Stand.BrokenXemblyException If fails
+     * @checkstyle RedundantThrows (4 lines)
      */
     private void post(final String json) throws Stand.BrokenXemblyException {
         final JsonObject object = Json.createReader(
---------------
-------------
@@ -90,7 +90,7 @@
         /**
          * Simple.
          */
-        @Loggable(Loggable.INFO)
+        @Loggable(Loggable.DEBUG)
         @ToString
         @EqualsAndHashCode(of = { "who", "lvl", "msg" })
         @Immutable
---------------
-------------
@@ -66,7 +66,6 @@
     /**
      * Public ctor.
      * @param rpo Repo
-     * @param wrk Work
      * @param appr Appender
      */
     protected LoggedInstance(final Repo rpo, final ConveyerAppender appr) {
---------------
-------------
@@ -165,7 +165,7 @@
                 IOUtils.toInputStream(
                     this.build.info(
                         UriBuilder.fromUri(this.uriInfo().getBaseUri())
-                            .path(this.stand).build()
+                            .segment("s", this.stand).build()
                     )
                 )
             ),
---------------
-------------
@@ -120,6 +120,7 @@
             new Attributes()
                 .with(AwsRule.FIELD_SPEC, spec.asText())
                 .with(AwsRule.FIELD_DRAIN, drain.asText())
+                .with(AwsRule.FIELD_FAILURE, "")
         );
     }
 
---------------
-------------
@@ -137,7 +137,7 @@
         {
             int pos = path.lastIndexOf( REPOSITORY_SEPARATOR );
             parseArtifactPart( path.substring( pos + 1 ) );
-            m_repositoryURL = new RepositoryURL( path.substring( 0, pos ) );
+            m_repositoryURL = new RepositoryURL( path.substring( 0, pos ) + "@snapshots" );
         }
         else
         {
---------------
-------------
@@ -53,7 +53,7 @@
      * Regex pattern for matching instructions when specified in url.
      */
     private static final Pattern INSTRUCTIONS_PATTERN =
-        Pattern.compile( "([a-zA-Z_0-9-]+)=([-!\"'()*+,.0-9A-Z_a-z%]+)" );
+        Pattern.compile( "([a-zA-Z_0-9-]+)=([-!\"'()*+,.0-9A-Z_a-z%;=]+)" );
 
     /**
      * Utility class. Ment to be used using static methods
---------------
-------------
@@ -137,7 +137,7 @@
         {
             int pos = path.lastIndexOf( REPOSITORY_SEPARATOR );
             parseArtifactPart( path.substring( pos + 1 ) );
-            m_repositoryURL = new RepositoryURL( path.substring( 0, pos ) );
+            m_repositoryURL = new RepositoryURL( path.substring( 0, pos ) + "@snapshots" );
         }
         else
         {
---------------
-------------
@@ -53,7 +53,7 @@
      * Regex pattern for matching instructions when specified in url.
      */
     private static final Pattern INSTRUCTIONS_PATTERN =
-        Pattern.compile( "([a-zA-Z_0-9-]+)=([-!\"'()*+,.0-9A-Z_a-z%]+)" );
+        Pattern.compile( "([a-zA-Z_0-9-]+)=([-!\"'()*+,.0-9A-Z_a-z%;=]+)" );
 
     /**
      * Utility class. Ment to be used using static methods
---------------
-------------
@@ -258,6 +258,7 @@
     // Get all the options from the configuration
     Map<String,String> cryptoOpts = conf.getAllPropertiesWithPrefix(Property.CRYPTO_PREFIX);
     cryptoOpts.putAll(conf.getAllPropertiesWithPrefix(Property.INSTANCE_PREFIX));
+    cryptoOpts.remove(Property.INSTANCE_SECRET.getKey());
     cryptoOpts.put(Property.CRYPTO_BLOCK_STREAM_SIZE.getKey(), Integer.toString((int) conf.getMemoryInBytes(Property.CRYPTO_BLOCK_STREAM_SIZE)));
 
     return fillParamsObjectFromStringMap(params, cryptoOpts);
---------------
-------------
@@ -148,7 +148,7 @@
     throw new RuntimeException("Unable to find port");
   }
   
-  public Process exec(Class<? extends Object> clazz, String... args) throws IOException {
+  Process exec(Class<? extends Object> clazz, String... args) throws IOException {
     String javaHome = System.getProperty("java.home");
     String javaBin = javaHome + File.separator + "bin" + File.separator + "java";
     String classpath = System.getProperty("java.class.path");
---------------
-------------
@@ -495,6 +495,7 @@
   
   public boolean equals(Mutation m) {
     serialize();
+    m.serialize();
     if (Arrays.equals(row, m.row) && entries == m.entries && Arrays.equals(data, m.data)) {
       if (values == null && m.values == null)
         return true;
---------------
-------------
@@ -109,8 +109,8 @@
           // Once this passes, we can issue a shutdown of the pool
           svc.shutdown();
         } catch (Exception e) {
-          log.error("Unabled to get destination tracer hosts in ZooKeeper, will retry in 5 seconds", e);
-          // We failed to connect to ZK, try again in 5seconds
+          log.error("Unabled to get destination tracer hosts in ZooKeeper, will retry in " + retryPause + " milliseconds", e);
+          // We failed to connect to ZK, try again in `retryPause` milliseconds
           svc.schedule(this, retryPause, TimeUnit.MILLISECONDS);
         }
       }
---------------
-------------
@@ -198,7 +198,7 @@
       Credentials creds = Credentials.deserialize(pair[1]);
       return instance.getConnector(creds.getPrincipal(), creds.getToken());
     } else {
-      throw new org.apache.accumulo.core.client.AccumuloSecurityException("", org.apache.accumulo.core.client.impl.thrift.SecurityErrorCode.INVALID_INSTANCEID);
+      throw new org.apache.accumulo.core.client.AccumuloSecurityException(pair[0], org.apache.accumulo.core.client.impl.thrift.SecurityErrorCode.INVALID_INSTANCEID);
     }
   }
   
---------------
-------------
@@ -148,7 +148,7 @@
     throw new RuntimeException("Unable to find port");
   }
   
-  public Process exec(Class<? extends Object> clazz, String... args) throws IOException {
+  Process exec(Class<? extends Object> clazz, String... args) throws IOException {
     String javaHome = System.getProperty("java.home");
     String javaBin = javaHome + File.separator + "bin" + File.separator + "java";
     String classpath = System.getProperty("java.class.path");
---------------
-------------
@@ -642,6 +642,7 @@
     private void _seek(Range range) throws IOException {
       
       this.range = range;
+      this.checkRange = true;
       
       if (blockCount == 0) {
         // its an empty file
---------------
-------------
@@ -63,7 +63,7 @@
      */
     public ValueIterator(SortedKeyValueIterator<Key,Value> source) {
       this.source = source;
-      topKey = source.getTopKey();
+      topKey = new Key(source.getTopKey());
       hasNext = _hasNext();
     }
     
---------------
-------------
@@ -63,7 +63,7 @@
      */
     public ValueIterator(SortedKeyValueIterator<Key,Value> source) {
       this.source = source;
-      topKey = source.getTopKey();
+      topKey = new Key(source.getTopKey());
       hasNext = _hasNext();
     }
     
---------------
-------------
@@ -246,7 +246,7 @@
     String sysUser = System.getProperty("user.name");
     if (sysUser == null)
       sysUser = "root";
-    String user = cl.getOptionValue(usernameOption.getOpt());
+    String user = cl.getOptionValue(usernameOption.getOpt(), sysUser);
 
     String passw = cl.getOptionValue(passwOption.getOpt(), null);
     tabCompletion = !cl.hasOption(tabCompleteOption.getLongOpt());
---------------
-------------
@@ -245,7 +245,7 @@
     String sysUser = System.getProperty("user.name");
     if (sysUser == null)
       sysUser = "root";
-    String user = cl.getOptionValue(usernameOption.getOpt());
+    String user = cl.getOptionValue(usernameOption.getOpt(), sysUser);
 
     String passw = cl.getOptionValue(passwOption.getOpt(), null);
     tabCompletion = !cl.hasOption(tabCompleteOption.getLongOpt());
---------------
-------------
@@ -11,7 +11,8 @@
     // Taken from JDK7 java.lang.Package src code.
     private static Manifest loadManifest(String fn) {
         try (FileInputStream fis = new FileInputStream(fn);
-JarInputStream jis = new JarInputStream(fis, false))
+    // This should be an error
+    JarInputStream jis = new JarInputStream(fis, false))
         {
             return jis.getManifest();
         } catch (IOException e)
---------------
-------------
@@ -136,7 +136,7 @@
                 else if (!Character.isWhitespace(charAfter)
                     && ('(' != charAfter) && (')' != charAfter)
                     && (',' != charAfter) && ('[' != charAfter)
-                    && ('.' != charAfter))
+                    && ('.' != charAfter) && (':' != charAfter))
                 {
                     log(aAST.getLineNo(), after, "ws.illegalFollow", ">");
                 }
---------------
-------------
@@ -109,7 +109,7 @@
 
     protected void addTaxonInfo(Long pageId, Map<String, String> properties) throws PropertyEnricherException {
         try {
-            URI uri = new URI("http", null, "eol.org", 80, "/api/pages/1.0/" + pageId + ".json", "images=1&videos=0&sounds=0&maps=0&text=0&iucn=false&subjects=overview&licenses=all&details=false&common_names=true&synonyms=false&references=false&format=json", null);
+            URI uri = new URI("http", null, "eol.org", 80, "/api/pages/1.0/" + pageId + ".json", "images=0&videos=0&sounds=0&maps=0&text=0&iucn=false&subjects=overview&licenses=all&details=false&common_names=true&synonyms=false&references=false&format=json", null);
             String response = getResponse(uri);
             if (response != null) {
                 addCanonicalNamesAndRanks(properties, response);
---------------
-------------
@@ -90,7 +90,7 @@
         }
 
         properties.put(EOLDictionary.SCIENTIFIC_NAME, (String) result.get("scientificName"));
-        if (result.containsKey("taxonRank")) {
+        if (result.containsKey("rank")) {
             properties.put(EOLDictionary.TAXON_RANK, (String) result.get("rank"));
         }
 
---------------
-------------
@@ -145,7 +145,7 @@
             put(INTERACTION_INTERACTS_WITH, InteractType.INTERACTS_WITH.toString());
             put(INTERACTION_SYMBIONT_OF, InteractType.SYMBIONT_OF.toString());
             put(INTERACTION_HOST_OF, InteractType.HOST_OF.toString());
-            put(INTERACTION_HAS_HOST, InteractType.HOST_OF.toString());
+            put(INTERACTION_HAS_HOST, InteractType.HAS_HOST.toString());
         }
     };
 
---------------
-------------
@@ -27,7 +27,7 @@
             externalIds.add(new TaxonNode(rel.getEndNode()).getExternalId());
 
         }
-        assertThat("expected [" + expectedCount + "] relationships for " + name, counter, is(expectedCount));
+        assertThat("expected [" + expectedCount + "] relationships for [" + name + "]: [" + externalIds.toString() + "]", counter, is(expectedCount));
         return externalIds;
     }
 }
---------------
-------------
@@ -69,6 +69,7 @@
         options.addOption(OPTION_SKIP_IMPORT, false, "skip the import of all GloBI datasets");
         options.addOption(OPTION_SKIP_EXPORT, false, "skip the export for GloBI datasets to aggregated archives.");
         options.addOption(OPTION_SKIP_LINK, false, "skip taxa cross-reference step");
+        options.addOption(OPTION_SKIP_REPORT, false, "skip report generation step");
         options.addOption(OPTION_USE_DARK_DATA, false, "use only dark datasets (requires permission)");
         Option helpOpt = new Option(OPTION_HELP, "help", false, "print this help information");
         options.addOption(helpOpt);
---------------
-------------
@@ -75,7 +75,7 @@
     @Override
     public EcoRegion findEcoRegion(double lat, double lng) throws EcoRegionFinderException {
         Map<String, String> props = findEcoRegion(new GeometryFactory().createPoint(new Coordinate(lng, lat)));
-        return props == null || props.containsKey(config.idLabel) ? null : createEcoRegion(props);
+        return props == null || !props.containsKey(config.idLabel) ? null : createEcoRegion(props);
     }
 
     private EcoRegion createEcoRegion(Map<String, String> props) {
---------------
-------------
@@ -27,7 +27,7 @@
 
     @Bean(destroyMethod = "shutdown")
     public GraphDatabaseService graphDb(@Value("${storeDir:target/graph.db.test}") final String storeDir) {
-        GraphDatabaseBuilder graphDatabaseBuilder = new GraphDatabaseFactory().newEmbeddedDatabaseBuilder(baseDir + storeDir);
+        GraphDatabaseBuilder graphDatabaseBuilder = new GraphDatabaseFactory().newEmbeddedDatabaseBuilder(storeDir);
         graphDatabaseBuilder.setConfig(MapUtil.stringMap("read_only", "false"));
         return graphDatabaseBuilder.newGraphDatabase();
     }
---------------
-------------
@@ -132,7 +132,7 @@
 
     public Taxon findTaxonOfType(String taxonName) throws NodeFactoryException {
         String cleanedTaxonName = correctionService.correct(taxonName);
-        String query = "name:\"" + cleanedTaxonName + "\"";
+        String query = "name:\"" + cleanedTaxonName.replace("\"", "") + "\"";
         IndexHits<Node> matchingTaxa = taxons.query(query);
         Node matchingTaxon;
         Taxon firstMatchingTaxon = null;
---------------
-------------
@@ -228,7 +228,7 @@
                                 addEnvironment(location, envoTerm.getId(), envoTerm.getName());
                             }
                             if (envoTerms.size() == 0) {
-                                addEnvironment(location, PropertyAndValueDictionary.NO_MATCH, habitat);
+                                addEnvironment(location, "SPIRE:" + habitat, habitat);
                             }
                         } catch (EnvoServiceException e) {
                             LOG.warn("unexpected problem during lookup environment for habitat [" + habitat + "]", e);
---------------
-------------
@@ -48,7 +48,7 @@
                 String preyTaxonName = null;
                 for (String preyLabel : preyLabels) {
                     preyTaxonName = parser.getValueByLabel(preyLabel);
-                    if (StringUtils.isNotBlank(preyTaxonName) && !"NA".equals(preyTaxonName)) {
+                    if (StringUtils.isNotBlank(preyTaxonName)) {
                         break;
                     }
                 }
---------------
-------------
@@ -138,7 +138,7 @@
             if (node.isTextual()) {
                 resultBuilder.append("\"");
             }
-            resultBuilder.append(node.getTextValue());
+            resultBuilder.append(node.asText());
             if (node.isTextual()) {
                 resultBuilder.append("\"");
             }
---------------
-------------
@@ -124,6 +124,7 @@
 			oldRecord = currentRecord;
 		}
 		if (resetNeedFor(currentEntity)) {
+			resetCondition();
 			clear();
 		}
 		oldEntity = currentEntity;
---------------
-------------
@@ -173,6 +173,7 @@
 				}
 			}
 		}
+		MemoryWarningSystem.removeListener(this);
 	}
 
 	protected void onFinished() {
---------------
-------------
@@ -143,7 +143,7 @@
 		} catch(IllegalArgumentException e) {
 			HierarchyNode memberResource = new HierarchyNode(memberUri,
 					getGraph(), hierarchyService);
-			UriRef newUri = new UriRef(getNode().getUnicodeString() + "/" +
+			UriRef newUri = new UriRef(getNode().getUnicodeString() +
 				memberResource.getName());
 			memberResource.replaceWith(newUri);
 		}
---------------
-------------
@@ -1,18 +1,20 @@
 /*
- *  Copyright 2010 reto.
- * 
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *  under the License.
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
 package org.apache.clerezza.rdf.utils;
 
---------------
-------------
@@ -196,7 +196,7 @@
      */
     @NonNull
     public URIRequirementBuilder withPath(@CheckForNull String path) {
-        withoutScheme();
+        withoutPath();
         if (path != null) {
             requirements.add(new PathRequirement(path));
         }
---------------
-------------
@@ -196,7 +196,7 @@
      */
     @NonNull
     public URIRequirementBuilder withPath(@CheckForNull String path) {
-        withoutScheme();
+        withoutPath();
         if (path != null) {
             requirements.add(new PathRequirement(path));
         }
---------------
-------------
@@ -131,7 +131,7 @@
                 where("Site.ActivityId").in(filter.getRestrictions(type));
 
             } else if (type == DimensionType.Database) {
-                where("Site.DatabaseId").in(filter.getRestrictions(type));
+                where("Activity.DatabaseId").in(filter.getRestrictions(type));
 
             } else if (type == DimensionType.Partner) {
                 where("Site.PartnerId").in(filter.getRestrictions(type));
---------------
-------------
@@ -77,6 +77,8 @@
 
             stopwatch.stop();
             LOGGER.finest("Acquiring advisory lock takes: " + stopwatch.elapsed(TimeUnit.MILLISECONDS) + "ms");
+        } catch (CommandTimeoutException e) {
+            throw e;
         } catch (Exception e) {
             LOGGER.log(Level.SEVERE, "Internal error during acquiring advisory lock: " + e.getMessage(), e);
             throw new RuntimeException("Exception caught while trying to acquire update lock", e);
---------------
-------------
@@ -440,7 +440,7 @@
 			
 			double da = (y0 + y1) * (x1 - x0) / 2;
 			finArea += da;
-			if (Math.abs(y0 - y1) < 0.00001) {
+			if (Math.abs(y0 + y1) < 0.00001) {
 				finCGx += (x0 + x1) / 2 * da;
 				finCGy += y0 / 2 * da;
 			} else {
---------------
-------------
@@ -262,7 +262,7 @@
 	//  Given the sequentially connected points (a,b), (c,d), and (e,f), this
 	//  function returns, in (C,D), a bevel-inset replacement for point (c,d).
 	//
-	//  Note:  If vectors (a,b)->(c,d) and (c,d)->(e,f) are exactly 180° opposed,
+	//  Note:  If vectors (a,b)->(c,d) and (c,d)->(e,f) are exactly 180 degrees opposed,
 	//         or if either segment is zero-length, this function will do
 	//         nothing; i.e. point (C,D) will not be set.
 	private Coordinate insetCorner(
---------------
-------------
@@ -1,3 +1,18 @@
+/**
+ * Copyright (C) 2013 all@code-story.net
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *         http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
 package net.codestory.http.convert;
 
 import java.util.*;
---------------
-------------
@@ -244,6 +244,10 @@
     
         
     private void copyHtmlResources(String reportFolderPath) throws IOException {
+    	// copy sorting libs
+        copyResourceToFolder("/html-report/tablesorter.css", reportFolderPath + File.separator + "tablesorter.css");
+        copyResourceToFolder("/html-report/tablesorter.js", reportFolderPath + File.separator + "tablesorter.js");
+    	// copy galen libs
         copyResourceToFolder("/html-report/galen-report.css", reportFolderPath + File.separator + "galen-report.css");
         copyResourceToFolder("/html-report/galen-report.js", reportFolderPath + File.separator + "galen-report.js");
         copyResourceToFolder("/html-report/jquery-1.10.2.min.js", reportFolderPath + File.separator + "jquery-1.10.2.min.js");
---------------
-------------
@@ -238,7 +238,7 @@
                     String name = file.getName().toLowerCase();
                     if (name.endsWith(".test")) {
                         basicTestFiles.add(file);
-                    } else if (name.endsWith(".test.js")) {
+                    } else if (name.endsWith(".js")) {
                         jsTestFiles.add(file);
                     }
                 }
---------------
-------------
@@ -212,7 +212,7 @@
                 + " This is extremely unsafe for production. Caveat utilitor!"); //$NON-NLS-1$
 
         try {
-            SSLContext sslContext = SSLContext.getInstance("Default"); //$NON-NLS-1$
+            SSLContext sslContext = SSLContext.getInstance("TLSv1"); //$NON-NLS-1$
 
             // This accepts anything.
             sslContext.init(null, new X509TrustManager[] { new X509TrustManager() {
---------------
-------------
@@ -37,7 +37,7 @@
                 mavenBundle("javax.validation", "validation-api", "1.1.0.Final"), //
                 mavenBundle("commons-lang", "commons-lang", "2.6"), //
                 mavenBundle("org.osgi", "org.osgi.compendium", "4.3.1"), //
-                mavenBundle("org.apache.felix", "org.apache.felix.configadmin", "1.4.0").start(true), //
+                mavenBundle("org.apache.felix", "org.apache.felix.configadmin", "1.6.0").start(true), //
                 mavenBundle("org.apache.felix", "org.apache.felix.scr", "1.6.2"), //
                 mavenBundle("org.slf4j", "slf4j-api", "1.7.2"), //
                 mavenBundle("ch.qos.logback", "logback-core", "1.0.6"), //
---------------
-------------
@@ -37,7 +37,7 @@
                 mavenBundle("javax.validation", "validation-api", "1.1.0.Final"), //
                 mavenBundle("commons-lang", "commons-lang", "2.6"), //
                 mavenBundle("org.osgi", "org.osgi.compendium", "4.3.1"), //
-                mavenBundle("org.apache.felix", "org.apache.felix.configadmin", "1.4.0").start(true), //
+                mavenBundle("org.apache.felix", "org.apache.felix.configadmin", "1.6.0").start(true), //
                 mavenBundle("org.apache.felix", "org.apache.felix.scr", "1.6.2"), //
                 mavenBundle("org.slf4j", "slf4j-api", "1.7.2"), //
                 mavenBundle("ch.qos.logback", "logback-core", "1.0.6"), //
---------------
-------------
@@ -142,7 +142,7 @@
                         return "зараз";
                     }
                     if (duration.isInPast()) {
-                        return "тільки що";
+                        return "щойно";
                     }
                     return null;
                 }
---------------
-------------
@@ -73,7 +73,7 @@
             {"MonthFutureSuffix", ""},
             {"MonthPastPrefix", ""},
             {"MonthPastSuffix", "前"},
-            {"MonthSingularName", "月"},
+            {"MonthSingularName", "ヶ月"},
             {"MonthPluralName", "ヶ月"},
             {"SecondPattern", "%n%u"},
             {"SecondFuturePrefix", ""},
---------------
-------------
@@ -142,7 +142,7 @@
                         return "зараз";
                     }
                     if (duration.isInPast()) {
-                        return "тільки що";
+                        return "щойно";
                     }
                     return null;
                 }
---------------
-------------
@@ -73,7 +73,7 @@
             {"MonthFutureSuffix", ""},
             {"MonthPastPrefix", ""},
             {"MonthPastSuffix", "前"},
-            {"MonthSingularName", "月"},
+            {"MonthSingularName", "ヶ月"},
             {"MonthPluralName", "ヶ月"},
             {"SecondPattern", "%n%u"},
             {"SecondFuturePrefix", ""},
---------------
-------------
@@ -287,7 +287,7 @@
             if (!RoleService.exists(role)){
                 throw new CommandExecutionException(command,"required role does not exists: "+role);
             }
-            JsonNode userVisible = params.get(UserDao.ATTRIBUTES_VISIBLE_BY_ANONYMOUS_USER);
+            JsonNode userVisible = params.get(UserDao.ATTRIBUTES_VISIBLE_ONLY_BY_THE_USER);
             JsonNode friendsVisible = params.get(UserDao.ATTRIBUTES_VISIBLE_BY_FRIENDS_USER);
             JsonNode registeredVisible = params.get(UserDao.ATTRIBUTES_VISIBLE_BY_REGISTERED_USER);
             JsonNode anonymousVisible = params.get(UserDao.ATTRIBUTES_VISIBLE_BY_ANONYMOUS_USER);
---------------
-------------
@@ -371,8 +371,6 @@
 				unauthorized("appcode can not be null");
 			}
 			
-			
-			
 			java.io.File dir = new java.io.File(Play.application().path().getAbsolutePath()+sep+backupDir);
 			if(!dir.exists()){
 				boolean createdDir = dir.mkdir();
---------------
-------------
@@ -262,7 +262,7 @@
                 String[] ary = new String[val.size()];
                 int idx = 0;
                 for (JsonNode n: val){
-                    String s = n==null?null:n.toString();
+                    String s = n==null?null:n.asText();
                     ary[idx++] = s;
                 }
                 query.put(k,ary);
---------------
-------------
@@ -287,7 +287,7 @@
             if (!RoleService.exists(role)){
                 throw new CommandExecutionException(command,"required role does not exists: "+role);
             }
-            JsonNode userVisible = params.get(UserDao.ATTRIBUTES_VISIBLE_BY_ANONYMOUS_USER);
+            JsonNode userVisible = params.get(UserDao.ATTRIBUTES_VISIBLE_ONLY_BY_THE_USER);
             JsonNode friendsVisible = params.get(UserDao.ATTRIBUTES_VISIBLE_BY_FRIENDS_USER);
             JsonNode registeredVisible = params.get(UserDao.ATTRIBUTES_VISIBLE_BY_REGISTERED_USER);
             JsonNode anonymousVisible = params.get(UserDao.ATTRIBUTES_VISIBLE_BY_ANONYMOUS_USER);
---------------
-------------
@@ -262,7 +262,7 @@
                 String[] ary = new String[val.size()];
                 int idx = 0;
                 for (JsonNode n: val){
-                    String s = n==null?null:n.toString();
+                    String s = n==null?null:n.asText();
                     ary[idx++] = s;
                 }
                 query.put(k,ary);
---------------
-------------
@@ -83,7 +83,7 @@
             throw new CommandParsingException(command,"missing required user");
         boolean unfollow;
         if (remove == null){
-            unfollow = true;
+            unfollow = false;
         } else if (remove.isBoolean()){
             unfollow =remove.asBoolean();
         } else {
---------------
-------------
@@ -195,6 +195,7 @@
 			  if (!Util.validateEmail((String) privateAttributes.findValuesAsText("email").get(0)))
 				  return badRequest("The email address must be valid.");
 		  }
+		  if (StringUtils.isEmpty(password)) return status(422,"The password field cannot be empty");
 		  
 		  //try to signup new user
 		  ODocument profile = null;
---------------
-------------
@@ -16,9 +16,7 @@
 
 import java.io.Serializable;
 
-/**
- * Created by benjamin on 10/20/13.
- */
+
 public class ServerModel implements Server, Serializable {
 
     private String url;
---------------
-------------
@@ -157,7 +157,7 @@
 
     @Override
     public double getDoubleValue() {
-        return this.d;
+        return this.d == null ? 0.0 : this.d;
 
     }
 
---------------
-------------
@@ -39,8 +39,6 @@
     @Resource(name="entityDao")
     private EntityJPATransactions entityDao;
 
-
-
     @RequestMapping(value="service/search", method= RequestMethod.GET)
     public String search(
             @RequestParam("search") String dangerousSearchText,
---------------
-------------
@@ -55,7 +55,7 @@
     // removing all the links we found this time around from the set of
     // old links. any links remaining after this will be stale, and need
     // to be retracted
-    for (Link newl : curlinks) {
+    for (Link newl : new ArrayList<Link>(curlinks)) {
       String key = makeKey(newl);
       Link oldl = oldmap.get(key);
       if (oldl == null)
---------------
-------------
@@ -458,6 +458,7 @@
 				org.osgi.service.remoteserviceadmin.RemoteConstants.ENDPOINT_ID,
 				UUID.randomUUID().toString());
 		props.put(org.osgi.framework.Constants.OBJECTCLASS, new String[] { UUID.randomUUID().toString() });
+		props.put(org.osgi.service.remoteserviceadmin.RemoteConstants.SERVICE_IMPORTED_CONFIGS, UUID.randomUUID().toString());
 		checkEndpointPermissionRead(
 				"checkRSAReadAccess", new org.osgi.service.remoteserviceadmin.EndpointDescription( //$NON-NLS-1$
 						props));
---------------
-------------
@@ -20,6 +20,7 @@
  */
 public class Ajc160Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	
+	public void testDecFieldProblem_pr218167() { runTest("dec field problem");}
 	public void testGenericsSuperITD_pr206911() { runTest("generics super itd"); }
 	public void testGenericsSuperITD_pr206911_2() { runTest("generics super itd - 2"); }
 
---------------
-------------
@@ -23,6 +23,7 @@
 public class Ajc161Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	
 	// AspectJ1.6.1
+	public void testGenericAspectAroundAdvice_pr226201() { runTest("generic aspect around advice");}
 	public void testCrazyGenericsInnerTypes_pr235829() { runTest("crazy generics and inner types");}
 	public void testAnnotationExposureGenerics_pr235597() { runTest("annotation exposure and generics");}
     public void testIncorrectRelationship_pr235204() {
---------------
-------------
@@ -96,7 +96,7 @@
 		// classes that represent arrays return a class name that is the signature of the array type, ho-hum...
 		String className = aClass.getName();
 		if (aClass.isArray()) {
-			return world.resolve(UnresolvedType.forSignature(className));
+			return world.resolve(UnresolvedType.forSignature(className.replace('.','/')));
 		}
 		else{
 			return world.resolve(className);
---------------
-------------
@@ -643,7 +643,7 @@
         addColumn("lengthTriggersChangedEnvironment", new LUndef());
         addColumn("lengthTriggersChangedObjective", new LUndef());
         addColumn("lengthTriggersChangedCollectionProfile", new LUndef());
-        addColumn("lengthColändere das noch mit lectionProfileDescription", new LUndef());
+        addColumn("lengthCollectionProfileDescription", new LUndef());
         addColumn("lengthCollectionProfileTypeOfObjects", new LUndef());
         addColumn("lengthCollectionProfileExpectedGrowthRate", new LUndef());
         addColumn("lengthCollectionProfileRetentionPeriod", new LUndef());
---------------
-------------
@@ -431,7 +431,7 @@
       }
 
       @SuppressWarnings("unchecked")  // Guaranteed by javax.servlet
-      Map<String, String[]> params = (Map<String, String[]>)request.getParameterMap();
+      Map<String, String[]> params = (Map<String, String[]>) request.getParameterMap();
 
       // Extract injectable pieces of the pathInfo.
       final Map<String, String> map = matcher.findMatches(pathInfo);
---------------
-------------
@@ -31,6 +31,7 @@
 public class SoapContext {
 
     public final static SoapContext DEFAULT = SoapContext.builder().build();
+    public final static SoapContext NO_CONTENT = SoapContext.builder().exampleContent(false).build();
 
     /**
      * Generates comments with type information in new requests
---------------
-------------
@@ -36,7 +36,7 @@
   public List<ValidationError> check(Sentence sentence) {
     List<ValidationError> result = new ArrayList<ValidationError>();
     String content = sentence.content;
-    if (!sentence.isStartaragraph
+    if (!sentence.isStartaragraph && content.length() > 0
         && !String.valueOf(content.charAt(0)).equals(" ")) {
       result.add(new ValidationError(
           "Space not exist the beggining of sentence.",
---------------
-------------
@@ -40,7 +40,7 @@
     @Override
     public void validate(List<ValidationError> errors, Sentence sentence) {
         String content = sentence.content;
-        if (!isFistInLine(sentence) && !String.valueOf(content.charAt(0)).equals(" ")) {
+        if (!isFistInLine(sentence) && content.length() > 0 && content.charAt(0) != ' ') {
             errors.add(createValidationError(sentence));
         }
     }
---------------
-------------
@@ -31,7 +31,7 @@
      * @throws IOException if an error occurs.
      */
     public static File getTestFile(String testFile) throws IOException {
-        File file = new File("src/test/org/jnode/fs/", testFile);
+        File file = new File("fs/src/test/org/jnode/fs/", testFile);
 
         // Look for the gzip file.
         File gzipFile = new File(file.getParent(), file.getName() + ".gz");
---------------
-------------
@@ -31,7 +31,7 @@
      * @throws IOException if an error occurs.
      */
     public static File getTestFile(String testFile) throws IOException {
-        File file = new File("src/test/org/jnode/fs/", testFile);
+        File file = new File("fs/src/test/org/jnode/fs/", testFile);
 
         // Look for the gzip file.
         File gzipFile = new File(file.getParent(), file.getName() + ".gz");
---------------
-------------
@@ -88,6 +88,7 @@
                     return token;
                 })
                 .filter(token -> token.length() > MINIMUM_TOKEN_SIZE)
+                .distinct()
                 .collect(Collectors.toList());
     }
 
---------------
-------------
@@ -18,7 +18,7 @@
 
     private String baseToken;
     private char[] tokenElements;
-    final private char[] elements = "ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮйцукенгшщзхъфывапролджэячсмитьбю".toCharArray();
+    final private char[] elements = " ".toCharArray();
     private char separator;
     private int filesCount;
     private Path location;
---------------
-------------
@@ -9,7 +9,7 @@
 import java.util.stream.Collectors;
 
 
-class DictBuilder implements IDictBuilder<Collection<String>> {
+public class DictBuilder implements IDictBuilder<Collection<String>> {
 
     private final ISetComparator comparator;
 
---------------
-------------
@@ -60,7 +60,6 @@
                 .collect(Collectors.toList());
     }
 
-    @VisibilityReducedForTestPurposeOnly
     static List<CharacterStat> getCharactersStatistic(final StatData startCharacterStatData, final StatData endCharactersStatData) {
         final List<CharacterStat> characterStats = new ArrayList<>(startCharacterStatData.getAllCharacters().size());
         for (Character ch : startCharacterStatData.getAllCharacters()) {
---------------
-------------
@@ -44,7 +44,7 @@
 
     @Override
     public void describeTo(Description description) {
-        description.appendText("Rfc1123-compliant date in header");
+        description.appendText("Rfc1123-compliant date in header, like 'Mon, 09 May 2011 18:49:18 GMT'");
     }
 
 }
---------------
-------------
@@ -48,7 +48,7 @@
      */
     public Header(String nameAndValue) {
 
-        String[] parts = nameAndValue.split(":");
+        String[] parts = nameAndValue.split(":", 2);
 
         if (parts.length != 2) {
             throw new IllegalArgumentException("Single-argument Header must be 'name: value'");
---------------
-------------
@@ -133,6 +133,7 @@
 
         if (StringUtils.isNotEmpty(content)) {
             httpString.appendNewLine();
+            httpString.appendNewLine();
             httpString.append(StringUtils.abbreviate(content, Response.MAX_BODY_DISPLAY_LENGTH));
         }
 
---------------
-------------
@@ -376,6 +376,7 @@
         uninstallerMerge.addAll(pathResolver.getMergeableFromPath("uninstaller-META-INF/", "META-INF/"));
         uninstallerMerge.addAll(pathResolver.getMergeableFromPath("com/izforge/izpack/api/"));
         uninstallerMerge.addAll(pathResolver.getMergeableFromPath("com/izforge/izpack/util/"));
+        uninstallerMerge.addAll(pathResolver.getMergeableFromPath("com/izforge/izpack/gui/"));
 
         // The uninstaller extension is facultative; it will be exist only
         // if a native library was marked for uninstallation.
---------------
-------------
@@ -1,4 +1,4 @@
-package org.apache.maven.it0000;
+package org.apache.maven.it0036;
 
 public class Person
 {
---------------
-------------
@@ -278,7 +278,7 @@
                 value = project.getProperties().getProperty( expression );
             }
 
-            if ( value == null )
+            if ( value == null && properties != null )
             {
                 // We will attempt to get nab a system property as a way to specify a
                 // parameter to a plugins. My particular case here is allowing the surefire
---------------
-------------
@@ -171,6 +171,8 @@
 
                                 set.add( node );
                                 
+                                // This is required right now.
+                                result.addArtifact( artifact );
                                 result.addRequestedArtifact( artifact );
                             }
                         }
---------------
-------------
@@ -164,7 +164,7 @@
             }
 
             // if the expression refers to itself, skip it.
-            if ( String.valueOf( value ).indexOf( realExpr ) > -1 )
+            if ( String.valueOf( value ).indexOf( wholeExpr ) > -1 )
             {
                 throw new ModelInterpolationException( wholeExpr, model.getId() + " references itself." );
             }
---------------
-------------
@@ -193,7 +193,7 @@
             context.getLog().warn( "DEPRECATED: use ${} to delimit expressions instead of # for '" + expr + "'" );
             expr = expr.substring( 1 );
         }
-        else if ( expr.startsWith( "${" ) && expr.endsWith( "}" ) )
+        else if ( expr.startsWith( "${" ) && expr.indexOf( "}" ) == expr.length() - 1 )
         {
             expr = expr.substring( 2, expr.length() - 1 );
         }
---------------
-------------
@@ -14,7 +14,7 @@
     private final double result;
 
     CodeProportionsRatio( int part, int total ) {
-        result = computeRatio( part, total );
+        result = total == 0 ? 0 : computeRatio( part, total );
     }
 
     public double compute() {
---------------
-------------
@@ -22,7 +22,7 @@
     }
 
     public double computeReverseIndicator() {
-        return result == 0 ? 0 : 100 - result;
+        return 100 - result;
     }
 
     // internal
---------------
-------------
@@ -136,9 +136,6 @@
                             // TODO: For progressive, there will be more than one SOS...
                             length = Long.MAX_VALUE - realPosition;
                         }
-//                        else if (marker == JPEG.APP14 && isAppSegmentWithId("Adobe", stream)) {
-//                            length = 16;
-//                        }
                         else {
                             // Length including length field itself
                             length = stream.readUnsignedShort() + 2;
---------------
-------------
@@ -62,7 +62,7 @@
   @Deprecated
   public QueryDataRowWrapper(final DataRow backend, final int queryLimit, final int queryTimeout)
   {
-    this(backend, queryLimit, queryTimeout, workAroundBrokenJavaGenerics());
+    this(backend, queryTimeout, queryLimit, workAroundBrokenJavaGenerics());
   }
 
   private static List<SortConstraint> workAroundBrokenJavaGenerics()
---------------
-------------
@@ -210,7 +210,7 @@
 
     static public Pattern getTokenPattern(String str) {
         String regex;
-        regex = str.replaceAll("\\[(.*)\\]",
+        regex = str.replaceAll("\\[(.*?)\\]",
                 Matcher.quoteReplacement("\\[") +
                 "$1" + Matcher.quoteReplacement("\\]"));
         regex = regex.replaceAll("\\-", Matcher.quoteReplacement("\\-"));
---------------
-------------
@@ -210,7 +210,7 @@
 
     static public Pattern getTokenPattern(String str) {
         String regex;
-        regex = str.replaceAll("\\[(.*)\\]",
+        regex = str.replaceAll("\\[(.*?)\\]",
                 Matcher.quoteReplacement("\\[") +
                 "$1" + Matcher.quoteReplacement("\\]"));
         regex = regex.replaceAll("\\-", Matcher.quoteReplacement("\\-"));
---------------
-------------
@@ -29,7 +29,7 @@
     }
 
     @Override
-    protected void removeLifecycleListener(Object listener) {
+    protected void removeLifecycleListener(LifecycleListener listener) {
         throw new UnsupportedOperationException("Not supported yet.");
     }
 
---------------
-------------
@@ -79,6 +79,8 @@
                             if (mailbox.value(n) == msg) // another call to receive from within the processor may have deleted n
                                 mailbox.del(n);
                             throw e;
+                        } finally {
+                            currentMessage = null;
                         }
                         actor.monitorSkippedMessage();
                     }
---------------
-------------
@@ -424,7 +424,7 @@
 	 */
 	public String wrapInDiv(String xml) {
 		xml = xml.trim();
-		xml = xml.replaceAll("<htmlform>(.*)</htmlform>", "<div class=\"htmlform\">$1</div>");
+		xml = xml.replaceAll("(?s)<htmlform>(.*)</htmlform>", "<div class=\"htmlform\">$1</div>");
 		return xml;
 	}
 	
---------------
-------------
@@ -65,7 +65,7 @@
     }
 
     public double mean() {
-        return mean();
+        return mean;
     }
 
     public double variance() {
---------------
-------------
@@ -68,7 +68,7 @@
         }
     }
 
-    public static int getAvialablePort(final int basePort) {
+    public static int getAvailablePort(final int basePort) {
         if(basePort == 0) {
             return getAvailablePort();
         }
---------------
-------------
@@ -65,7 +65,7 @@
     }
 
     public double mean() {
-        return mean();
+        return mean;
     }
 
     public double variance() {
---------------
-------------
@@ -241,6 +241,7 @@
                 final ResourceConfig config = ResourceConfig.forApplication(new CstlApplication());
                 config.addProperties(grizzlyWebContainerProperties);
                 ApplicationHandler handler = new ApplicationHandler(config);
+
                 threadSelector = GrizzlyHttpServerFactory.createHttpServer(currentUri, handler, true);
                 
             } catch (ProcessingException e) {
---------------
-------------
@@ -165,7 +165,7 @@
                 //workaround because 1.1.1 is defined with a DTD rather than an XSD
                 //we marshall the response and return the XML String
                 final StringWriter sw = new StringWriter();
-                marshaller.setProperty("com.sun.xml.bind.xmlHeaders",
+                marshaller.setProperty("com.sun.xml.internal.bind.xmlHeaders",
                            (requestCapab.getVersion().toString().equals("1.1.1")) ?
                            "<!DOCTYPE WMT_MS_Capabilities SYSTEM \"http://schemas.opengis.net/wms/1.1.1/WMS_MS_Capabilities.dtd\">\n" :
                            "");
---------------
-------------
@@ -98,6 +98,7 @@
     /**
      * Construit un data record pour l'enregistrement courant.
      */
+    @Override
     protected SimpleDataRecordEntry createEntry(final ResultSet results) throws CatalogException, SQLException {
         final SimpleDataRecordQuery query = (SimpleDataRecordQuery) super.query;
         final String idDataBlock = results.getString(indexOf(query.idBlock));
---------------
-------------
@@ -16,7 +16,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.constellation.test;
+package org.constellation.test.utils;
 
 import org.apache.sis.test.XMLComparator;
 import org.w3c.dom.Node;
---------------
-------------
@@ -860,7 +860,7 @@
             }
         
         availableStandardLabel = availableStandardLabel.substring(0, availableStandardLabel.length() - 1);
-        LOGGER.warning("class no found: " + className + " in the following standards: " + availableStandardLabel + "\n (" + object.getClass().getName() + ')');
+        LOGGER.warning("class not found: " + className + " in the following standards: " + availableStandardLabel + "\n (" + object.getClass().getName() + ')');
         return null;
     }
 
---------------
-------------
@@ -78,6 +78,12 @@
         return builder.toString();
     }
 
+    /**
+     * Parse a boolean from a string value.
+     * 
+     * @param strTransparent
+     * @return
+     */
     public static boolean toBoolean(final String strTransparent) {
         if (strTransparent == null) {
             return false;
---------------
-------------
@@ -99,7 +99,7 @@
      */
     public int getProfile(int dbType) {
         switch (dbType) {
-            case MDWEB:
+            case MDWEB :
                 return CSWworker.TRANSACTIONAL;
             case FILESYSTEM:
                 return CSWworker.TRANSACTIONAL;
---------------
-------------
@@ -142,7 +142,7 @@
                 // @checkstyle MultipleStringLiterals (2 lines)
                 .queryParam("client_id", "{client_id}")
                 .queryParam("redirect_uri", "{redirect_uri}")
-                .build(this.appKey, this.redirectUri())
+                .build(this.appId, this.redirectUri())
         );
     }
 
---------------
-------------
@@ -52,7 +52,7 @@
  * <p>The class is immutable and thread-safe.
  *
  * @author Evgeniy Nyavro (e.nyavro@gmail.com)
- * @version $Id: WebappFilesCheck.java 1732 2012-05-24 20:36:50Z guard $
+ * @version $Id$
  */
 final class WebappFilesCheck implements Check {
 
---------------
-------------
@@ -72,7 +72,7 @@
     public void render(@NotNull final BasePage<?, ?> page,
         @NotNull final Response.ResponseBuilder builder) {
         assert this.resource != null;
-        page.link(new Link("self", "./"));
+        page.link(new Link("self", "."));
         page.link(new Link("home", "/"));
     }
 
---------------
-------------
@@ -100,7 +100,7 @@
             } else {
                 uri = this.home.resolve(link);
             }
-            if (!NoBrokenLinks.isValid(uri)) {
+            if (!uri.isAbsolute() || !NoBrokenLinks.isValid(uri)) {
                 broken.add(uri);
             }
         }
---------------
-------------
@@ -276,6 +276,7 @@
                     Logger.warn(
                         this,
                         "assertThat(%[type]s): attempt #%d failed, re-trying..",
+                        assertion,
                         attempt
                     );
                     this.iresponse = null;
---------------
-------------
@@ -112,7 +112,7 @@
             mrsh = this.buildContext(type).createMarshaller();
             mrsh.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
             final String header = String.format(
-                "\n<?xml-stylesheet type='text/xml' href='%s'?>",
+                "\n<?xml-stylesheet type='text/xsl' href='%s'?>",
                 StringEscapeUtils.escapeXml(this.stylesheet(type))
             );
             mrsh.setProperty("com.sun.xml.bind.xmlHeaders", header);
---------------
-------------
@@ -114,7 +114,7 @@
         int close = line.lastIndexOf(")");
         if (close == -1) close = line.length();
         sb.append("\"");
-        sb.append(Utils.escapeDoubleQuotesAndBackSlashes(line.substring(comma+1, close)));
+        sb.append(separateVariables(line.substring(comma+1, close).trim()));
         sb.append("\");");
         return scheduleLine(sb.toString(), lineNumber);
     }
---------------
-------------
@@ -37,7 +37,7 @@
   /* just for dev use /
   @Test
   public void singletest() {
-    String suitePath = getSuitePath("/integration/date.sah");
+    String suitePath = getSuitePath("/integration/language.sah");
     runSuite(suitePath);
   }
   //*/
---------------
-------------
@@ -179,6 +179,7 @@
     if (inputSchema.isNullable()) {
       if (val == null) {
         builder.set(fieldName, null);
+        return;
       }
       inputType = inputSchema.getNonNullable().getType();
       outputType = outputSchema.getNonNullable().getType();
---------------
-------------
@@ -169,7 +169,7 @@
     if (!this.deferred.isEmpty()) {
       try {
         // this will start, use and return a new transaction if xaction is null
-        this.xaction = this.opex.execute(this.context, null, this.deferred);
+        this.xaction = this.opex.execute(this.context, this.xaction, this.deferred);
         this.deferred.clear();
       } catch (OperationException e) {
         // opex aborts the transaction if the execute fails
---------------
-------------
@@ -33,10 +33,10 @@
 
 /**
  * Client for interacting with Local Reactor's app-fabric service to perform the following operations:
- * a) Deploy locally
- * b) Start/Stop/Status of flow in Local Reactor
- * c) Promote to cloud
- * d) Change number of instances of flowlet in Local Reactor
+ * a) Deploy app
+ * b) Start/Stop/Status of flow, procedure or map reduce job
+ * c) Promote app to cloud
+ * d) Scale number of flowlet instances
  * <p/>
  * Usage:
  * ReactorClient client = new ReactorClient();
---------------
-------------
@@ -257,6 +257,7 @@
   }
 
   @Override
+  @Deprecated
   public FileSet getUnderlyingFileSet() {
     return getEmbeddedFileSet();
   }
---------------
-------------
@@ -51,6 +51,11 @@
 
   @Override
   public Module getInMemoryModules() {
+    // Turning off assertions for Hive packages, since some assertions in StandardStructObjectInspector do not work
+    // when outer joins are run. It is okay to turn off Hive assertions since we assume Hive is a black-box that does
+    // the right thing, and we only want to test our/our user's code.
+    getClass().getClassLoader().setPackageAssertionStatus("org.apache.hadoop.hive", false);
+    getClass().getClassLoader().setPackageAssertionStatus("org.apache.hive", false);
     return Modules.combine(new ExploreExecutorModule(), new ExploreLocalModule(true));
   }
 
---------------
-------------
@@ -149,7 +149,7 @@
     conf.set(Constants.AppFabric.OUTPUT_DIR, System.getProperty("java.io.tmpdir"));
     conf.set(Constants.AppFabric.TEMP_DIR, System.getProperty("java.io.tmpdir"));
     conf.setBoolean(Constants.Scheduler.SCHEDULERS_LAZY_START, true);
-
+    conf.set(Constants.AppFabric.APP_TEMPLATE_DIR, tmpFolder.newFolder("plugins").getAbsolutePath());
     conf.setBoolean(Constants.Dangerous.UNRECOVERABLE_RESET, true);
 
     DirUtils.mkdirs(new File(conf.get(Constants.AppFabric.APP_TEMPLATE_DIR)));
---------------
-------------
@@ -42,7 +42,7 @@
   private static final String COUNT = "count";
   private static final String START_TIME = "start";
   private static final String END_TIME = "end";
-  private static final String RUN_ID = "runId";
+  private static final String RUN_ID = "run-id";
   private static final String INTERPOLATE = "interpolate";
   private static final String STEP_INTERPOLATOR = "step";
   private static final String LINEAR_INTERPOLATOR = "linear";
---------------
-------------
@@ -362,7 +362,7 @@
   private static void parseRunIdFromQueryParam(Map<String, List<String>> queryParams, MetricsRequestBuilder builder)
     throws MetricsPathException {
     if (queryParams.containsKey(RUN_ID)) {
-      if (queryParams.size() > 1) {
+      if (queryParams.get(RUN_ID).size() > 1) {
         throw new MetricsPathException("Should supply only one run-id");
       }
       builder.setRunId(queryParams.get(RUN_ID).get(0));
---------------
-------------
@@ -47,7 +47,7 @@
 
   @Override
   protected NavigableMap<byte[], byte[]> getPersisted(byte[] row, byte[][] columns) throws Exception {
-    return core.getRow(row, columns, null, null, columns.length, tx);
+    return core.getRow(row, columns, null, null, columns == null ? Integer.MAX_VALUE: columns.length, tx);
   }
 
   @Override
---------------
-------------
@@ -141,6 +141,8 @@
     if (zkClient != null && zkClient.isRunning()) {
       zkClient.stop();
     }
+
+    notifyStopped();
   }
 
   private ZKClientService getZkClientService(String zkConnectionString) {
---------------
-------------
@@ -195,7 +195,7 @@
       String message =
           String.format("Meta data entry for %s already exists.", entry);
       Log.debug(message);
-      throw new OperationException(StatusCode.ENTRY_EXISTS, message);
+      throw new OperationException(StatusCode.WRITE_CONFLICT, message);
     }
     if (isUpdate) {
       if (bytesRead == null) {
---------------
-------------
@@ -67,7 +67,7 @@
     prop.setProperty("socket.receive.buffer.bytes", "1048576");
     prop.setProperty("socket.request.max.bytes", "104857600");
     prop.setProperty("log.dir", tmpFolder.newFolder().getAbsolutePath());
-    prop.setProperty("num.partitions", "10");
+    prop.setProperty("num.partitions", "2");
     prop.setProperty("log.flush.interval.messages", "10000");
     prop.setProperty("log.flush.interval.ms", "1000");
     prop.setProperty("log.retention.hours", "1");
---------------
-------------
@@ -74,7 +74,7 @@
     public void run() {
       LOG.info("Ran dummy action");
       try {
-        Thread.sleep(500);
+        TimeUnit.MILLISECONDS.sleep(500);
       } catch (InterruptedException e) {
         LOG.info("Interrupted");
       }
---------------
-------------
@@ -51,6 +51,11 @@
 
   @Override
   public Module getInMemoryModules() {
+    // Turning off assertions for Hive packages, since some assertions in StandardStructObjectInspector do not work
+    // when outer joins are run. It is okay to turn off Hive assertions since we assume Hive is a black-box that does
+    // the right thing, and we only want to test our/our user's code.
+    getClass().getClassLoader().setPackageAssertionStatus("org.apache.hadoop.hive", false);
+    getClass().getClassLoader().setPackageAssertionStatus("org.apache.hive", false);
     return Modules.combine(new ExploreExecutorModule(), new ExploreLocalModule(true));
   }
 
---------------
-------------
@@ -179,6 +179,7 @@
     if (inputSchema.isNullable()) {
       if (val == null) {
         builder.set(fieldName, null);
+        return;
       }
       inputType = inputSchema.getNonNullable().getType();
       outputType = outputSchema.getNonNullable().getType();
---------------
-------------
@@ -2676,5 +2676,4 @@
                            String.format(UserMessages.getMessage(UserErrors.RESET_FAIL), e.getMessage()));
     }
   }
-
 }
---------------
-------------
@@ -116,6 +116,8 @@
         || uriParts[5].equals("tables") || uriParts[5].equals("jdbc"))) {
       // namespaced explore operations. For example, /v3/namespaces/{namespace-id}/data/explore/streams/{stream}/enable
       return Constants.Service.EXPLORE_HTTP_USER_SERVICE;
+    } else if ((uriParts.length == 3) && uriParts[1].equals("explore") && uriParts[2].equals("status")) {
+      return Constants.Service.EXPLORE_HTTP_USER_SERVICE;
     } else if (uriParts.length == 7 && uriParts[3].equals("data") && uriParts[4].equals("datasets") &&
       (uriParts[6].equals("flows") || uriParts[6].equals("workers") || uriParts[6].equals("mapreduce"))) {
       // namespaced app fabric data operations:
---------------
-------------
@@ -1,7 +1,7 @@
 package com.continuuity.hive;
 
 import com.continuuity.hive.client.HiveClient;
-import junit.framework.Assert;
+import org.junit.Assert;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
---------------
-------------
@@ -300,8 +300,9 @@
 
     ResourceAssigner<Discoverable> assigner = DefaultResourceAssigner.create(assignmentMap);
 
-    // Call the strategy for assignment only if there are some handlers.
-    if (!handlers.isEmpty()) {
+    // Call the strategy for assignment only if there are some handlers and the requirement is not empty.
+    // Otherwise the assignment will be just an empty assignment
+    if (!handlers.isEmpty() && !partitions.isEmpty()) {
       assignmentStrategy.assign(requirement, handlers, assigner);
     }
 
---------------
-------------
@@ -113,7 +113,6 @@
             // NOTE: we assume all classes needed to load dataset module class are available in the jar or otherwise
             //       are system classes
             // NOTE: if jarLocation is null, we assume that this is a system module, ie. always present in classpath
-
             cl = jarLocation == null ? this.getClass().getClassLoader() :
               ClassLoaders.newProgramClassLoaderWithoutFilter(unpackedLocation, this.getClass().getClassLoader());
             @SuppressWarnings("unchecked")
---------------
-------------
@@ -690,7 +690,7 @@
 
       StreamSpecification stream = store.getStream(Id.Namespace.from(namespaceId), streamId);
       if (stream == null) {
-        responder.sendString(HttpResponseStatus.BAD_REQUEST, "Stream specified with streamId param does not exist");
+        responder.sendString(HttpResponseStatus.NOT_FOUND, "Stream specified with streamId param does not exist");
         return;
       }
 
---------------
-------------
@@ -9,6 +9,7 @@
  */
 // todo: implementations should throw different from TransactionFailureException in case of user code error?
 // todo: accept only Callable? Executors util has a way to convert everything to Callable...
+// TODO: Unify with TransactionalDatasetRegistry, see https://jira.continuuity.com/browse/REACTOR-324
 public interface TransactionExecutor {
 
   /**
---------------
-------------
@@ -65,7 +65,8 @@
   }
 
   public boolean isVisible(long version) {
-    return version <= getReadPointer() && !isExcluded(version);
+    // either it was committed before or the change belongs to current tx
+    return (version <= getReadPointer() && !isExcluded(version)) || writePointer == version;
   }
 
   public boolean hasExcludes() {
---------------
-------------
@@ -76,7 +76,7 @@
   }
 
   @Override
-  protected void validateDesiredSchema(Schema desiredSchema) throws UnsupportedTypeException {
+  protected void validateSchema(Schema desiredSchema) throws UnsupportedTypeException {
     // a valid schema is a record of simple types. In other words, no maps, arrays, records, unions, or enums allowed.
     // the exception is the very last field, which is allowed to be an array of simple types.
     // These types may be nullable, which is a union of a null and non-null type.
---------------
-------------
@@ -143,7 +143,7 @@
    * @param newValue value to set
    * @return true if compare and swap succeeded, false otherwise (stored value is different from expected)
    */
-  public boolean swap(byte[] key, byte[] oldValue, byte[] newValue) throws Exception {
+  public boolean compareAndSwap(byte[] key, byte[] oldValue, byte[] newValue) throws Exception {
     return this.table.compareAndSwap(key, KEY_COLUMN, oldValue, newValue);
   }
 
---------------
-------------
@@ -141,6 +141,8 @@
     if (zkClient != null && zkClient.isRunning()) {
       zkClient.stop();
     }
+
+    notifyStopped();
   }
 
   private ZKClientService getZkClientService(String zkConnectionString) {
---------------
-------------
@@ -94,7 +94,7 @@
     public void run() {
       LOG.info("Custom action run");
       try {
-        Thread.sleep(100);
+        Thread.sleep(2000);
       } catch (InterruptedException e) {
         e.printStackTrace();
       }
---------------
-------------
@@ -587,6 +587,7 @@
 
   @Override
   public void close(QueryHandle handle) throws ExploreException, HandleNotFoundException {
+    inactiveHandleCache.invalidate(handle);
     activeHandleCache.invalidate(handle);
   }
 
---------------
-------------
@@ -45,7 +45,7 @@
       String.format("procedure.%s.%s.%s",
                     accountId, applicationId, procedureName)).iterator().next();
 
-    URL url = new URL(String.format("http://%s:%d/apps/%s/procedures/%s/%s",
+    URL url = new URL(String.format("http://%s:%d/apps/%s/procedures/%s/methods/%s",
                       discoverable.getSocketAddress().getHostName(),
                       discoverable.getSocketAddress().getPort(),
                       applicationId,
---------------
-------------
@@ -141,6 +141,8 @@
     if (zkClient != null && zkClient.isRunning()) {
       zkClient.stop();
     }
+
+    notifyStopped();
   }
 
   private ZKClientService getZkClientService(String zkConnectionString) {
---------------
-------------
@@ -97,7 +97,7 @@
 
   // ex: /system/apps/appX/mapreduce/jobId/runs/897e3c92-f369-43de-94b1-7344ccf2fd13/mappers/process.entries.in
   @GET
-  @Path("/{scope}/{type}/{type-id}/{request-type}/{request-id}/{component-type}/runs/{run-id}/{metric}")
+  @Path("/{scope}/{type}/{type-id}/{request-type}/{request-id}/runs/{run-id}/{component-type}/{metric}")
   public void handleComponentTypeWithRunId(HttpRequest request, HttpResponder responder) throws IOException {
     handleRequest(request, responder);
   }
---------------
-------------
@@ -28,6 +28,9 @@
     return ois;
   }
 
+  /**
+   * Standard Union.
+   */
   public static class StandardUnion implements UnionObject {
     protected byte tag;
     protected Object object;
---------------
-------------
@@ -8,6 +8,9 @@
 import com.continuuity.api.data.dataset.KeyValueTable;
 import org.apache.hadoop.mapreduce.Job;
 
+/**
+ * The classic word count example.
+ */
 public final class ClassicWordCount implements MapReduce {
     @UseDataSet("jobConfig")
     private KeyValueTable table;
---------------
-------------
@@ -65,7 +65,7 @@
   public boolean nextKeyValue() throws IOException, InterruptedException {
     StreamEvent streamEvent;
     do {
-      if (reader.getPosition() >= inputSplit.getStart() + inputSplit.getLength()) {
+      if (reader.getPosition() - inputSplit.getStart() >= inputSplit.getLength()) {
         return false;
       }
 
---------------
-------------
@@ -81,7 +81,7 @@
     } else if (matches(uriParts, "v3", "system", "services", null, "logs")) {
       //Log Handler Path /v3/system/services/<service-id>/logs
       return Constants.Service.METRICS;
-    } else if ((uriParts.length >= 4) && uriParts[3].equals("streams")) {
+    } else if ((uriParts.length >= 4) && uriParts[1].equals("namespaces") && uriParts[3].equals("streams")) {
       //     /v3/namespaces/<namespace>/streams goes to AppFabricHttp
       //     /v3/namespaces/<namespace>/streams/<stream-id> PUT, POST should go to Stream Handler
       // GET /v3/namespaces/<namespace>/streams/<stream-id>/flows should go to AppFabricHttp
---------------
-------------
@@ -51,6 +51,11 @@
 
   @Override
   public Module getInMemoryModules() {
+    // Turning off assertions for Hive packages, since some assertions in StandardStructObjectInspector do not work
+    // when outer joins are run. It is okay to turn off Hive assertions since we assume Hive is a black-box that does
+    // the right thing, and we only want to test our/our user's code.
+    getClass().getClassLoader().setPackageAssertionStatus("org.apache.hadoop.hive", false);
+    getClass().getClassLoader().setPackageAssertionStatus("org.apache.hive", false);
     return Modules.combine(new ExploreExecutorModule(), new ExploreLocalModule(true));
   }
 
---------------
-------------
@@ -65,7 +65,8 @@
   }
 
   public boolean isVisible(long version) {
-    return version <= getReadPointer() && !isExcluded(version);
+    // either it was committed before or the change belongs to current tx
+    return (version <= getReadPointer() && !isExcluded(version)) || writePointer == version;
   }
 
   public boolean hasExcludes() {
---------------
-------------
@@ -205,7 +205,7 @@
             endSplitIdx = startSplitIdx + width;
           }
           // add any remaining part of the splitFieldLine string
-          if (startSplitIdx < splitFieldLine.length() - 1) {
+          if (startSplitIdx < splitFieldLine.length()) {
             cellLines.add(splitFieldLine.substring(startSplitIdx, splitFieldLine.length()));
           }
           multiLines = true;
---------------
-------------
@@ -118,7 +118,7 @@
   private static final Map<String, ImmutablePair<List<HttpMethod>, Pattern>> ALLOWED_PATHS =
       new  ImmutableMap.Builder<String, ImmutablePair<List<HttpMethod>, Pattern>>().
                 put(DEPLOY_PATH,
-                    new ImmutablePair<List<HttpMethod>, Pattern>(ImmutableList.of(HttpMethod.POST),
+                    new ImmutablePair<List<HttpMethod>, Pattern>(ImmutableList.of(HttpMethod.POST, HttpMethod.PUT),
                                                                  Pattern.compile(DEPLOY_PATH))).
                 put(DEPLOY_STATUS_PATH,
                     new ImmutablePair<List<HttpMethod>, Pattern>(ImmutableList.of(HttpMethod.GET),
---------------
-------------
@@ -33,10 +33,10 @@
 
 /**
  * Client for interacting with Local Reactor's app-fabric service to perform the following operations:
- * a) Deploy locally
- * b) Start/Stop/Status of flow in Local Reactor
- * c) Promote to cloud
- * d) Change number of instances of flowlet in Local Reactor
+ * a) Deploy app
+ * b) Start/Stop/Status of flow
+ * c) Promote app to cloud
+ * d) Scale number of flowlet instances
  * <p/>
  * Usage:
  * ReactorClient client = new ReactorClient();
---------------
-------------
@@ -45,7 +45,7 @@
       String.format("procedure.%s.%s.%s",
                     accountId, applicationId, procedureName)).iterator().next();
 
-    URL url = new URL(String.format("http://%s:%d/apps/%s/procedures/%s/%s",
+    URL url = new URL(String.format("http://%s:%d/apps/%s/procedures/%s/methods/%s",
                       discoverable.getSocketAddress().getHostName(),
                       discoverable.getSocketAddress().getPort(),
                       applicationId,
---------------
-------------
@@ -41,7 +41,7 @@
     lock.lock();
     try {
       final Discoverable wrapper = new DiscoverableWrapper(discoverable);
-      services.put(wrapper.getName(), discoverable);
+      services.put(wrapper.getName(), wrapper);
       return new Cancellable() {
         @Override
         public void cancel() {
---------------
-------------
@@ -203,7 +203,7 @@
       String message =
           String.format("Meta data entry for %s already exists.", entry);
       Log.debug(message);
-      throw new OperationException(StatusCode.ENTRY_EXISTS, message);
+      throw new OperationException(StatusCode.WRITE_CONFLICT, message);
     }
     if (isUpdate) {
       if (bytesRead == null) {
---------------
-------------
@@ -46,7 +46,7 @@
 public class EthnicityOntology extends AbstractSolrVocabulary
 {
     /**
-     * @param stringSearch part of full ethnicity name
+     * @param input part of full ethnicity name
      * @return set of strings that are full ethnicity names that match the partial string
      * @deprecated since 1.2M4 use {@link #search(String, int, String, String)} instead
      */
---------------
-------------
@@ -46,7 +46,7 @@
 public class EthnicityOntology extends AbstractSolrVocabulary
 {
     /**
-     * @param stringSearch part of full ethnicity name
+     * @param input part of full ethnicity name
      * @return set of strings that are full ethnicity names that match the partial string
      * @deprecated since 1.2M4 use {@link #search(String, int, String, String)} instead
      */
---------------
-------------
@@ -39,6 +39,7 @@
  * etc.
  * 
  * @version $Id$
+ * @since 1.0M8
  */
 @Component
 @Named("cmregistry")
---------------
-------------
@@ -587,7 +587,7 @@
       stripByteCounts[tileNumber] *= pixel;
     }
     int size = (int) (tileWidth * tileLength * pixel * effectiveChannels);
-   
+
     if (buf == null) buf = new byte[size];
     if (stripByteCounts[tileNumber] == 0 ||
       stripOffsets[tileNumber] >= in.length())
---------------
-------------
@@ -152,7 +152,7 @@
   /** Returns true if a byte buffer of the given size will fit in memory. */
   public static boolean canFitInMemory(long bufferSize) {
     Runtime r = Runtime.getRuntime();
-    long mem = r.freeMemory();
+    long mem = r.freeMemory() / 2;
     return bufferSize < mem;
   }
 
---------------
-------------
@@ -94,6 +94,7 @@
     }, desc = "Clears the inventory", usage = "[player]", flags = {
         @Flag(longName = "removeArmor", name = "ra")
     }, max = 1)
+    @SuppressWarnings("deprecation")
     public void clearinventory(CommandContext context)
     {
         User sender = context.getSenderAsUser();
---------------
-------------
@@ -37,7 +37,7 @@
     public static final File configDirectory = new File("bin/test/server/plugins/coretest/CubeCore");
     public static final File worldsDirectory = new File("bin/test/server");
     
-    @Test
+    //@Test
     public void setUp()
     {
         //TODO Das hier zum laufen bringen...
---------------
-------------
@@ -183,7 +183,7 @@
             consoleAppender.setLogger(((BukkitCore)CubeEngine.getCore()).getLogger());
             PatternLayout consoleLayout = new PatternLayout();
             consoleLayout.setContext(logger.getLoggerContext());
-            consoleLayout.setPattern("[" + module.getName() + "] color(%msg)");
+            consoleLayout.setPattern("[" + module.getName() + "] %color(%msg)");
             consoleAppender.setLayout(consoleLayout);
 
             // Setup the module's file logger
---------------
-------------
@@ -15,7 +15,6 @@
 import java.util.*;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.logging.Level;
-import org.bukkit.entity.Player;
 
 /**
  * Class to manage all the announcements and their receivers
---------------
-------------
@@ -75,7 +75,7 @@
     }
 
     public File temporaryConsoleFile(LocatableEntity locatableEntity) {
-        return new File("work/local", format("%s.log", DigestUtils.md5Hex(locatableEntity.entityLocator())));
+        return new File("data/console", format("%s.log", DigestUtils.md5Hex(locatableEntity.entityLocator())));
     }
 
 }
---------------
-------------
@@ -111,6 +111,7 @@
             List<? extends Property> propertyDefinitions = preference.getConfig().list();
             for (Property propertyDefinition : propertyDefinitions) {
                 ConfigurationProperty configuredProperty = configuration.getProperty(propertyDefinition.getKey());
+                if(configuredProperty == null) continue;
                 taskProperties.add(new TaskProperty(propertyDefinition.getOption(Property.DISPLAY_NAME), configuredProperty.getDisplayValue(), configuredProperty.getConfigKeyName()));
             }
             return taskProperties;
---------------
-------------
@@ -42,7 +42,7 @@
         return label;
     }
 
-    public static final Pattern PATTERN = Pattern.compile("(?i)\\$\\{([\\w\\.]+)(\\[:(\\d+)\\])?\\}");
+    public static final Pattern PATTERN = Pattern.compile("(?i)\\$\\{([a-zA-Z0-9_\\-\\.!~'#:]+)(\\[:(\\d+)\\])?\\}");
 
     private String replaceRevisionsInLabel(Map<CaseInsensitiveString, String> materialRevisions) {
         final Matcher matcher = PATTERN.matcher(this.label);
---------------
-------------
@@ -249,6 +249,8 @@
             return new ModelAndView(new ConsoleOutView(consoleOut.calculateNextStart(), consoleOut.output()));
         } catch (FileNotFoundException e) {
             return new ModelAndView(new ConsoleOutView(0, ""));
+        } catch (Exception e) {
+            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);
         }
     }
 
---------------
-------------
@@ -92,6 +92,7 @@
 
     @Override
     public void addExtraJarsToClasspath(String extraClasspath) {
+        extraClasspath = new StringBuilder(extraClasspath).append(",").append(systemEnvironment.configDir().getAbsoluteFile()).toString();
         webAppContext.setExtraClasspath(extraClasspath);
     }
 
---------------
-------------
@@ -36,7 +36,5 @@
     private void updateDefaults() {
         with(REQUIRED, true);
         with(SECURE, false);
-        with(DISPLAY_NAME, "");
-        with(DISPLAY_ORDER, 0);
     }
 }
---------------
-------------
@@ -401,7 +401,7 @@
 		String mutex = mutexForStageHistory(pipelineName, stageName);
 		readWriteLock.acquireReadLock(mutex);
 		try {
-			String subKey = String.format("%s-%s", pagination.getCurrentPage(), pagination.getPageSize());
+			String subKey = String.format("%s-%s", pagination.getOffset(), pagination.getPageSize());
 			String key = cacheKeyForDetailedStageHistories(pipelineName, stageName);
 			StageInstanceModels stageInstanceModels = (StageInstanceModels) goCache.get(key, subKey);
 			if (stageInstanceModels == null) {
---------------
-------------
@@ -85,7 +85,7 @@
             Constructor<?> constructor = Class.forName(databaseProvider).getConstructor(SystemEnvironment.class);
             return ((Database) constructor.newInstance(systemEnvironment));
         } catch (Exception e) {
-            throw new RuntimeException("could not locate database provider:" + databaseProvider);
+            throw new RuntimeException(String.format("Failed loading database provider [%s]", databaseProvider), e);
         }
     }
 
---------------
-------------
@@ -53,7 +53,7 @@
                 return uri.toString();
             }
         } catch (URISyntaxException e) {
-            throw new RuntimeException(e);
+            return sanitizedUrl;
         }
         return sanitizedUrl;
     }
---------------
-------------
@@ -53,7 +53,7 @@
                 return uri.toString();
             }
         } catch (URISyntaxException e) {
-            throw new RuntimeException(e);
+            return sanitizedUrl;
         }
         return sanitizedUrl;
     }
---------------
-------------
@@ -68,7 +68,7 @@
                     localePart = value.substring(0, spaceIndex);
                     timeZonePart = value.substring(spaceIndex + 1);
                 }
-                locale = (!"-".equals(localePart) ? StringUtils.parseLocaleString(localePart) : null);
+                locale = (!"-".equals(localePart) ? StringUtils.parseLocaleString(localePart.replace('-', '_')) : null);
                 if (timeZonePart != null) {
                     timeZone = StringUtils.parseTimeZoneString(timeZonePart);
                 }
---------------
-------------
@@ -127,7 +127,6 @@
         for(int i = 0; i < hostNames.size(); i++) {
             String hostName = hostNames.get(i);
             List<Integer> partitions = cluster.getNodeById(i).getPartitionIds();
-            Collections.sort(partitions);
 
             ClusterNodeDescriptor cnd = new ClusterNodeDescriptor();
             cnd.setHostName(hostName);
---------------
-------------
@@ -35,6 +35,7 @@
 
     public InconsistentDataException(String message, List<?> versions) {
         super(message);
+        this.versions = versions;
     }
 
     @Override
---------------
-------------
@@ -40,7 +40,7 @@
         this.queue = queue;
         this.storeName = storeName;
         this.adminClient = adminClient;
-        this.stopRequested.set(false);
+        this.stopRequested = new AtomicBoolean(false);
     }
 
     @Override
---------------
-------------
@@ -94,7 +94,7 @@
     public V getValue(K key, V defaultValue) {
         Versioned<V> versioned = get(key);
         if(versioned == null)
-            return null;
+            return defaultValue;
         else
             return versioned.getValue();
     }
---------------
-------------
@@ -244,7 +244,7 @@
 		Set<LexicalRule<? extends GermaNetInfo>> result = new HashSet<LexicalRule<? extends GermaNetInfo>>();
 		
 		// check POS is valid or not for GermaNet. Note that GermaNet only has noun, verb, and adjective.
-		if (!isValidPos(pos))
+		if ( pos != null && !isValidPos(pos))
 		{
 			// POS class that GermaNet knows not.  
 			// No need to look up, return an empty list.  
---------------
-------------
@@ -131,7 +131,7 @@
   public String getPrefixRundata() {
 
     if (isIndeterminedIndices())
-      return ".lane" + this.lane + ".read" + this.read;
+      return ".lane" + this.lane + ".undetermined.read" + this.read;
 
     return ".lane"
         + this.lane + ".sample." + this.sampleName + ".read" + this.read + "."
---------------
-------------
@@ -65,6 +65,8 @@
  * Down-stream applications may wish to further process the encoding for indexing or lookup purposes, for example, by
  * splitting on pipe (<code>|</code>) and indexing under each of these alternatives.
  *
+ * @see <a href="http://stevemorse.org/phonetics/bmpm.htm">Beider-Morse Phonetic Matching</a>
+ * @see <a href="http://stevemorse.org/phoneticinfo.htm">Reference implementation</a>
  * @since 1.6
  * @version $Id$
  */
---------------
-------------
@@ -1,3 +1,5 @@
+package soot.toolkits.purity;
+
 /**
  * This example is from the article A Combined Pointer and Purity Analysis for
  * Java Programs" by Alexandru Salcianu and Martin Rinard.
---------------
-------------
@@ -55,6 +55,7 @@
 			"-src-prec", "java",
 			"-output-format", "asm",
 			"-allow-phantom-refs",
+			"-keep-line-number",
 			"-java-version", getRequiredJavaVersion(),
 			getTargetClass()
 		});
---------------
-------------
@@ -58,7 +58,7 @@
     uploadRpm(reponame, multipartFile.getInputStream());
   }
 
-  @RequestMapping(value = "/{reponame}", method = DELETE)
+  @RequestMapping(value = "/{reponame:[a-zA-Z0-9-_.]*}", method = DELETE)
   @ResponseStatus(NO_CONTENT)
   public void deleteRepository(@PathVariable("reponame") String reponame) throws IOException {
     gridFs.deleteRepository(reponame);
---------------
-------------
@@ -3229,7 +3229,7 @@
         int beg = ts.tokenBeg;
         String s = ts.getString();
         int lineno = ts.lineno;
-        if (currentToken != Token.NAME) {
+        if (!"".equals(prevNameTokenString)) {
             beg = prevNameTokenStart;
             s = prevNameTokenString;
             lineno = prevNameTokenLineno;
---------------
-------------
@@ -333,7 +333,6 @@
                 lineno++;
                 sawEOL = true;
             } else {
-                sawEOL = false;
                 if (compilerEnv.isRecordingComments()) {
                     recordComment(lineno);
                 }
---------------
-------------
@@ -10,7 +10,7 @@
  * Copyright (c) 2012-2014 Nathanaël Jourdane.
  */
 
-package vue;
+package view;
 
 public class GLCBuilderGUI {
 	public static void main(String... args) {
---------------
-------------
@@ -63,7 +63,7 @@
   RequisitionGroup getByCode(String code);
 
   @Update("UPDATE requisition_groups " +
-    "SET code = #{code}, name = #{name}, description =  #{description}, supervisoryNodeId = #{supervisoryNode.id}, modifiedBy = #{modifiedBy}, modifiedDate = #{modifiedDate} " +
+    "SET code = #{code}, name = #{name}, description =  #{description}, supervisoryNodeId = #{supervisoryNode.id}, modifiedBy = #{modifiedBy}, modifiedDate = COALESCE(#{modifiedDate}, CURRENT_TIMESTAMP) " +
     "WHERE id = #{id}")
   void update(RequisitionGroup requisitionGroup);
 
---------------
-------------
@@ -267,6 +267,8 @@
 
     assertFalse("notesTextArea enabled.", notesTextArea.isEnabled());
 
+    assertFalse("Add new button enabled", addNewButton.isEnabled());
+    assertFalse("Delete button enabled", deleteButton.isEnabled());
   }
 
   public void clickProblemSinceLastVisitNoRadio() {
---------------
-------------
@@ -119,7 +119,7 @@
   @FindBy(how = XPATH, using = "//ng-include/div/ul/li[2]/a/span[@class='status-icon']")
   public static WebElement overallRefrigeratorIcon = null;
 
-  @FindBy(how = XPATH, using = "//div[@id='addRefrigeratorModal']/div[2]/div[3]/div/div")
+  @FindBy(how = ID, using = "duplicateSerialNumberError")
   public static WebElement duplicateRefrigeratorMessage = null;
 
   @FindBy(how = ID, using = "noRefrigerators")
---------------
-------------
@@ -21,7 +21,7 @@
   protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) {
     Order order = (Order) model.get(ORDER);
 
-    String fileName = "O" + System.currentTimeMillis() + ".csv";
+    String fileName = "O" + order.getId() + ".csv";
     response.setHeader("Content-Disposition", "attachment; filename=" + fileName);
 
     try (BufferedWriter writer = new BufferedWriter(response.getWriter())) {
---------------
-------------
@@ -83,7 +83,7 @@
     Map<String, String> validationErrorMessages = new HashMap<>();
     for (Map.Entry<String, OpenLmisMessage> entry : validationErrors.entrySet()) {
       String fieldName = entry.getKey();
-      validationErrorMessages.put(fieldName, messageService.message(entry.getValue()));
+      validationErrorMessages.put(fieldName, messageService.message(entry.getValue().getCode(), entry.getValue().getParams()));
     }
     return validationErrorMessages;
   }
---------------
-------------
@@ -37,7 +37,7 @@
   }
 
   public List<Program> getByFacility(Integer facilityId) {
-    return programMapper.getActiveByFacility(facilityId);
+    return programMapper.getByFacilityId(facilityId);
   }
 
   public List<Program> getAll() {
---------------
-------------
@@ -33,6 +33,7 @@
     CamelContext context = new DefaultCamelContext();
     ProducerTemplate template = context.createProducerTemplate();
     template.sendBodyAndHeader(createFtpUri(supplyingFacility), file, Exchange.FILE_NAME, file.getName());
+
   }
 
   private String createFtpUri(FacilityFtpDetails supplyingFacility) {
---------------
-------------
@@ -91,7 +91,7 @@
       order = new Order(rnr);
       SupplyLine supplyLine = supplyLineService.getSupplyLineBy(new SupervisoryNode(rnr.getSupervisoryNodeId()), rnr.getProgram());
       order.setSupplyLine(supplyLine);
-      if (!fulfillmentPermissionService.hasPermission(userId, supplyLine.getSupplyingFacility().getId(), Right.CONVERT_TO_ORDER)) {
+      if (!fulfillmentPermissionService.hasPermissionOnWarehouse(userId, supplyLine.getSupplyingFacility().getId(), Right.CONVERT_TO_ORDER)) {
         throw new AccessDeniedException("user.not.authorized");
       }
       OrderStatus status;
---------------
-------------
@@ -111,7 +111,7 @@
   }
 
   public void clickInitiateDistribution() {
-    testWebDriver.waitForElementToAppear(initiateDistributionButton);
+    testWebDriver.waitForElementToBeEnabled(initiateDistributionButton);
     initiateDistributionButton.click();
   }
 
---------------
-------------
@@ -137,7 +137,7 @@
     isAddedBy = commentAddedBy.getText().contains("By: " + AddedBy);
     assertTrue(isAddedBy);
     Date date = new Date();
-    SimpleDateFormat ft = new SimpleDateFormat("dd/MM/YYYY");
+    SimpleDateFormat ft = new SimpleDateFormat("dd/MM/yyyy");
     isAddedOn = commentAddedBy.getText().contains(ft.format(date));
     assertTrue(isAddedOn);
     commentCloseIcon.click();
---------------
-------------
@@ -56,7 +56,7 @@
     try {
       report.validateForApproval();
       restRequisitionService.approve(report, requisitionId, loggedInUserId(principal));
-      return success("msg.rnr.approve.success");
+      return success("msg.rnr.approved.success");
     } catch (DataException e) {
       return error(e.getOpenLmisMessage(), BAD_REQUEST);
     }
---------------
-------------
@@ -97,7 +97,7 @@
     {
         testWebDriver.waitForElementToAppear(requisitionHeader);
         String headerText=testWebDriver.getText(requisitionHeader);
-        //SeleneseTestNgHelper.assertTrue(headerText.contains("Report and Requisition for "+program));
+        SeleneseTestNgHelper.assertTrue(headerText.contains("Report and Requisition for "+program));
         String facilityText=testWebDriver.getText(facilityLabel);
         SeleneseTestNgHelper.assertTrue(facilityText.contains(FCode + FCstring + " - " + FName + FCstring));
 
---------------
-------------
@@ -109,7 +109,7 @@
             return new ResponseEntity<ModelMap>(modelMap, HttpStatus.BAD_REQUEST);
         }
         modelMap.put("facility", facility);
-        modelMap.put("success", facility.getName() + " / " + facility.getCode() +" "+ message + " successfully");
+        modelMap.put("success", "\"" + facility.getName() + "\" / \"" + facility.getCode() +"\" "+ message + " successfully");
         return new ResponseEntity<ModelMap>(modelMap, HttpStatus.OK);
     }
 
---------------
-------------
@@ -114,7 +114,7 @@
     } else if (csvFile == null || csvFile.isEmpty()) {
       errorMessage = new OpenLmisMessage(FILE_IS_EMPTY);
     } else if (!csvFile.getOriginalFilename().endsWith(".csv")) {
-      errorMessage = new OpenLmisMessage(INCORRECT_FILE_FORMAT, model);
+      errorMessage = new OpenLmisMessage(messageService.message(INCORRECT_FILE_FORMAT, uploadBeansMap.get(model).getDisplayName()));
     }
     return errorMessage;
   }
---------------
-------------
@@ -80,7 +80,7 @@
     client.createContext();
 
     Report reportFromJson = readObjectFromFile(FULL_JSON_APPROVE_TXT_FILE_NAME, Report.class);
-    reportFromJson.setUserId("commTrack1");
+    reportFromJson.setUserName("commTrack1");
     reportFromJson.setRequisitionId(id);
     reportFromJson.getProducts().get(0).setProductCode("P10");
     reportFromJson.getProducts().get(0).setQuantityApproved(quantityApproved);
---------------
-------------
@@ -767,6 +767,7 @@
   }
 
   private void verifyElementsPresent() {
+    distributionPage = PageFactory.getInstanceOfDistributionPage(testWebDriver);
     assertTrue("selectDeliveryZoneSelectBox should be present", distributionPage.IsDisplayedSelectDeliveryZoneSelectBox());
     assertTrue("selectProgramSelectBox should be present", distributionPage.IsDisplayedSelectProgramSelectBox());
     assertTrue("selectPeriodSelectBox should be present", distributionPage.IsDisplayedSelectPeriodSelectBox());
---------------
-------------
@@ -42,7 +42,7 @@
   private Integer calculateTargetGroup(Double whoRatio, Long catchmentPopulation) {
     Integer targetGroup = null;
     if (whoRatio != null && catchmentPopulation != null) {
-      targetGroup = (int) round(catchmentPopulation * whoRatio);
+      targetGroup = (int) round(catchmentPopulation * whoRatio / 100);
     }
     return targetGroup;
   }
---------------
-------------
@@ -58,7 +58,7 @@
          * @return builder
          */
         public Builder addAllSkills(Collection<String> skills){
-            for(String skill : skills) this.skills.add(skill);
+            for(String skill : skills) addSkill(skill);
             return this;
         }
 
---------------
-------------
@@ -9,7 +9,7 @@
 
     public static final String PATTERN = "yyyy-MM-dd HH:mm:ss.SSS";
 
-    public static DateAssert assertThat(DateTime date) {
+    public static DateAssert assertTime(DateTime date) {
         return new DateAssert(DateAssert.class, date);
     }
 
---------------
-------------
@@ -698,7 +698,7 @@
 			// Nothing in Index
 			// At least one of Head, Index, Merge is not empty
 			// make sure not to overwrite untracked files
-			if (f != null) {
+			if (f != null && !f.isEntryIgnored()) {
 				// A submodule is not a file. We should ignore it
 				if (!FileMode.GITLINK.equals(mMode)) {
 					// a dirty worktree: the index is empty but we have a
---------------
-------------
@@ -243,6 +243,8 @@
 					return contentId = i.idBuffer();
 				}
 				contentIdOffset = 0;
+			} else {
+				contentIdOffset = 0;
 			}
 		}
 		switch (mode & FileMode.TYPE_MASK) {
---------------
-------------
@@ -481,7 +481,7 @@
 	 * @throws IOException
 	 */
 	public void packRefs() throws IOException {
-		Collection<Ref> refs = repo.getRefDatabase().getRefs(ALL).values();
+		Collection<Ref> refs = repo.getRefDatabase().getRefs(Constants.R_REFS).values();
 		List<String> refsToBePacked = new ArrayList<String>(refs.size());
 		pm.beginTask(JGitText.get().packRefs, refs.size());
 		try {
---------------
-------------
@@ -265,7 +265,7 @@
 		File gitdir = createUniqueTestGitDir(bare);
 		FileRepository db = new FileRepository(gitdir);
 		assertFalse(gitdir.exists());
-		db.create();
+		db.create(bare);
 		toClose.add(db);
 		return db;
 	}
---------------
-------------
@@ -186,6 +186,7 @@
 							.setMessage(newMessage)
 							.setReflogComment("revert: " + shortMessage).call(); //$NON-NLS-1$
 					revertedRefs.add(src);
+					headCommit = newHead;
 				} else {
 					unmergedPaths = merger.getUnmergedPaths();
 					Map<String, MergeFailureReason> failingPaths = merger
---------------
-------------
@@ -221,7 +221,7 @@
 				builder = null;
 			}
 
-			if (getUnmergedPaths().isEmpty()) {
+			if (getUnmergedPaths().isEmpty() && !failed()) {
 				resultTree = dircache.writeTree(getObjectInserter());
 				return true;
 			} else {
---------------
-------------
@@ -280,8 +280,6 @@
 					ConfigConstants.CONFIG_KEY_BARE, true);
 		cfg.setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null,
 				ConfigConstants.CONFIG_KEY_LOGALLREFUPDATES, !bare);
-		cfg.setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null,
-				ConfigConstants.CONFIG_KEY_AUTOCRLF, false);
 		cfg.save();
 	}
 
---------------
-------------
@@ -390,7 +390,7 @@
 				if (e != null)
 					toBeCheckedOut.put(tw.getPathString(), e);
 				return true;
-			} else if (modeT == 0) {
+			} else if ((modeT == 0) && (modeB != 0)) {
 				// we want THEIRS ... but THEIRS contains the deletion of the
 				// file
 				toBeCheckedOut.put(tw.getPathString(), null);
---------------
-------------
@@ -577,7 +577,7 @@
 		// directories are always lazily created. Note that we
 		// try the rename first as the directory likely does exist.
 		//
-		FileUtils.mkdir(dst.getParentFile());
+		FileUtils.mkdir(dst.getParentFile(), true);
 		if (tmp.renameTo(dst)) {
 			dst.setReadOnly();
 			unpackedObjectCache.add(id);
---------------
-------------
@@ -509,7 +509,7 @@
 						done = k;
 						break;
 					default:
-						rev = rw.parseAny(rev);
+						rev = rw.peel(rev);
 						if (rev instanceof RevCommit) {
 							RevCommit commit = ((RevCommit) rev);
 							if (commit.getParentCount() == 0)
---------------
-------------
@@ -455,7 +455,7 @@
           if(constructor == null) {
             binder.bind(assistedReturnType).to((Key)returnType);
           } else {
-            binder.bind(assistedReturnType).toConstructor((Constructor)constructor);
+            binder.bind(assistedReturnType).toConstructor((Constructor)constructor, (TypeLiteral)returnType.getTypeLiteral());
           }
         }
       }
---------------
-------------
@@ -40,7 +40,10 @@
       T t = injector.callInContext(new ContextualCallable<T>() {
         public T call(InternalContext context) throws ErrorsException {
           Dependency dependency = context.getDependency();
-          return internalFactory.get(errors, context, dependency, false);
+          // Always pretend that we are a linked binding, to support
+          // scoping implicit bindings.  If we are not actually a linked
+          // binding, we'll fail properly elsewhere in the chain.
+          return internalFactory.get(errors, context, dependency, true);
         }
       });
       errors.throwIfNewErrors(0);
---------------
-------------
@@ -156,7 +156,7 @@
 			logger.info("Extracting rules for sentence " + (i+1) + ".");
 			long startTime1 = System.currentTimeMillis();
 			{
-				ParallelCorpusGrammarFactory parallelCorpus = new ParallelCorpusGrammarFactory(sourceSuffixArray, targetSuffixArray, alignments, null, ruleSampleSize, maxPhraseSpan, maxPhraseLength, maxNonterminals, minNonterminalSpan, Float.MIN_VALUE, JoshuaConfiguration.phrase_owner, JoshuaConfiguration.default_non_terminal, JoshuaConfiguration.oovFeatureCost);
+				ParallelCorpusGrammarFactory parallelCorpus = new ParallelCorpusGrammarFactory(sourceSuffixArray, targetSuffixArray, alignments, null, ruleSampleSize, maxPhraseSpan, maxPhraseLength, maxNonterminals, minNonterminalSpan, Float.MIN_VALUE, JoshuaConfiguration.phrase_owner, JoshuaConfiguration.default_non_terminal, JoshuaConfiguration.oov_feature_cost);
 
 //				PrefixTree prefixTree = new PrefixTree(sourceSuffixArray, targetCorpusArray, alignments, sourceSuffixArray.getVocabulary(), lexProbs, ruleExtractor, maxPhraseSpan, maxPhraseLength, maxNonterminals, minNonterminalSpan);
 				PrefixTree prefixTree = new PrefixTree(parallelCorpus);
---------------
-------------
@@ -267,7 +267,7 @@
 	 */
 	public boolean removeTeamMember(User u)
 	{
-		if(!team.contains(u))
+		if(team.contains(u))
 		{
 			team.remove(u);
 			return true;
---------------
-------------
@@ -79,7 +79,7 @@
 		getBoxIteration().setText(displayRequirement.getIteration());
 		getBoxEstimate().setText(String.valueOf(displayRequirement.getEstimate()));
 		getBoxReleaseNum().setText(displayRequirement.getRelease());
-		getDropdownStatus().setSelectedItem(displayRequirement.getStatus());
+		getDropdownStatus().setSelectedItem(displayRequirement.getParent().getStatus());
 		getDropdownType().setSelectedItem(displayRequirement.getType());
 		
 		switch(displayRequirement.getPriority())
---------------
-------------
@@ -46,7 +46,7 @@
 		 
 		 // for all other attributes: instantiate as null, fill in if given.
 		 
-		 int idNum = deflated.getAsInt();
+		 int idNum = deflated.get("idNum").getAsInt();
 		 String username = null;
 		 String name = null;
 		 
---------------
-------------
@@ -143,7 +143,7 @@
    */
   public void seekToYear(String year) {
     int yearInt = Integer.parseInt(year);
-    assert(yearInt > 0 && yearInt < 9999);
+    assert(yearInt >= 0 && yearInt < 9999);
     
     markDateInvocation();
     
---------------
-------------
@@ -173,7 +173,7 @@
 
     public FieldDefinition getFieldDefinitionByName(String name) {
         for (FieldDefinition fd : this.fields) {
-            if (fd.getFieldName().equals(name)) {
+            if (name.equals(fd.getFieldName())) {
                 return fd;
             }
         }
---------------
-------------
@@ -42,7 +42,7 @@
 
 		String colorAsString = properties.getProperty(prefix);
 		if (colorAsString == null) {
-			return DEFAULT_COLOR;
+			return null;
 		} else {
 			return asColor(colorAsString);
 		}
---------------
-------------
@@ -459,7 +459,7 @@
                 list.add(word);
             }
         }
-        if (tempWord != null) {
+        if (tempWord != null && !list.isEmpty()) {
             String tmp = list.get(list.size() - 1) + tempWord;
             list.add(tmp);
         }
---------------
-------------
@@ -231,6 +231,9 @@
         sb.append(txt);
         for (Evidence e : ec.iterator(confidenceFilter)) {
             String value = e.getValue();
+            
+            //hack to get around the fact that lucene does a realy good job of recognizing domains and not
+            // splitting them. TODO - put together a better lucene analyzer specific to the domain.
             if (value.startsWith("http://")) {
                 value = value.substring(7).replaceAll("\\.", " ");
             }
---------------
-------------
@@ -459,7 +459,7 @@
                 list.add(word);
             }
         }
-        if (tempWord != null) {
+        if (tempWord != null && !list.isEmpty()) {
             String tmp = list.get(list.size() - 1) + tempWord;
             list.add(tmp);
         }
---------------
-------------
@@ -231,6 +231,9 @@
         sb.append(txt);
         for (Evidence e : ec.iterator(confidenceFilter)) {
             String value = e.getValue();
+            
+            //hack to get around the fact that lucene does a realy good job of recognizing domains and not
+            // splitting them. TODO - put together a better lucene analyzer specific to the domain.
             if (value.startsWith("http://")) {
                 value = value.substring(7).replaceAll("\\.", " ");
             }
---------------
-------------
@@ -410,7 +410,7 @@
     	// Context will do our recursive parsing and initial IRI resolution
     	context = context.parse(contextLike);
     	// And then leak to us the potential 'prefixes'
-    	Map<String, String> prefixes = context.getPrefixes(false);
+    	Map<String, String> prefixes = context.getPrefixes(true);
     	
         for (final String key : prefixes.keySet()) {
             final String val = prefixes.get(key);
---------------
-------------
@@ -115,7 +115,7 @@
 
     public SuiteTagMatcher(String suiteTags, boolean matchIfNoTags, boolean andStrategy) {
       tagString = suiteTags;
-      if (suiteTags != null) {
+      if (StringUtils.isNotBlank(suiteTags)) {
         tags = Arrays.asList(suiteTags.split(LIST_SEPARATOR));
       }
       else {
---------------
-------------
@@ -4,6 +4,6 @@
 
 public class FitNesseVersion {
 	public String toString() {
-		return "v20090918";
+		return "v20090930";
 	}
 }
---------------
-------------
@@ -26,6 +26,7 @@
     addTableType("query:", QueryTable.class);
     addTableType("table:", TableTable.class);
     addTableType("script", ScriptTable.class);
+    addTableType("script:", ScriptTable.class);
     addTableType("scenario", ScenarioTable.class);
     addTableType("import", ImportTable.class);
     addTableType("library", LibraryTable.class);
---------------
-------------
@@ -9,7 +9,7 @@
 import static fitnesse.slim.SlimServer.*;
 
 public class SlimExceptionResult implements ExceptionResult {
-  public static final Pattern EXCEPTION_MESSAGE_PATTERN = Pattern.compile("^message:<<(.*)>>$", Pattern.DOTALL);
+  public static final Pattern EXCEPTION_MESSAGE_PATTERN = Pattern.compile("message:<<(.*)>>", Pattern.DOTALL);
 
   private final String resultKey;
   private final String exceptionValue;
---------------
-------------
@@ -26,6 +26,7 @@
     addTableType("query:", QueryTable.class);
     addTableType("table:", TableTable.class);
     addTableType("script", ScriptTable.class);
+    addTableType("script:", ScriptTable.class);
     addTableType("scenario", ScenarioTable.class);
     addTableType("import", ImportTable.class);
     addTableType("library", LibraryTable.class);
---------------
-------------
@@ -46,7 +46,7 @@
 	public void doSending(Response response) throws Exception
 	{
 		response.readyToSend(this);
-		waitForClose(50000);
+		waitForClose(5000);
 	}
 
 	// Utility method that returns when this.closed is true. Throws an exception
---------------
-------------
@@ -7,7 +7,7 @@
     
     public Comment() {
         super("Comment");
-        wikiMatcher(new Matcher().startLine().string("#"));
+        wikiMatcher(new Matcher().startLineOrCell().string("#"));
         wikiRule(this);
         htmlTranslation(this);
     }
---------------
-------------
@@ -33,7 +33,7 @@
   public String testResultsDirectoryName = "testResults";
   public boolean shouldCollectHistory = false;
   public boolean doNotChunk;
-  public String pageTheme = "straight";
+  public String pageTheme = "fitnesse_straight";
 
   public FitNesseContext() {
     this(null);
---------------
-------------
@@ -21,6 +21,12 @@
         return calculateProfit(series, trade);
     }
 
+	/**
+	 * Calculates the profit of a trade (Buy and sell).
+	 * @param series a time series
+	 * @param trade a trade
+	 * @return the profit of the trade
+	 */
     private double calculateProfit(TimeSeries series, Trade trade) {
         double exitClosePrice = series.getTick(trade.getExit().getIndex()).getClosePrice();
         double entryClosePrice = series.getTick(trade.getEntry().getIndex()).getClosePrice();
---------------
-------------
@@ -102,7 +102,7 @@
     if (rawStatus.getStatus() != Measure.Level.OK) {
       // There were no defined alerts before, so this one is a new one
       createEvent(project, rawStatus.getStatus().getColorName(), rawStatus.getText());
-      // notifyUsers(project, alertName, alertText, alertLevel, true);
+      notifyUsers(project, rawStatus.getStatus().getColorName(), rawStatus, true);
     }
   }
 
---------------
-------------
@@ -1,3 +1,22 @@
+/*
+ * SonarQube, open source software quality management tool.
+ * Copyright (C) 2008-2014 SonarSource
+ * mailto:contact AT sonarsource DOT com
+ *
+ * SonarQube is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * SonarQube is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
 package org.sonar.server.log.index;
 
 import org.elasticsearch.action.search.SearchResponse;
---------------
-------------
@@ -44,7 +44,7 @@
     final long now = system.now();
 
     MassUpdate massUpdate = context.prepareMassUpdate();
-    massUpdate.select("SELECT i.created_at, i.updated_at, i.issue_change_creation_date_ms, i.id FROM issue_changes i WHERE created_at_ms IS NULL");
+    massUpdate.select("SELECT i.created_at, i.updated_at, i.issue_change_creation_date, i.id FROM issue_changes i WHERE created_at_ms IS NULL");
     massUpdate.update("UPDATE issue_changes SET created_at_ms=?, updated_at_ms=?, issue_change_creation_date_ms=? WHERE id=?");
     massUpdate.rowPluralName("issue_changes");
     massUpdate.execute(new MassUpdate.Handler() {
---------------
-------------
@@ -122,7 +122,6 @@
       for (Map.Entry<String, String> entry : properties.entrySet()) {
         mapper.deleteGlobalProperty(entry.getKey());
       }
-      session.commit();//required for postgresql bulk inserts (?)
       for (Map.Entry<String, String> entry : properties.entrySet()) {
         mapper.insert(new PropertyDto().setKey(entry.getKey()).setValue(entry.getValue()));
       }
---------------
-------------
@@ -30,7 +30,7 @@
   public static final String ID = "h2";
 
   public H2() {
-    super(ID, "h2", "org.h2.Driver", "true", "false", "SELECT 1");
+    super(ID, ".h2.", "org.h2.Driver", "true", "false", "SELECT 1");
   }
 
   public Class<? extends org.hibernate.dialect.Dialect> getHibernateDialectClass() {
---------------
-------------
@@ -168,7 +168,7 @@
   }
 
   private boolean isAfter(Violation violation, Date date) {
-    return !violation.getCreatedAt().before(date);
+    return violation.getCreatedAt()!= null && violation.getCreatedAt().after(date);
   }
 
   private Metric getMetricForSeverity(RulePriority severity) {
---------------
-------------
@@ -68,7 +68,7 @@
       result.addProperty("error", condition.getErrorThreshold());
     }
     result.addProperty("actual", evaluatedCondition.getActualValue());
-    result.addProperty(FIELD_LEVEL, level.toString());
+    result.addProperty(FIELD_LEVEL, evaluatedCondition.getLevel().name());
     return result;
   }
 
---------------
-------------
@@ -77,7 +77,7 @@
 
     Optional<AlertStatus> previousQGStatus = parse(previousMeasure.get().getAlertStatus());
     if (!previousQGStatus.isPresent()) {
-      LOGGER.warn("Previous alterStatus for project %s is not a supported value. Can not compute Quality Gate event");
+      LOGGER.warn(String.format("Previous alterStatus for project %s is not a supported value. Can not compute Quality Gate event", project.getKey()));
       checkNewQualityGate(project, currentStatus, alertText);
       return;
     }
---------------
-------------
@@ -36,7 +36,7 @@
 public class BulkRuleActivationActions implements ServerComponent {
 
   public static final String PROFILE_KEY = "profile_key";
-  public static final String SEVERITY = "severity";
+  public static final String SEVERITY = "activation_severity";
 
   public static final String BULK_ACTIVATE_ACTION = "activate_rules";
   public static final String BULK_DEACTIVATE_ACTION = "deactivate_rules";
---------------
-------------
@@ -210,6 +210,8 @@
       esSearch.addSort(SortBuilders.scoreSort());
     } else {
       esSearch.addSort(RuleNormalizer.RuleField.UPDATED_AT.key(), SortOrder.DESC);
+      // deterministic sort when exactly the same updated_at (same millisecond)
+      esSearch.addSort(RuleNormalizer.RuleField.KEY.key(), SortOrder.ASC);
     }
 
     /* integrate Option's Pagination */
---------------
-------------
@@ -156,7 +156,7 @@
         }
         actions.add("plan");
         if (UserSession.get().hasProjectPermission(UserRole.ISSUE_ADMIN, issue.projectKey())) {
-          actions.add("severity");
+          actions.add("set_severity");
         }
         for (Action action : actionService.listAvailableActions(issue)) {
           actions.add(action.key());
---------------
-------------
@@ -161,7 +161,7 @@
   }
 
   private boolean isSameLine(Violation newViolation, RuleFailureModel pastViolation) {
-    return pastViolation.getLine() == newViolation.getLineId();
+    return pastViolation.getLine() == newViolation.getLineId(); //When lines are null, we also return true
   }
 
   private boolean isSameMessage(Violation newViolation, RuleFailureModel pastViolation) {
---------------
-------------
@@ -94,7 +94,7 @@
   }
 
   protected String exportPmdRulesetToXml(PmdRuleset pmdRuleset) {
-    Element eltRuleset = new Element("resultset");
+    Element eltRuleset = new Element("ruleset");
     for (PmdRule pmdRule : pmdRuleset.getPmdRules()) {
       Element eltRule = new Element("rule");
       addAttribute(eltRule, "ref", pmdRule.getRef());
---------------
-------------
@@ -151,7 +151,7 @@
   }
 
   private void mapRulePriority(Map<String, RulePriority> prioritiesByRule, RulePriority priority, String key) {
-    if (prioritiesByRule.containsKey(key)) {
+    if (prioritiesByRule.containsKey(key) && prioritiesByRule.get(key) != null) {
       if (prioritiesByRule.get(key).compareTo(priority) < 0) {
         prioritiesByRule.put(key, priority);
       }
---------------
-------------
@@ -50,7 +50,7 @@
 
   @Override
   public boolean execute(Map<String, Object> properties, Context context) {
-    return issueUpdater.setSeverity((DefaultIssue) context.issue(), severity(properties), context.issueChangeContext());
+    return issueUpdater.setManualSeverity((DefaultIssue) context.issue(), severity(properties), context.issueChangeContext());
   }
 
   private String severity(Map<String, Object> properties) {
---------------
-------------
@@ -47,6 +47,8 @@
     // See Ruby on Rails url_for
     System.setProperty("org.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH", "true");
 
+    System.setProperty("org.apache.catalina.startup.EXIT_ON_INIT_FAILURE", "true");
+
     // Required for webapp and logback xml files
     System.setProperty("SONAR_HOME", env.rootDir().getAbsolutePath());
 
---------------
-------------
@@ -1,3 +1,22 @@
+/*
+ * SonarQube, open source software quality management tool.
+ * Copyright (C) 2008-2014 SonarSource
+ * mailto:contact AT sonarsource DOT com
+ *
+ * SonarQube is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * SonarQube is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
 package org.sonar.process;
 
 public interface ProcessMXBean {
---------------
-------------
@@ -141,7 +141,7 @@
     processBuilder.environment().putAll(properties);
     processBuilder.environment().put(Process.NAME_PROPERTY, this.getName());
     processBuilder.environment().put(Process.PORT_PROPERTY, Integer.toString(port));
-    System.out.println("processBuilder.toString(); = " + processBuilder.toString());
+
     try {
       java.lang.Process process = processBuilder.start();
       errorGobbler = new StreamGobbler(process.getErrorStream(), this.getName() + "-ERROR");
---------------
-------------
@@ -495,7 +495,7 @@
 
         List<String[]> indicesList = new ArrayList<>(whereClauses.size());
         for (WhereClause whereClause : whereClauses) {
-            String[] indices = indices(tableInfo, whereClauses.get(0));
+            String[] indices = indices(tableInfo, whereClause);
             if (indices.length > 0) {
                 if (!whereClause.hasQuery() && tableInfo.isPartitioned()) {
                     plan.add(new ESDeletePartitionNode(indices));
---------------
-------------
@@ -103,7 +103,7 @@
         try {
             if (hasBulkParams()) {
                 // already did a type guess so it is possible to create a literal directly
-                return newLiteral(bulkTypes[index], bulkParameters[currentIdx][index]);
+                return newLiteral(bulkTypes[index], bulkTypes[index].value(bulkParameters[currentIdx][index]));
             }
             DataType type = guessTypeSafe(parameters[index]);
             // use type.value because some types need conversion (String to BytesRef, List to Array)
---------------
-------------
@@ -24,7 +24,7 @@
 
     @Override
     public boolean isEmpty() {
-        return limit == 0 && collection.isEmpty();
+        return limit == 0 || collection.isEmpty();
     }
 
     @Override
---------------
-------------
@@ -230,6 +230,7 @@
                 if (compare < 0) {
                     leastBi = bi;
                     leastRow = row;
+                    bucketsWithRowEqualToLeast.clear();
                 } else if (compare == 0) {
                     bucketsWithRowEqualToLeast.add(bi);
                 }
---------------
-------------
@@ -256,7 +256,7 @@
             Map<String, Object> columnProperties = (Map) columnEntry.getValue();
             DataType columnDataType = getColumnDataType(columnEntry.getKey(), columnIdent, columnProperties);
 
-            if (columnDataType == DataType.OBJECT) {
+            if (columnDataType == DataType.OBJECT || columnDataType == DataType.OBJECT_ARRAY) {
                 ReferenceInfo.ObjectType objectType =
                         ReferenceInfo.ObjectType.of(columnProperties.get("dynamic"));
                 ColumnIdent newIdent = childIdent(columnIdent, columnEntry.getKey());
---------------
-------------
@@ -42,7 +42,7 @@
         .add(new UnassignedShardCollectorExpression<Boolean>(ShardPrimaryExpression.NAME) {
             @Override
             public Boolean value() {
-                return false;
+                return null;
             }
         })
         .add(new UnassignedShardCollectorExpression<BytesRef>(ShardRelocatingNodeExpression.NAME) {
---------------
-------------
@@ -155,7 +155,7 @@
 
     @Override
     public void finishProjection() {
-        int resultSize = pq.size() - start;
+        final int resultSize = Math.max(pq.size() - start, 0);
         if (downStream.isPresent()) {
             // pass rows to downStream
             Projector projector = downStream.get();
---------------
-------------
@@ -24,7 +24,7 @@
 
     @Override
     public boolean isEmpty() {
-        return limit == 0 && collection.isEmpty();
+        return limit == 0 || collection.isEmpty();
     }
 
     @Override
---------------
-------------
@@ -495,7 +495,7 @@
 
         List<String[]> indicesList = new ArrayList<>(whereClauses.size());
         for (WhereClause whereClause : whereClauses) {
-            String[] indices = indices(tableInfo, whereClauses.get(0));
+            String[] indices = indices(tableInfo, whereClause);
             if (indices.length > 0) {
                 if (!whereClause.hasQuery() && tableInfo.isPartitioned()) {
                     plan.add(new ESDeletePartitionNode(indices));
---------------
-------------
@@ -63,7 +63,7 @@
 
                 @Override
                 public void onFailure(@Nonnull Throwable t) {
-                    throw new TaskExecutionException(AbstractChainedTask.this, t);
+                    result.setException(t);
                 }
             });
         } else {
---------------
-------------
@@ -103,7 +103,7 @@
         try {
             if (hasBulkParams()) {
                 // already did a type guess so it is possible to create a literal directly
-                return newLiteral(bulkTypes[index], bulkParameters[currentIdx][index]);
+                return newLiteral(bulkTypes[index], bulkTypes[index].value(bulkParameters[currentIdx][index]));
             }
             DataType type = guessTypeSafe(parameters[index]);
             // use type.value because some types need conversion (String to BytesRef, List to Array)
---------------
-------------
@@ -47,7 +47,7 @@
 
     @Override
     public Symbol visitReference(Reference symbol, Void context) {
-        if (symbol.info().granularity() != granularity) {
+        if (symbol.info().granularity().ordinal() > granularity.ordinal()) {
             return symbol;
         }
 
---------------
-------------
@@ -206,7 +206,7 @@
             "  details object(ignored) as (" +
             "    num_pages integer" +
             "  )" +
-            ")");
+            ") with (number_of_replicas = 0)");
         transportExecutor.exec("insert into ot (title, author, details) values (?, ?, ?)",
             new Object[]{
                 "The Hitchhiker's Guide to the Galaxy",
---------------
-------------
@@ -33,6 +33,8 @@
                 subList.add(parseSubArray(context, parser));
             } else if (token == XContentParser.Token.START_OBJECT) {
                 subList.add(parser.map());
+            } else if (token == XContentParser.Token.VALUE_NULL) {
+                subList.add(null);
             } else {
                 throw new SQLParseSourceException(context, "Field [" + parser.currentName() + "] has an invalid value");
             }
---------------
-------------
@@ -94,7 +94,7 @@
 
                     if (expectedType == DataTypes.NULL) {
                         bulkTypes[i] = guessedType;
-                    } else if (!bulkTypes[i].equals(guessedType)) {
+                    } else if (o != null && !bulkTypes[i].equals(guessedType)) {
                         throw new IllegalArgumentException(String.format(Locale.ENGLISH,
                                 "argument %d of bulk arguments contains mixed data types", i + 1));
                     }
---------------
-------------
@@ -146,6 +146,7 @@
             for (String s : ident.path()) {
                 builder.add(s);
             }
+            builder.add(name);
             return new ColumnIdent(ident.name(), builder.build());
         }
     }
---------------
-------------
@@ -190,6 +190,8 @@
             for (String node : downStreamNodes) {
                 out.writeString(node);
             }
+        } else {
+            out.writeVInt(0);
         }
     }
 
---------------
-------------
@@ -52,6 +52,7 @@
     public void table(TableIdent tableIdent) {
         table = referenceInfos.getTableInfo(tableIdent);
         Preconditions.checkNotNull(table, "Table not found", tableIdent);
+        updateRowGranularity(table.rowGranularity());
     }
 
     public TableInfo table() {
---------------
-------------
@@ -147,6 +147,8 @@
             @Nullable
             @Override
             public String apply(Input<?> input) {
+                if (input.value() == null)
+                    return null;
                 return input.value().toString();
             }
         });
---------------
-------------
@@ -169,7 +169,7 @@
         if (granularity != that.granularity) return false;
         if (ident != null ? !ident.equals(that.ident) : that.ident != null) return false;
         if (objectType.ordinal() != that.objectType.ordinal()) { return false; }
-        if (type != that.type) return false;
+        if (type != null ? !type.equals(that.type) : that.type != null) return false;
 
         return true;
     }
---------------
-------------
@@ -81,7 +81,7 @@
 
         @Override
         public Object[] materialize() {
-            return Buckets.materialize(delegate);
+            return Buckets.materialize(this);
         }
     };
 
---------------
-------------
@@ -50,6 +50,8 @@
         informationSchemaTables.addBinding(TableConstraintsTable.NAME).to(TableConstraintsTable.class)
                 .asEagerSingleton();
         informationSchemaTables.addBinding(RoutinesTable.NAME).to(RoutinesTable.class).asEagerSingleton();
+        informationSchemaTables.addBinding(TableColumnsTable.NAME).to(TableColumnsTable.class).asEagerSingleton();
+        informationSchemaTables.addBinding(TableIndicesTable.NAME).to(TableIndicesTable.class).asEagerSingleton();
 
         // get a factory for InformationSchemaTableExecutionContext
         bind(InformationSchemaTableExecutionContextFactory.class).toProvider(FactoryProvider
---------------
-------------
@@ -136,6 +136,7 @@
         List<Symbol> groupBy = new ArrayList<>(outputSymbols.size());
         for (Symbol symbol : outputSymbols) {
             if (!isAggregate(symbol)) {
+                GroupBySymbolValidator.validate(symbol);
                 groupBy.add(symbol);
             }
         }
---------------
-------------
@@ -100,7 +100,12 @@
         }
     }
 
-    /** Add a task that gets repeated. */
+    /** Add a task that gets repeated.
+     *
+     * @param repeatEvery repeat Every time period
+     * @param timeUnit unit for repeatEvery
+     * @param task task to perform
+     */
     public void addRepeatingTask(final long repeatEvery, final TimeUnit timeUnit, final Runnable task) {
 
         repeatingTasks.add(new RepeatingTask( task, timeUnit, repeatEvery ));
---------------
-------------
@@ -238,6 +238,7 @@
         V8.checkThread();
         try {
             Method method = object.getClass().getMethod(methodName, parameterTypes);
+            method.setAccessible(true);
             v8.registerCallback(object, method, 0, getHandle(), jsFunctionName);
         } catch (NoSuchMethodException e) {
             throw new IllegalStateException(e);
---------------
-------------
@@ -163,6 +163,7 @@
                 return getString(index);
             case V8_ARRAY:
                 return getArray(index);
+            case V8_FUNCTION:
             case V8_OBJECT:
                 return getObject(index);
         }
---------------
-------------
@@ -44,7 +44,7 @@
 	@Override
 	public ExtensionLibraryDescriptor[] list()
 	throws ResourceNotFoundException, ForbiddenUserException, FailedRequestException {
-		return list("/ext/");
+		return list("/ext");
 	}
 	@Override
 	public ExtensionLibraryDescriptor[] list(String directory)
---------------
-------------
@@ -1192,6 +1192,7 @@
 						handleMatch(reader, startElement);
 						break eventType;
 					}
+					break;
 				case XMLStreamConstants.END_ELEMENT:
 					if (snippetName.equals(event.asEndElement().getName())) {
 						break events;
---------------
-------------
@@ -59,7 +59,7 @@
     public void sendMail(Mail mail) throws MessagingException {
         int bodySize = mail.getMessage().getSize();
         try {
-            if (m_maxMessageSizeBytes != 0 && m_maxMessageSizeBytes < bodySize) throw new MessageSizeException();
+            if (m_maxMessageSizeBytes != 0 && m_maxMessageSizeBytes*1024 < bodySize) throw new MessageSizeException();
         } catch (MessageSizeException e) {
             throw new MessagingException("message size exception is nested", e);
         }
---------------
-------------
@@ -17,7 +17,7 @@
  * under the License.                                           *
  ****************************************************************/
 
-package org.apache.james.api.kernel.mock;
+package org.apache.james.services;
 
 import java.util.HashMap;
 import java.util.Map;
---------------
-------------
@@ -59,7 +59,7 @@
     public void sendMail(Mail mail) throws MessagingException {
         int bodySize = mail.getMessage().getSize();
         try {
-            if (m_maxMessageSizeBytes != 0 && m_maxMessageSizeBytes < bodySize) throw new MessageSizeException();
+            if (m_maxMessageSizeBytes != 0 && m_maxMessageSizeBytes*1024 < bodySize) throw new MessageSizeException();
         } catch (MessageSizeException e) {
             throw new MessagingException("message size exception is nested", e);
         }
---------------
-------------
@@ -62,6 +62,6 @@
 		s.click(By.linkText("创建任务"));
 		s.click(By.id("submit_btn"));
 
-		assertEquals("必选字段", s.getText(By.xpath("//fieldset/div/div/label")));
+		assertEquals("必选字段", s.getText(By.xpath("//fieldset/div/div/span")));
 	}
 }
---------------
-------------
@@ -29,6 +29,9 @@
 
 		//登陆成功
 		assertEquals("QuickStart示例:任务管理", s.getTitle());
+
+		//退出用户
+		s.open("/logout");
 	}
 
 	@Test
---------------
-------------
@@ -28,7 +28,7 @@
 	public static class User {
 		long id;
 		String username;
-		static int counter;
+		public static int counter;
 
 		public User() {
 			counter++;
---------------
-------------
@@ -828,6 +828,7 @@
 		if (parameters == null) {
 			return;
 		}
+		init();
 		Iterator it = query.iterateNamedParameters();
 		while (it.hasNext()) {
 			String paramName = (String) it.next();
---------------
-------------
@@ -54,7 +54,7 @@
 		}
 
 		this.email = address.substring(ndx + 1, address.length() - 1);
-		this.personalName = address.substring(0, ndx - 1).trim();
+		this.personalName = address.substring(0, ndx).trim();
 	}
 
 	/**
---------------
-------------
@@ -9,7 +9,7 @@
 public class EchoTestServer extends NanoHTTPD {
 
 	public EchoTestServer() throws IOException {
-		super(80, new File("."));
+		super(8081, new File("."));
 	}
 
 	public String uri;
---------------
-------------
@@ -22,7 +22,7 @@
         final JsonNode node = jp.getCodec().readTree(jp);
         final int id = (Integer) ((IntNode) node.get("id")).numberValue();
         final String itemName = node.get("itemName").asText();
-        final int userId = (Integer) ((IntNode) node.get("owner")).numberValue();
+        final int userId = (Integer) ((IntNode) node.get("createdBy")).numberValue();
 
         return new Item(id, itemName, new User(userId, null));
     }
---------------
-------------
@@ -89,7 +89,7 @@
             ldapOperations.create(entity);
         } else {
             ldapOperations.update(entity);
-            if (declaredId != calculatedId) {
+            if (calculatedId != null && declaredId != calculatedId) {
                 odm.setId(entity, calculatedId);
             }
         }
---------------
-------------
@@ -154,7 +154,7 @@
         return time != null ? formatTime(time) : "";
     }
 
-    private static CompactCalendar parseDateTime(String stringValue, String timeZonePreference) throws ParseException {
+    static CompactCalendar parseDateTime(String stringValue, String timeZonePreference) throws ParseException {
         Date parsed = getDateTimeFormat(timeZonePreference).parse(stringValue);
         return fromDate(parsed);
     }
---------------
-------------
@@ -244,7 +244,7 @@
         //new object - need to store creation time
         if (annotationHelper.isAnnotationPresentInHierarchy(type, CreationTime.class)) {
             CreationTime ct = annotationHelper.getAnnotationFromHierarchy(o.getClass(), CreationTime.class);
-            boolean checkForNew = ct.checkForNew();
+            boolean checkForNew = ct.checkForNew() || morphium.getConfig().isCheckForNew();
             List<String> lst = annotationHelper.getFields(type, CreationTime.class);
             for (String fld : lst) {
                 Field field = annotationHelper.getField(o.getClass(), fld);
---------------
-------------
@@ -339,7 +339,7 @@
     }
 
     public void inc(Class<?> cls,Query<?> query, String field,int amount) {
-        inc(cls,query,field,amount);
+        inc(cls,query,field,amount,false,false);
     }
 
     public void inc(Class<?> cls,Query<?> query, String field,int amount, boolean insertIfNotExist, boolean multiple) {
---------------
-------------
@@ -142,7 +142,7 @@
                     }
                     if (!morphium.getDatabase().collectionExists(coll)) {
                         if (logger.isDebugEnabled())
-                            logger.debug("Collection does not exist - ensuring indices");
+                            logger.debug("Collection " + coll + " does not exist - ensuring indices");
                         morphium.ensureIndicesFor(type);
                     }
 
---------------
-------------
@@ -376,6 +376,7 @@
                             optionsMap = options.get(cnt);
                         }
                         getWriterForClass(type).ensureIndex(type, onCollection, m, optionsMap, callback);
+                        cnt++;
                     }
                 }
             }
---------------
-------------
@@ -86,7 +86,7 @@
                     } else {
                         id = annotationHelper.getId(val);
                     }
-                    if (field.getType().isAssignableFrom(List.class)) {
+                    if (Collection.class.isAssignableFrom(field.getType())) {
                         // list of references, this should be part of
                         //
                         // need to compare DBRefs
---------------
-------------
@@ -12,7 +12,7 @@
 /**
  * @author stephan
  */
-@Cache(clearOnWrite = true, maxEntries = 20000, overridable = false, readCache = true, writeCache = true, strategy = Cache.ClearStrategy.LRU, timeout = 1000)
+@Cache(clearOnWrite = true, maxEntries = 20000, overridable = false, readCache = true, writeCache = true, strategy = Cache.ClearStrategy.LRU, timeout = 5000)
 @Entity
 
 public class CachedObject {
---------------
-------------
@@ -108,7 +108,7 @@
                 toStore.add(msg);
 
             }
-            morphium.storeList(messagesList);
+            morphium.storeList(toStore);
             try {
                 sleep(pause);
             } catch (InterruptedException e) {
---------------
-------------
@@ -26,6 +26,7 @@
         checkNotNull(parentPath);
         checkNotNull(nodeName);
         checkArgument(parentPath.startsWith("/"), "Only absolute paths are supported.");
+        if (nodeName.isEmpty()) return parentPath;
         if (parentPath.equals("/")) {
             return "/" + nodeName;
         } else {
---------------
-------------
@@ -228,7 +228,7 @@
     }
 
     public static long round(double a) {
-        return (long) a;
+        return Math.round(a);
     }
 
     public static List<Double> sample(final long amount, final double start, final double end) {
---------------
-------------
@@ -157,7 +157,7 @@
             newParent = newParent.withChildRemoved(node.getName());
         }
         Node subnet = Node.NETWORK
-                .withName(newParent.uniqueName("subnet"))
+                .withName(newParent.uniqueName("network"))
                 .withChildrenAdded(parent, nodes);
         List<String> nodeNames = new ArrayList<String>();
 
---------------
-------------
@@ -89,7 +89,7 @@
 	public SWTBotToolbarButton getToolBar(String toolbarToolTip) {
 		List<SWTBotToolbarButton> toolbarButtons = getToolbarButtons();
 		for (SWTBotToolbarButton button : toolbarButtons) {
-			if (button.isEnabled() && button.getToolTipText().equals(toolbarToolTip)) {
+			if (button.getToolTipText().equals(toolbarToolTip)) {
 				return button;
 			}
 		}
---------------
-------------
@@ -1,10 +1,17 @@
 /**
- * Copyright (c) 2014 by ArcBees Inc., All rights reserved.
- * This source code, and resulting software, is the confidential and proprietary information
- * ("Proprietary Information") and is the intellectual property ("Intellectual Property")
- * of ArcBees Inc. ("The Company"). You shall not disclose such Proprietary Information and
- * shall use it only in accordance with the terms and conditions of any and all license
- * agreements you have entered into with The Company.
+ * Copyright 2011 ArcBees Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
  */
 
 package com.gwtplatform.dispatch.rest.client.serialization;
---------------
-------------
@@ -306,7 +306,7 @@
     functionParameter.setAnnotationAttributes(readAnnotationAttribute(reader));
     while (reader.hasNext()
         && !(reader.isEndElement() && edmNamespace.equals(reader.getNamespaceURI())
-        && XmlMetadataConstants.EDM_FUNCTION_IMPORT.equals(reader.getLocalName()))) {
+        && XmlMetadataConstants.EDM_FUNCTION_PARAMETER.equals(reader.getLocalName()))) {
       reader.next();
       if (reader.isStartElement()) {
         extractNamespaces(reader);
---------------
-------------
@@ -222,7 +222,6 @@
     }
 
     public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {
-        // assert debug("REDUCE <<" + new String(name) + ">> ctx=" + ctx + ";literal=" + (fields & LITERAL) + ";assign=" + (fields & ASSIGN));
         String s;
         if ((fields & (LITERAL)) != 0) {
             if ((fields & THISREF) != 0)
---------------
-------------
@@ -839,6 +839,8 @@
     case SUPER:
     case NUMBER:
     case STRING:
+    case NO_SUBSTITUTION_TEMPLATE:
+    case TEMPLATE_HEAD:
     case NULL:
     case TRUE:
     case SLASH: // regular expression literal
---------------
-------------
@@ -87,6 +87,8 @@
       } else if (callNode.getChildCount() == 3) {
         // goog.inherits(SubClass, SuperClass)
         subclass = callName.getNext();
+      } else {
+        return null;
       }
 
       if (type == SubclassType.MIXIN) {
---------------
-------------
@@ -326,7 +326,7 @@
             block = cur.getLastChild();
             lastStm = block.getLastChild();
             cur = cur.getNext();
-            if (lastStm.isBreak()) {
+            if (lastStm != null && lastStm.isBreak()) {
               block.removeChild(lastStm);
               reportCodeChange();
               break;
---------------
-------------
@@ -40,6 +40,7 @@
 package com.google.javascript.rhino.testing;
 
 import com.google.javascript.rhino.ErrorReporter;
+
 import org.junit.Assert;
 
 /**
---------------
-------------
@@ -1140,6 +1140,7 @@
 
     private boolean validAssignmentTarget(Node target) {
       switch (target.getType()) {
+        case Token.CAST: // CAST is a bit weird, but syntactically valid.
         case Token.NAME:
         case Token.GETPROP:
         case Token.GETELEM:
---------------
-------------
@@ -1012,7 +1012,7 @@
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
-        case '\0': sb.append("\\000"); break;
+        case '\0': sb.append("\\x00"); break;
         case '\n': sb.append("\\n"); break;
         case '\r': sb.append("\\r"); break;
         case '\t': sb.append("\\t"); break;
---------------
-------------
@@ -79,6 +79,7 @@
     int i = 0;
     while (DecompositionType.DECOMPOSABLE == canExposeExpression(expression)) {
       exposeExpression(expression);
+      i++;
       if (i > MAX_INTERATIONS) {
         throw new IllegalStateException(
             "DecomposeExpression depth exceeded on :\n" +
---------------
-------------
@@ -1282,7 +1282,6 @@
 
       // Check if the sources need to be re-ordered.
       if (options.dependencyOptions.needsManagement() &&
-          !options.skipAllPasses &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
---------------
-------------
@@ -742,7 +742,7 @@
         return false;
       }
     }
-    return len > 0;
+    return len > 0 && s.charAt(0) != '0';
   }
 
   static double getSimpleNumber(String s) {
---------------
-------------
@@ -44,7 +44,7 @@
  *
  * @author Tim Boudreau
  */
-@ServiceProvider (service = ProjectFactory.class)
+@ServiceProvider (service = ProjectFactory.class, position = -200000000)
 public class NodeJSProjectFactory implements ProjectFactory2 {
     public static final String PACKAGE_JSON = "package.json"; //NOI18N
     public static final String NODE_MODULES_FOLDER = "node_modules"; //NOI18N
---------------
-------------
@@ -62,7 +62,7 @@
 	protected static String DELETE_STEP= "delete from workflow_step where id = ?";
 	protected static String SELECT_STEP_BY_CONTENTLET= "select workflow_step.* from workflow_step join workflow_task on workflow_task.status = workflow_step.id where workflow_task.webasset= ?";
 	protected static String RESET_CONTENTLET_STEPS= "update workflow_task set status = ? where webasset= ?";
-	protected static String SELECT_COUNT_CONTENTLES_BY_STEP= "select count(workflow_task.*) as count from workflow_task join workflow_step on workflow_task.status=workflow_step.id where workflow_step.id=?";
+	protected static String SELECT_COUNT_CONTENTLES_BY_STEP= "select count(workflow_task.id) as count from workflow_task join workflow_step on workflow_task.status=workflow_step.id where workflow_step.id=?";
 
 	protected static String SELECT_ACTION_CLASSES_BY_ACTION= "select * from workflow_action_class where action_id = ? order by  my_order";
 	protected static String SELECT_ACTION_CLASS= "select * from workflow_action_class where id = ? ";
---------------
-------------
@@ -196,7 +196,7 @@
 	
 	public static void removeFieldVariables(Field field) {
     	DotCacheAdministrator cache = CacheLocator.getCacheAdministrator();
-        String key = getPrimaryGroup() + field.getInode();
+        String key = getFieldsVarGroup() + field.getInode();
 
 		cache.remove(key,getFieldsVarGroup());
 
---------------
-------------
@@ -160,7 +160,7 @@
 			List<FileAsset> fas = APILocator.getFileAssetAPI().findFileAssetsByHost(host, user, false);
 			for(FileAsset fa:fas){
 			    if(!fa.isArchived()) {
-			        FileResourceImpl fr = new FileResourceImpl(fa, path + host.getHostname() + "/" + fa.getPath());
+			        FileResourceImpl fr = new FileResourceImpl(fa, path + fa.getFileName());
 				    frs.add(fr);
 			    }
 			}
---------------
-------------
@@ -62,7 +62,7 @@
 	protected static String DELETE_STEP= "delete from workflow_step where id = ?";
 	protected static String SELECT_STEP_BY_CONTENTLET= "select workflow_step.* from workflow_step join workflow_task on workflow_task.status = workflow_step.id where workflow_task.webasset= ?";
 	protected static String RESET_CONTENTLET_STEPS= "update workflow_task set status = ? where webasset= ?";
-	protected static String SELECT_COUNT_CONTENTLES_BY_STEP= "select count(workflow_task.*) as count from workflow_task join workflow_step on workflow_task.status=workflow_step.id where workflow_step.id=?";
+	protected static String SELECT_COUNT_CONTENTLES_BY_STEP= "select count(workflow_task.id) as count from workflow_task join workflow_step on workflow_task.status=workflow_step.id where workflow_step.id=?";
 
 	protected static String SELECT_ACTION_CLASSES_BY_ACTION= "select * from workflow_action_class where action_id = ? order by  my_order";
 	protected static String SELECT_ACTION_CLASS= "select * from workflow_action_class where id = ? ";
---------------
-------------
@@ -132,7 +132,7 @@
 			}
 		}
 
-		config.setJobName(config.getJobName()+"_"+config.get("indexAlias"));
+		
 
 		try {
 			if(config.runNow()){
---------------
-------------
@@ -212,7 +212,7 @@
 		Identifier id = null;
 		String idStr = ic.getIdentifierFromInode(versionable);
 
-		if(idStr !=null){
+		if(UtilMethods.isSet(idStr)){
 			id= find(idStr);
 		}
 		else{
---------------
-------------
@@ -212,7 +212,7 @@
 		Identifier id = null;
 		String idStr = ic.getIdentifierFromInode(versionable);
 
-		if(idStr !=null){
+		if(UtilMethods.isSet(idStr)){
 			id= find(idStr);
 		}
 		else{
---------------
-------------
@@ -750,7 +750,7 @@
 		"from folder join identifier on (folder.identifier = identifier.id) " +
 		"where identifier.host_inode = ? " +
 		"and ("+dotFolderPath+"(parent_path,asset_name) not like ? OR "+dotFolderPath+"(parent_path,asset_name) = ?) " +
-		"and permission_type = 'com.dotmarketing.portlets.folders.model.Folder' " +
+		"and permission_type = '"+Contentlet.class.getCanonicalName()+"' " +
 		"and reference_id = folder.inode" +
 		") " +
 		"OR EXISTS(SELECT c.inode " +
---------------
-------------
@@ -580,7 +580,7 @@
     
     protected void processMap(Contentlet contentlet, Map<String,Object> map) {
         String stInode=(String)map.get(Contentlet.STRUCTURE_INODE_KEY);
-        if(UtilMethods.isSet(stInode)) {
+        if(!UtilMethods.isSet(stInode)) {
             String stName=(String)map.get("stName");
             if(UtilMethods.isSet(stName)) {
                 stInode = StructureCache.getStructureByVelocityVarName(stName).getInode();
---------------
-------------
@@ -196,7 +196,7 @@
 	
 	public static void removeFieldVariables(Field field) {
     	DotCacheAdministrator cache = CacheLocator.getCacheAdministrator();
-        String key = getPrimaryGroup() + field.getInode();
+        String key = getFieldsVarGroup() + field.getInode();
 
 		cache.remove(key,getFieldsVarGroup());
 
---------------
-------------
@@ -120,7 +120,6 @@
                 + "')]//td[@class='xwikibuttonlink']/a[contains(.,'Rollback')]")).click();
         Alert alert = getDriver().switchTo().alert();
         alert.accept();
-
     }
 
     public void deleteVersion(String version)
---------------
-------------
@@ -103,6 +103,9 @@
         // See http://code.google.com/p/selenium/issues/detail?id=256
         // Thus FTM we have to use getDriver().findElement().
 
+        // For some unknown reason sometimes the menuId cannot be found so wait for it to be visible before finding it.
+        waitUntilElementIsVisible(By.id(menuId));
+
         WebElement menuDiv = getDriver().findElement(By.id(menuId));
         executeScript("showsubmenu(arguments[0])", menuDiv);
 
---------------
-------------
@@ -16,7 +16,7 @@
 			this.sub = sub;
 		}
 
-	};
+	}
 
 	/**
 	 * <pre>
---------------
-------------
@@ -5,7 +5,7 @@
 import org.geogit.storage.blueprints.BlueprintsGraphDatabase;
 import org.geogit.storage.ConfigDatabase;
 
-import com.boundlessgeo.blongo.MongoGraph;
+import org.geogit.blongo.MongoGraph;
 import com.google.inject.Inject;
 import com.mongodb.DB;
 import com.mongodb.DBCollection;
---------------
-------------
@@ -76,7 +76,7 @@
         } catch (ScriptException e) {
             Throwable cause = Throwables.getRootCause(e);
             // TODO: improve this hack to check exception type
-            if (cause instanceof CannotRunGeogitOperationException) {
+            if (cause != e) {
                 String msg = cause.getMessage();
                 msg = msg.substring(CannotRunGeogitOperationException.class.getName().length() + 2,
                         msg.lastIndexOf("(")).trim();
---------------
-------------
@@ -174,10 +174,7 @@
                     .call(RevTree.class);
             Optional<NodeRef> ref = command(FindTreeChild.class).setParent(revTree.get())
                     .setChildPath(path).call();
-            /*
-             * Preconditions.checkArgument(ref.isPresent(),
-             * "pathspec '%s' did not match any valid path", path);
-             */
+
             if (!ref.isPresent()) {
                 return Optional.absent();
             }
---------------
-------------
@@ -27,7 +27,7 @@
 
   public static final String FILE_EXTENSIONS_PROP_KEY = "sonar.web.file.suffixes";
   public static final String OLD_FILE_EXTENSIONS_PROP_KEY = "sonar.web.fileExtensions";
-  public static final String FILE_EXTENSIONS_DEF_VALUE = ".html,.xhtml,.jsp,.jspf,.jsf,.php,.erb,.rhtml";
+  public static final String FILE_EXTENSIONS_DEF_VALUE = ".html,.xhtml,.rhtml,.shtml";
 
   private WebConstants() {
   }
---------------
-------------
@@ -126,7 +126,7 @@
     }
 
     private WebDriver switchTo(WebDriverTarget newTarget) {
-        if (!newTarget.equals(currentTarget)) {
+        if (!newTarget.equals(currentTarget) || alert != null) {
             newTarget.switchTo(driver.switchTo());
             currentTarget = newTarget;
             alert = null;
---------------
-------------
@@ -135,7 +135,7 @@
 	 * @return CR/LF equivalent
 	 */
 	private static String getAfterValue(ExportHandler eh) {
-		if (eh.getTemplateFile().getName().endsWith(Constants.XSL_FO_EXTENSION)) {
+		if (eh != null && eh.getTemplateFile().getName().endsWith(Constants.XSL_FO_EXTENSION)) {
 			return "			</fo:block><fo:block font-size=\"9pt\" text-indent=\"5mm\" space-after.optimum=\"2mm\">";
 		} 
 		return "<br/>";
---------------
-------------
@@ -59,7 +59,7 @@
 		final int characterCheckVal = SettingsHandler.getGame().getIndexOfCheck(checkName);
 		if (characterCheckVal>=0) {
 			final int characterCheckBonus = (int) character.getBonus(characterCheckVal + 1, false);
-			runningTotal = prereq.getOperator().compare(characterCheckBonus, operand);
+			runningTotal = prereq.getOperator().compare(characterCheckBonus, operand) > 0 ? 1 : 0;
 		}
 		return countedTotal(prereq, runningTotal);
 	}
---------------
-------------
@@ -56,7 +56,7 @@
     Pipe pipe = new Each( previous, argumentFieldSelector, new Identity( new Fields( "n", "l", "v" ) ) );
 
     // name and rate against others of same movie
-    pipe = new Group( pipe, new Fields( "l" ), 2, new Fields( "n1", "l", "v1", "n2", "l2", "v2" ) );
+    pipe = new Group( pipe, new Fields( "l" ), 1, new Fields( "n1", "l", "v1", "n2", "l2", "v2" ) );
 
     // remove useless fields
     pipe = new Each( pipe, new Fields( "l", "n1", "v1", "n2", "v2" ), new Identity() );
---------------
-------------
@@ -262,7 +262,7 @@
 
       LOG.debug( "handling path: {}", stringPath );
 
-      URI uri = new URI( stringPath );
+      URI uri = new Path( stringPath ).toUri(); // safer URI parsing
       String schemeString = uri.getScheme();
       String authority = uri.getAuthority();
 
---------------
-------------
@@ -86,7 +86,7 @@
 					newMessage.setObjectId(key.getOwnerObjectId());
 					newMessage.setObjectType(ObjectType.ENTITY);
 					newMessage.setObjectEtag(null);
-					processCreateUpdate(change);
+					processCreateUpdate(newMessage);
 				}
 			} catch (NotFoundException e) {
 				// Nothing to do if the wiki does not exist
---------------
-------------
@@ -135,7 +135,7 @@
 	private static void copyDtoToDbo(Participant dto, ParticipantDBO dbo) {		
 		dbo.setCompId(dto.getCompetitionId() == null ? null : Long.parseLong(dto.getCompetitionId()));
 		dbo.setUserId(dto.getCompetitionId() == null ? null : Long.parseLong(dto.getUserId()));
-		dbo.setCreatedOn(dto.getCreatedOn().getTime());
+		dbo.setCreatedOn(dto.getCreatedOn() == null ? null : dto.getCreatedOn().getTime());
 	}
 	
 	/**
---------------
-------------
@@ -8,7 +8,7 @@
 	/**
 	 * DOI prefix plus the separator (/).
 	 */
-	public static final String DOI_PREFIX = "doi:10.5072/";
+	public static final String DOI_PREFIX = "doi:10.5072/FK2.";
 
 	/**
 	 * Synapse web portal URL with protocol and host name. Path not included.
---------------
-------------
@@ -86,7 +86,7 @@
 					newMessage.setObjectId(key.getOwnerObjectId());
 					newMessage.setObjectType(ObjectType.ENTITY);
 					newMessage.setObjectEtag(null);
-					processCreateUpdate(change);
+					processCreateUpdate(newMessage);
 				}
 			} catch (NotFoundException e) {
 				// Nothing to do if the wiki does not exist
---------------
-------------
@@ -8,8 +8,7 @@
 	void clear(String tableName, String hashKeyName, String rangeKeyName);
 	
 	/**
-	 * Are Dyanmo related feature enabled?
-	 * @return
+	 * Are Dyanmo related features enabled?
 	 */
 	boolean isDynamoEnabled();
 }
---------------
-------------
@@ -22,6 +22,11 @@
 		T create(BufferedReader rdr);
 	}
 
+	/**
+	 * Read the next log event from the reader.  
+	 * @return LogEvent representing the next event logged in the file, or null if EndOfFile reached.
+	 * @throws IOException
+	 */
 	public LogEvent readLogEvent() throws IOException;
 
 }
\ No newline at end of file
---------------
-------------
@@ -135,7 +135,7 @@
 	private static void copyDtoToDbo(Participant dto, ParticipantDBO dbo) {		
 		dbo.setCompId(dto.getCompetitionId() == null ? null : Long.parseLong(dto.getCompetitionId()));
 		dbo.setUserId(dto.getCompetitionId() == null ? null : Long.parseLong(dto.getUserId()));
-		dbo.setCreatedOn(dto.getCreatedOn().getTime());
+		dbo.setCreatedOn(dto.getCreatedOn() == null ? null : dto.getCreatedOn().getTime());
 	}
 	
 	/**
---------------
-------------
@@ -272,7 +272,7 @@
 
     public long maxTimestamp()
     {
-        long maxTimestamp = Long.MIN_VALUE;
+        long maxTimestamp = getMarkedForDeleteAt();
         for (IColumn column : columns)
             maxTimestamp = Math.max(maxTimestamp, column.maxTimestamp());
         return maxTimestamp;
---------------
-------------
@@ -95,7 +95,7 @@
         return udpAddr_;
     }
 
-    public static IPartitioner getPartitioner() {
+    public static IPartitioner<?> getPartitioner() {
         return partitioner_;
     }
 
---------------
-------------
@@ -587,7 +587,7 @@
     {
         return metadata.cfType == ColumnFamilyType.Standard
                ? Column.serializer()
-               : SuperColumn.serializer(getColumnComparator());
+               : SuperColumn.serializer(metadata.subcolumnComparator);
     }
 
     /**
---------------
-------------
@@ -367,7 +367,7 @@
 
     public ColumnStats getColumnStats()
     {
-        long maxTimestampSeen = Long.MIN_VALUE;
+        long maxTimestampSeen = getMarkedForDeleteAt();
         StreamingHistogram tombstones = new StreamingHistogram(SSTable.TOMBSTONE_HISTOGRAM_BIN_SIZE);
 
         for (IColumn column : columns)
---------------
-------------
@@ -378,7 +378,7 @@
         submitUserDefined(cfs, descriptors, getDefaultGcBefore(cfs));
     }
 
-    private Future<Object> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
+    Future<Object> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
     {
         Callable<Object> callable = new Callable<Object>()
         {
---------------
-------------
@@ -376,7 +376,7 @@
         ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));
         int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);
         CfDef cfDef = getCfDef(columnFamily);
-        boolean isSuper = cfDef.comparator_type.equals("Super");
+        boolean isSuper = cfDef.column_type.equals("Super");
         
         byte[] superColumnName = null;
         ByteBuffer columnName;
---------------
-------------
@@ -468,7 +468,7 @@
             return;
 
         IndexClause clause = new IndexClause();
-        String columnFamily = statement.getChild(0).getText();
+        String columnFamily = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
         // ^(CONDITIONS ^(CONDITION $column $value) ...)
         Tree conditions = statement.getChild(1);
         
---------------
-------------
@@ -35,6 +35,7 @@
         cards = ImplementedCardList.getInstance().getCardList();
         cards.removeIf(filter);
         gen = new Random();
+        this.limitCopies = limitCopies;
     }
     
     /**
---------------
-------------
@@ -72,7 +72,7 @@
                     boolean exists = false;
                     if (isDistinct) {
                         TableIterator iter = ret.iterator();
-                        if (iter.hasNext()) {
+                        while (iter.hasNext()) {
                             Row next = iter.next();
                             if (next.equals(row)) {
                                 exists = true;
---------------
-------------
@@ -51,6 +51,7 @@
 
 import edu.iu.grnoc.flowspace_firewall.web.FlowSpaceFirewallWebRoutable;
 import edu.iu.grnoc.flowspace_firewall.web.IFlowSpaceFirewallService;
+import edu.iu.grnoc.flowspace_firewall.FlowStatCacher;
 
 public class FlowSpaceFirewall implements IFloodlightModule, IOFMessageListener, IOFSwitchListener, IFlowSpaceFirewallService{
 
---------------
-------------
@@ -51,6 +51,7 @@
 
 import edu.iu.grnoc.flowspace_firewall.web.FlowSpaceFirewallWebRoutable;
 import edu.iu.grnoc.flowspace_firewall.web.IFlowSpaceFirewallService;
+import edu.iu.grnoc.flowspace_firewall.FlowStatCacher;
 
 public class FlowSpaceFirewall implements IFloodlightModule, IOFMessageListener, IOFSwitchListener, IFlowSpaceFirewallService{
 
---------------
-------------
@@ -38,7 +38,7 @@
 
 	public GetRequest field(String name, Object value) {
 		StringBuilder queryString  = new StringBuilder();
-		if (this.url.contains("\\?")) {
+		if (this.url.contains("?")) {
 			queryString.append("&");
 		} else {
 			queryString.append("?");
---------------
-------------
@@ -38,7 +38,7 @@
 
 	public GetRequest field(String name, Object value) {
 		StringBuilder queryString  = new StringBuilder();
-		if (this.url.contains("\\?")) {
+		if (this.url.contains("?")) {
 			queryString.append("&");
 		} else {
 			queryString.append("?");
---------------
-------------
@@ -213,7 +213,7 @@
                                     }
                                 });
                             } catch (Exception e) {
-                                if (e instanceof IllegalArgumentException && e.getCause()!=null && e.getCause().getCause()!=null && e.getCause().getCause() instanceof EnumDerialisationException) {
+                                if (e instanceof IllegalArgumentException && e.getCause() != null && (e.getCause().getCause()==null || e.getCause().getCause() instanceof EnumDerialisationException)) {
                                     responses.add(JsonRpcErrorResponse.buildErrorResponse(rpc, new JsonRpcError(INVALID_PARAMS, ServerFaultCode.ServerDeserialisationFailure.getDetail(), null)));
                                 }
                                 else {
---------------
-------------
@@ -71,7 +71,7 @@
 					index = random.nextInt(list.size);
 				} while (indexes.contains(index, false));
 				randomList.add(list.get(index));
-				indexes.add(i);
+				indexes.add(index);
 			}
 			return randomList;
 		} else {
---------------
-------------
@@ -60,7 +60,7 @@
 	private Runnable launchBackgroundProcess = new Runnable() {
 		@Override
 		public void run() {
-			mockController.getBackgroundExecutor().submit(
+			controller.getBackgroundExecutor().submit(
 					new BackgroundTask<String>() {
 						@Override
 						public String call() throws Exception {
---------------
-------------
@@ -58,7 +58,7 @@
     /**
      * Set Registry object.
      * 
-     * @param AiravataRegistry
+     * @param AiravataRegistry2
      *            object to used.
      */
     void setRegistryService(AiravataRegistry2 value);
---------------
-------------
@@ -91,7 +91,7 @@
 
         for (TaskDetails taskDetail: tasks)
         {
-            orchestrator.launchExperiment(simpleExperiment,test, taskDetail);
+            orchestrator.launchExperiment(simpleExperiment,test, taskDetail,null);
         }
     }
 }
---------------
-------------
@@ -252,6 +252,7 @@
 
     @Override
     public void postProcess(InvocationContext context) throws ServiceException {
+        if(this.registryService != null)
         ((JCRRegistry)this.registryService).closeConnection();
     }
 
---------------
-------------
@@ -1,3 +1,5 @@
+
+
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
---------------
-------------
@@ -1,3 +1,5 @@
+
+
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
---------------
-------------
@@ -191,6 +191,8 @@
    * @param starAttributeFilesToDataInput A mapping from star attribute file names to their respective DataInput object.
    * @param darkAttributeFilesToDataInput A mapping from dark attribute file names to their respective DataInput object.
    */
+  @SuppressWarnings("unused")
+  // used via reflection in the tests
   private NChiladaFileScan(final InputStream groupInputStream,
       final Map<String, DataInput> gasAttributeFilesToDataInput,
       final Map<String, DataInput> starAttributeFilesToDataInput,
---------------
-------------
@@ -27,7 +27,7 @@
   private static final long MAX_WAITING_TIME_MS = TimeUnit.MILLISECONDS.convert(1, TimeUnit.DAYS);
 
   /** The default port for the server. */
-  private static final int PORT = 8753;
+  public static final int PORT = 8753;
 
   /** The Restlet Component is the main class that holds multiple servers/hosts for this application. */
   private final Component component;
---------------
-------------
@@ -35,6 +35,6 @@
     QueryPlan checkTask = planQ.peekFirst();
     Verify.verify(checkTask == this, "this %s should be the first object on the queue, not %s!", this, checkTask);
     planQ.removeFirst();
-    planQ.addAll(plans);
+    planQ.addAll(0, plans);
   }
 }
---------------
-------------
@@ -46,7 +46,7 @@
    * @throws IOException if there is an IO exception
    */
   public CsvTupleWriter(final char separator, final OutputStream out) throws IOException {
-    this(out, CSVFormat.DEFAULT.withRecordSeparator(separator));
+    this(out, CSVFormat.DEFAULT.withDelimiter(separator));
   }
 
   /**
---------------
-------------
@@ -337,7 +337,7 @@
       }
 
       /* initiate rowIndices */
-      rowIndices = new int[getChildren().length];
+      rowIndices = new int[tables[tableIndex].numColumns()];
       Arrays.fill(rowIndices, 0);
     }
 
---------------
-------------
@@ -35,6 +35,6 @@
     QueryPlan checkTask = planQ.peekFirst();
     Verify.verify(checkTask == this, "this %s should be the first object on the queue, not %s!", this, checkTask);
     planQ.removeFirst();
-    planQ.addAll(plans);
+    planQ.addAll(0, plans);
   }
 }
---------------
-------------
@@ -169,7 +169,7 @@
   private final ConcurrentHashMap<Long, MasterQueryPartition> activeQueries;
 
   /**
-   * Results of succeeded queries, currently the number of tuples received by the SonkRoot.
+   * Results of succeeded queries, currently the number of tuples received by the SinkRoot.
    * */
   private final ConcurrentHashMap<Long, Long> succeededQueryResults;
 
---------------
-------------
@@ -32,8 +32,6 @@
 import org.ops4j.pax.exam.Configuration;
 import org.ops4j.pax.exam.Option;
 import org.ops4j.pax.exam.junit.JUnit4TestRunner;
-import org.ops4j.pax.exam.spi.reactors.AllConfinedStagedReactorFactory;
-import org.ops4j.pax.exam.spi.reactors.ExamReactorStrategy;
 import org.ops4j.pax.exam.util.PathUtils;
 import org.ops4j.pax.swissbox.framework.ServiceLookup;
 import org.osgi.framework.BundleContext;
---------------
-------------
@@ -211,7 +211,7 @@
                     copyDirectory(file, webResourceDir);
                 }
                 else {
-                    exploder.processFile(file.getAbsolutePath(), webResourceDir.getAbsolutePath());
+                    exploder.processFile(file, webResourceDir);
                 }
             }
         }
---------------
-------------
@@ -46,7 +46,6 @@
  *
  */
 @RunWith( JUnit4TestRunner.class )
-@ExamReactorStrategy( AllConfinedStagedReactorFactory.class )
 public class ShutdownTimeoutTestWrapped
 {
     @Inject
---------------
-------------
@@ -257,7 +257,7 @@
 		}
 
 		// ask the parent whether this subfolder is shared
-		return parent.isShared;
+		return parent.isShared();
 	}
 
 	/**
---------------
-------------
@@ -10,7 +10,7 @@
 import org.hive2hive.core.H2HConstants;
 
 /**
- * An ASN.1 encoder and decoder for the signature.
+ * A RSA encoder and decoder for the signature.
  * 
  * @author Thomas, Seppi
  */
---------------
-------------
@@ -69,7 +69,7 @@
 		// download next chunk
 		KeyPair firstInList = chunksToGet.remove(0);
 		decryptionKey = firstInList.getPrivate(); // store current private key
-		logger.info("Downloading next chunk... " + firstInList + " chunk(s) more to go.");
+		logger.info("Downloading next chunk... " + chunksToGet.size() + " chunk(s) more to go.");
 		get(firstInList.getPublic().toString(), H2HConstants.FILE_CHUNK);
 	}
 
---------------
-------------
@@ -10,7 +10,7 @@
     }
 
     public static String convertToEnsemblSpecies(String species) {
-       return firstTwoWords(species).toLowerCase();
+       return species == null ? null : firstTwoWords(species).toLowerCase();
     }
 
     static String firstTwoWords(String sentence) {
---------------
-------------
@@ -38,7 +38,7 @@
     public static final String PROPERTY_TYPE_SYMBOL = "symbol";
 
     // needs changing to DifferentialRequestPreferences.DEFAULT_CUTOFF
-    private static final double CUTOFF = 0.5;
+    public static final double CUTOFF = 0.5;
 
     @Value("#{configuration['index.types.genepage']}")
     private String genePagePropertyTypes;
---------------
-------------
@@ -51,7 +51,7 @@
     public double round(double value) {
         int numberOfFractionalDigits = value >= 1 ? FRACTIONAL_DIGITS_FOR_VALUE_LARGER_OR_EQUAL_TO_ONE
                 : FRACTIONAL_DIGITS_FOR_VALUE_SMALLER_THAN_ONE;
-        return round(numberOfFractionalDigits, numberOfFractionalDigits);
+        return round(value, numberOfFractionalDigits);
     }
 
     public String htmlFormatDoubleEncoded(double number) {
---------------
-------------
@@ -122,7 +122,7 @@
         double level = rnaSeqBslnExpression.expressionLevel();
 
         String assayGroupId = rnaSeqBslnExpression.assayGroupId();
-        FactorGroup factorGroup = experiment.getExperimentalFactors().getFactorGroupByAssayGroupId(assayGroupId);
+        FactorGroup factorGroup = experiment.getExperimentalFactors().getFactorGroup(assayGroupId);
 
         return new BaselineExpression(level, factorGroup);
     }
---------------
-------------
@@ -56,7 +56,7 @@
 
     @Override
     public boolean apply(BaselineExpression expression) {
-        return !expression.isKnown() || (expression.isGreaterThan(cutoff) && checkFilterFactors(expression));
+        return checkFilterFactors(expression) && (!expression.isKnown() || expression.isGreaterThan(cutoff));
     }
 
     protected boolean checkFilterFactors(BaselineExpression expression) {
---------------
-------------
@@ -72,7 +72,7 @@
     public Set<String> findGeneIds(String searchText, String species) {    
 
         String geneQuery = buildQueryAllTextString(searchText);
-        String jsonString = getJsonResponse(SOLR_SEARCH_QUERY_TEMPLATE, "{!lucene q.op=OR df=alltext}", searchText, species);
+        String jsonString = getJsonResponse(SOLR_SEARCH_QUERY_TEMPLATE, "{!lucene q.op=OR df=alltext}", geneQuery, species);
 
         List<String> geneIds = JsonPath.read(jsonString, JSON_PATH_GENE_IDENTIFIERS);
 
---------------
-------------
@@ -84,7 +84,7 @@
         if (requestContext.isGeneSetMatch()) {
             return new String[]{GENE_SET_COLUMN_NAME};
         }
-        return new String[]{};
+        return new String[]{"Gene ID", "Gene Name"};
     }
 
     @Override
---------------
-------------
@@ -74,7 +74,7 @@
             }
         } else if (contrastPropertyType == otherProperty.contrastPropertyType &&
                 contrastPropertyType == ContrastPropertyType.FACTOR) {
-            int groupComparison = Booleans.compare(otherProperty.hasEqualValues(), hasEqualValues());
+            int groupComparison = Booleans.compare(hasEqualValues(), otherProperty.hasEqualValues());
             if (groupComparison != 0) {
                 return groupComparison;
             }
---------------
-------------
@@ -84,7 +84,7 @@
 
                 case '.':
                     poll();
-                    if (peek() == '.') {
+	                if (!isEmpty() && peek() == '.') {
                         poll();
                         fragments.add("..");
 
---------------
-------------
@@ -97,7 +97,8 @@
             String[] indexArr = COMMA.split(trimmedCondition);
 
             if(obj == null || jsonProvider.length(obj) == 0){
-                throw new PathNotFoundException("Failed to access array index: '" + condition + "' since the array is null or empty");
+                //throw new PathNotFoundException("Failed to access array index: '" + condition + "' since the array is null or empty");
+                return result;
             }
 
             if (indexArr.length == 1) {
---------------
-------------
@@ -44,7 +44,6 @@
         return (List<T>) filters.filter(root);
     }
 
-
     public static <T> List<T> read(String json, String jsonPath) throws java.text.ParseException {
         JsonPath path = compile(jsonPath);
 
---------------
-------------
@@ -7,7 +7,7 @@
 
 public class AvoidUsingOctalValues extends AbstractRule {
 
-    public static final Pattern OCTAL_PATTERN = Pattern.compile("0[0-7]+");
+    public static final Pattern OCTAL_PATTERN = Pattern.compile("0[0-7]+[lL]?");
 
     public Object visit(ASTLiteral node, Object data) {
         String img = node.getImage();
---------------
-------------
@@ -90,7 +90,7 @@
                         continue;
                     }
                     ASTExpression e = (ASTExpression) se.jjtGetChild(2);
-                    if (e.jjtGetChild(0) instanceof ASTEqualityExpression) {
+                    if (e.findChildrenOfType(ASTEqualityExpression.class).size() > 0) {
                         continue;
                     }
                     String val = getFirstNameImage(e);
---------------
-------------
@@ -45,7 +45,7 @@
 		    RuleViolation rv = violations.next();
 		    buf.append(rv.getFilename());
 		    buf.append(':').append(Integer.toString(rv.getBeginLine()));
-		    buf.append('\t').append(rv.getDescription()).append(PMD.EOL);
+		    buf.append(":\t").append(rv.getDescription()).append(PMD.EOL);
 		    writer.write(buf.toString());
 		}
     }
---------------
-------------
@@ -52,7 +52,7 @@
         }
 
         //if (immediateLiterals > 1) { // see patch http://sourceforge.net/tracker/index.php?func=detail&aid=1455282&group_id=56262&atid=479923
-        if (immediateLiterals == 2) {
+        if (immediateLiterals > 1) {
             return data;
         }
 
---------------
-------------
@@ -25,7 +25,7 @@
             List usages = (List) params.get(decl);
             for (Iterator j = usages.iterator(); j.hasNext();) {
                 NameOccurrence occ = (NameOccurrence) j.next();
-                if (occ.isOnLeftHandSide() && occ.getNameForWhichThisIsAQualifier() == null && !decl.isArray()) {
+                if ((occ.isOnLeftHandSide() || occ.isSelfAssignment()) && occ.getNameForWhichThisIsAQualifier() == null && !decl.isArray()) {
                     ((RuleContext) data).getReport().addRuleViolation(createRuleViolation((RuleContext) data, decl.getNode(), MessageFormat.format(getMessage(), new Object[]{decl.getImage()})));
                 }
             }
---------------
-------------
@@ -68,7 +68,7 @@
         return properties;
     }
 
-    public boolean isInclude()
+    public boolean include()
     {
         return true;
     }
---------------
-------------
@@ -273,7 +273,7 @@
 
             // extract, now using task if available
             MutableList<String> commands = MutableList.copyOf(installCommands(destFile))
-                    .appendAll(extractCommands(destFile, optionalTmpDir, destDir, false, keepArchiveAfterUnpacking));
+                    .appendAll(extractCommands(destFile, tmpDir, destDir, false, keepArchiveAfterUnpacking));
             if (DynamicTasks.getTaskQueuingContext()!=null) {
                 result = DynamicTasks.queue(SshTasks.newSshExecTaskFactory(machine, commands.toArray(new String[0])).summary("extracting archive").requiringExitCodeZero()).get();
             } else {
---------------
-------------
@@ -201,6 +201,11 @@
             // Two-phase deserialization. First we deserialize to find all instances (and their types).
             // Then we deserialize so that inter-entity references can be set. During the first phase,
             // any inter-entity reference will get the dummyEntity/dummyLocation.
+            //
+            // TODO if underlying data-store is changed between first and second phase (e.g. to add an
+            // entity), then second phase might try to reconstitute an entity that has not been put in
+            // the rebindContext. This should not affect normal production usage, because rebind is run
+            // against a data-store that is not being written to by other brooklyn instance(s).
             BrooklynMemento mementoHeaders = persister.loadMemento(dummyLookupContext);
     
             // Instantiate locations
---------------
-------------
@@ -32,7 +32,8 @@
         .parameter(String.class, "name")
         .buildAbstract();
 
-    /** Makes a string saying hi to the given name, in uppercase, for testing. */
+    /** Makes a string saying hi to the given name, in uppercase, for testing. 
+     * In contrast to v1, impl here returns HI not Hi. */
     String sayHI(String name);
     
 }
---------------
-------------
@@ -188,6 +188,7 @@
             jcloudsProperties.put(JcloudsLocationConfig.CLOUD_REGION_ID.getName(), regionName);
         } else {
             // other "providers" are APIs so take an _endpoint_ (but not a location)
+            jcloudsProperties.put(JcloudsLocationConfig.CLOUD_ENDPOINT.getName(), regionName);
         }
         
         return managementContext.getLocationManager().createLocation(LocationSpec.spec(JcloudsLocation.class)
---------------
-------------
@@ -188,6 +188,7 @@
             jcloudsProperties.put(JcloudsLocationConfig.CLOUD_REGION_ID.getName(), regionName);
         } else {
             // other "providers" are APIs so take an _endpoint_ (but not a location)
+            jcloudsProperties.put(JcloudsLocationConfig.CLOUD_ENDPOINT.getName(), regionName);
         }
         
         return managementContext.getLocationManager().createLocation(LocationSpec.spec(JcloudsLocation.class)
---------------
-------------
@@ -51,7 +51,7 @@
     public static final String PASSWD = "etc/passwd";
 
     @SetFromFlag("version")
-    public static final BasicConfigKey<String> SUGGESTED_VERSION = new BasicConfigKey<String>(SoftwareProcessEntity.SUGGESTED_VERSION, "0.18");
+    public static final BasicConfigKey<String> SUGGESTED_VERSION = new BasicConfigKey<String>(SoftwareProcessEntity.SUGGESTED_VERSION, "0.20");
     
     @SetFromFlag("amqpPort")
     public static final PortAttributeSensorAndConfigKey AMQP_PORT = AmqpServer.AMQP_PORT;
---------------
-------------
@@ -809,8 +809,8 @@
                     result.set(Calendar.SECOND, Integer.parseInt(secsS));
                 } else {
                     double s = Double.parseDouble(secsS);
-                    if (s>=0 && s<=60) {
-                        // in double format, with correct period
+                    if (secsS.indexOf('.')>=0) {
+                        // accept
                     } else if (secsS.length()==5) {
                         // allow ssSSS with no punctuation
                         s = s/=1000;
---------------
-------------
@@ -1430,7 +1430,7 @@
             
             if (Strings.isNonBlank(pubKey)) {
                 adminBuilder.authorizeAdminPublicKey(true).adminPublicKey(pubKey);
-                useKey = true;
+                if (privKey!=null) useKey = true;
             } else {
                 adminBuilder.authorizeAdminPublicKey(false).adminPublicKey(Identifiers.makeRandomId(12)+"-ignored");
             }
---------------
-------------
@@ -28,6 +28,7 @@
     @Override
     public void start(Collection<? extends Location> locations) {
         log.info("Starting entity "+this+" at "+locations);
+        addLocations(locations);
         
         // essentially does StartableMethods.start(this, locations),
         // but optionally filters locations for each child
---------------
-------------
@@ -109,7 +109,7 @@
     @Path("/machines/{machine}")
     @ApiOperation(
             value = "Retrieve usage information about a specific machine location",
-            responseClass = "brooklyn.rest.domain.usagestatistics"
+            responseClass = "brooklyn.rest.domain.UsageStatistics"
     )
     @ApiErrors(value = {
             @ApiError(code = 404, reason = "Machine not found")
---------------
-------------
@@ -109,7 +109,7 @@
     @Path("/machines/{machine}")
     @ApiOperation(
             value = "Retrieve usage information about a specific machine location",
-            responseClass = "brooklyn.rest.domain.usagestatistics"
+            responseClass = "brooklyn.rest.domain.UsageStatistics"
     )
     @ApiErrors(value = {
             @ApiError(code = 404, reason = "Machine not found")
---------------
-------------
@@ -88,7 +88,7 @@
         for (String item: items) {
             boolean trimThisMerge = result.length()>0 && !result.toString().endsWith("://") && !result.toString().endsWith(":///") && !result.toString().endsWith(":");
             if (trimThisMerge) {
-                while (result.charAt(result.length()-1)=='/')
+                while (result.length()>0 && result.charAt(result.length()-1)=='/')
                     result.deleteCharAt(result.length()-1);
                 result.append('/');
             }
---------------
-------------
@@ -207,7 +207,7 @@
         return (Set<SubscriptionHandle>) ((Set<?>) elvis(subscriptionsBySubscriber.get(subscriber), Collections.emptySet()));
     }
 
-    public Set<SubscriptionHandle> getSubscriptionsForEntitySensor(Entity source, Sensor<?> sensor) {
+    public synchronized Set<SubscriptionHandle> getSubscriptionsForEntitySensor(Entity source, Sensor<?> sensor) {
         Set<SubscriptionHandle> subscriptions = new LinkedHashSet<SubscriptionHandle>();
         subscriptions.addAll(elvis(subscriptionsByToken.get(makeEntitySensorToken(source, sensor)), Collections.emptySet()));
         subscriptions.addAll(elvis(subscriptionsByToken.get(makeEntitySensorToken(null, sensor)), Collections.emptySet()));
---------------
-------------
@@ -102,8 +102,9 @@
                 } else {
                     v = vfuture.get();
                 }
-            } else if (v instanceof Closure) {
-                v = ((Closure) v).call();
+// FIXME Confirm we really want to remove this
+//            } else if (v instanceof Closure) {
+//                v = ((Closure) v).call();
             } else if (v instanceof Map) {
                 //and if a map or list we look inside
                 Map result = Maps.newLinkedHashMap();
---------------
-------------
@@ -36,7 +36,7 @@
     @SuppressWarnings("unused")
     private static final Logger log = LoggerFactory.getLogger(LocalManagementContext.class);
 
-    public static final List<LocalManagementContext> INSTANCES = new CopyOnWriteArrayList<LocalManagementContext>();
+    private static final List<LocalManagementContext> INSTANCES = new CopyOnWriteArrayList<LocalManagementContext>();
 
     public static List<LocalManagementContext> getInstances(){
         return new LinkedList<LocalManagementContext>(INSTANCES);
---------------
-------------
@@ -47,7 +47,7 @@
         String args = matcher.group(2);
         Map<String,?> locationArgs = KeyValueParser.parseMap(args);
 
-        Map<String, Object> filteredProperties = new LocationPropertiesFromBrooklynProperties().getLocationProperties("byon", namedLocation, properties);
+        Map<String, Object> filteredProperties = new LocationPropertiesFromBrooklynProperties().getLocationProperties(null, namedLocation, properties);
         MutableMap<String, Object> flags = MutableMap.<String, Object>builder()
                 .putAll(filteredProperties)
                 .putAll(locationFlags)
---------------
-------------
@@ -4,6 +4,7 @@
 
     public AcmeEntitlementManager() {
         super(Entitlements.root());
+        super.addUser("hacker", Entitlements.minimal());
         super.addUser("bob", Entitlements.readOnly());
         super.addUser("alice", Entitlements.root());
     }
---------------
-------------
@@ -211,6 +211,10 @@
                 }
             };
             
+            // FIXME dummyLookupContext isn't good enough - we need *all* the interfaces of the entity/location.
+            // So we need to peek inside the list of entities.
+            // Need to add methods such as Map<String, String> persister.loadEntityTypes()
+            
             // Two-phase deserialization. First we deserialize to find all instances (and their types).
             // Then we deserialize so that inter-entity references can be set. During the first phase,
             // any inter-entity reference will get the dummyEntity/dummyLocation.
---------------
-------------
@@ -169,6 +169,7 @@
 
     @Override
     public GeneratedPropertyBuilder addProperty(final String name) {
+        Preconditions.checkArgument(name != null, "Parameter name can't be null");
         final GeneratedPropertyBuilder builder = new GeneratedPropertyBuilderImpl(name);
         builder.setAccessModifier(AccessModifier.PUBLIC);
         properties = LazyCollections.lazyAdd(properties, builder);
---------------
-------------
@@ -169,6 +169,7 @@
 
     @Override
     public GeneratedPropertyBuilder addProperty(final String name) {
+        Preconditions.checkArgument(name != null, "Parameter name can't be null");
         final GeneratedPropertyBuilder builder = new GeneratedPropertyBuilderImpl(name);
         builder.setAccessModifier(AccessModifier.PUBLIC);
         properties = LazyCollections.lazyAdd(properties, builder);
---------------
-------------
@@ -50,7 +50,7 @@
     "^[A-Za-z0-9._%+\\-]+@[A-Za-z0-9.\\-]+\\.[A-Za-z]{2,4}$";
 
   public static boolean isDefined(String parameter) {
-    return (parameter != null && parameter.length() > 0 && !"null".equalsIgnoreCase(parameter));
+    return (parameter != null && parameter.trim().length() > 0 && !"null".equalsIgnoreCase(parameter));
   }
 
   public static boolean isInteger(String id) {
---------------
-------------
@@ -80,7 +80,7 @@
   public void visit(CronJobTrigger trigger) {
     try {
       CronTrigger cronTrigger = new CronTrigger();
-      cronTrigger.setCronExpression("* " + trigger.getCronExpression());
+      cronTrigger.setCronExpression("0 " + trigger.getCronExpression());
       if (trigger.getStartDate() != null) {
         cronTrigger.setStartTime(trigger.getStartDate());
       }
---------------
-------------
@@ -88,6 +88,7 @@
     i.setDomainFatherId(Integer.toString(rs.getInt(2)));
     i.setLabel(rs.getString(3));
     i.setName(name);
+    i.setInheritanceBlocked(rs.getInt("isInheritanceBlocked") == 1);
 
     return i;
   }
---------------
-------------
@@ -92,7 +92,7 @@
     insertRow(INSERT_DOMAIN, domain);
   }
   static final private String INSERT_DOMAIN ="INSERT INTO ST_Domain (id, name, description, " +
-      "propFileName, className, authenticationServer, theTimeStamp,s ilverpeasServerURL) VALUES " +
+      "propFileName, className, authenticationServer, theTimeStamp, silverpeasServerURL) VALUES " +
       " (? ,? ,?, ? ,?, ?, ?, ?)";
 
   @Override
---------------
-------------
@@ -103,7 +103,7 @@
 
     IDPattern pattern;
     try {
-      pattern = (IDPattern) xstream.fromXML(serializedPattern);
+      pattern = (IDPattern) xstream.fromXML(serializedGenerator);
     } catch (XStreamException e) {
 	    throw new IllegalArgumentException(
 	      "Could not understand or parse this representation of an ID generator.");
---------------
-------------
@@ -66,7 +66,7 @@
     }
 
     protected int getCountInternal(Query query) throws IOException {
-        FeatureReader<SimpleFeatureType, SimpleFeature> featureReader = getReader(query);
+        FeatureReader<SimpleFeatureType, SimpleFeature> featureReader = getReaderInternal(query);
         int n = 0;
         try {
             for (n = 0; featureReader.hasNext(); n++) {
---------------
-------------
@@ -1876,7 +1876,7 @@
                 // process the css entry
                 //
                 if (res.equalsIgnoreCase(strokeString)) {
-                    Expression color = parseCssParameter(child, false);
+                    Expression color = parseCssParameter(child, true);
                     stroke.setColor(color);
                 } else if (res.equalsIgnoreCase("width") || res.equalsIgnoreCase("stroke-width")) {
                     Expression width = parseCssParameter(child, false);
---------------
-------------
@@ -2,7 +2,7 @@
  *    GeoTools - The Open Source Java GIS Toolkit
  *    http://geotools.org
  *
- *    (C) 2002-2011, Open Source Geospatial Foundation (OSGeo)
+ *    (C) 2013, Open Source Geospatial Foundation (OSGeo)
  *
  *    This library is free software; you can redistribute it and/or
  *    modify it under the terms of the GNU Lesser General Public
---------------
-------------
@@ -2,7 +2,7 @@
  *    GeoTools - The Open Source Java GIS Toolkit
  *    http://geotools.org
  * 
- *    (C) 2014, Open Source Geospatial Foundation (OSGeo)
+ *    (C) 2014 - 2015, Open Source Geospatial Foundation (OSGeo)
  *
  *    This library is free software; you can redistribute it and/or
  *    modify it under the terms of the GNU Lesser General Public
---------------
-------------
@@ -2,7 +2,7 @@
  *    GeoTools - The Open Source Java GIS Toolkit
  *    http://geotools.org
  *
- *    (C) 2002-2011, Open Source Geospatial Foundation (OSGeo)
+ *    (C) 2013, Open Source Geospatial Foundation (OSGeo)
  *
  *    This library is free software; you can redistribute it and/or
  *    modify it under the terms of the GNU Lesser General Public
---------------
-------------
@@ -4170,7 +4170,7 @@
 				}
 				
 				if (sameName(elems[3], value[i])) {
-					legendURLS.add((String)value[2].getValue());
+					legendURLS.add((String)value[i].getValue());
 				}
 				
 				if (sameName(elems[4], value[i])) {
---------------
-------------
@@ -79,7 +79,7 @@
         
         long t2 = System.currentTimeMillis();
         System.out.println(t2-t1);
-        features.close(it);
+        it.close();
     }
 
     static FeatureSource loadData() throws Exception {
---------------
-------------
@@ -261,7 +261,7 @@
             dest = new Coordinate();
         }
 
-        final double[] array = new double[transform.getSourceDimensions()];
+        final double[] array = new double[transform.getTargetDimensions()];
         copy(source, array);
         transform.transform(array, 0, array, 0, 1);
 
---------------
-------------
@@ -2446,7 +2446,7 @@
                     // //
                     final Object grid = gridPropertyName.evaluate(drawMe.content);
                     if (grid instanceof GridCoverage2D) {
-                        coverage = (GridCoverage2D) drawMe.content;
+                        coverage = (GridCoverage2D) grid;
                     } else if (grid instanceof AbstractGridCoverage2DReader) {
                         final Object params = paramsPropertyName.evaluate(drawMe.content);
                         GridGeometry2D readGG = new GridGeometry2D(new GridEnvelope2D(screenSize), mapExtent);
---------------
-------------
@@ -57,7 +57,7 @@
 
     public void accepts(org.opengis.feature.FeatureVisitor visitor,
             org.opengis.util.ProgressListener progress) throws IOException {
-        delegate.accepts(visitor, progress);
+        DataUtilities.visit(this, visitor, progress);
     }
     
 
---------------
-------------
@@ -1876,7 +1876,7 @@
                 // process the css entry
                 //
                 if (res.equalsIgnoreCase(strokeString)) {
-                    Expression color = parseCssParameter(child, false);
+                    Expression color = parseCssParameter(child, true);
                     stroke.setColor(color);
                 } else if (res.equalsIgnoreCase("width") || res.equalsIgnoreCase("stroke-width")) {
                     Expression width = parseCssParameter(child, false);
---------------
-------------
@@ -48,7 +48,7 @@
 	 * Prefix under which JAX-RS resources should be registered.
 	 */
 	@XmlElement
-	private String prefix = "/";
+	private String prefix = "";
 
 	/**
 	 * Automatically register in Jersey any class marked with
---------------
-------------
@@ -944,6 +944,7 @@
                     if (tag==99) { // came from defaultwriteobject
                         fieldMap = new HashMap<String, Object>();
                         FSTObjectInput.this.readCompatibleObjectFields(referencee, clInfo, fstCompatibilityInfo.getFieldArray(), fieldMap);
+                        codec.readVersionTag(); // consume dummy version tag as created by defaultWriteObject
                     } else {
                         fieldMap = (HashMap<String, Object>) FSTObjectInput.this.readObjectInternal(HashMap.class);
                     }
---------------
-------------
@@ -944,6 +944,7 @@
                     if (tag==99) { // came from defaultwriteobject
                         fieldMap = new HashMap<String, Object>();
                         FSTObjectInput.this.readCompatibleObjectFields(referencee, clInfo, fstCompatibilityInfo.getFieldArray(), fieldMap);
+                        codec.readVersionTag(); // consume dummy version tag as created by defaultWriteObject
                     } else {
                         fieldMap = (HashMap<String, Object>) FSTObjectInput.this.readObjectInternal(HashMap.class);
                     }
---------------
-------------
@@ -24,6 +24,6 @@
     }
 
     private String capitalize(String line) {
-        return Character.toUpperCase(line.charAt(0)) + line.substring(1);
+        return line.length() > 0 ? Character.toUpperCase(line.charAt(0)) + line.substring(1) : "";
     }
 }
---------------
-------------
@@ -46,6 +46,6 @@
 
     @Override
     public String escapePattern(String pattern) {
-        return pattern;
+        return pattern.replaceAll ("\\\\", "\\\\\\\\");
     }
 }
---------------
-------------
@@ -107,6 +107,8 @@
             return Collections.unmodifiableList((List<T>) xStream.unmarshal(reader));
         } catch (AbstractReflectionConverter.UnknownFieldException e) {
             throw new CucumberException(e.getShortMessage());
+        } catch (AbstractReflectionConverter.DuplicateFieldException e) {
+            throw new CucumberException(e.getShortMessage());
         } catch (ConversionException e) {
             throw new CucumberException(String.format("Can't assign null value to one of the primitive fields in %s. Please use boxed types.", e.get("class")));
         }
---------------
-------------
@@ -46,6 +46,6 @@
 
     @Override
     public String escapePattern(String pattern) {
-        return pattern;
+        return pattern.replace ("\\", "\\\\");
     }
 }
---------------
-------------
@@ -22,7 +22,7 @@
     @Override
     public String template() {
         return "@{0}(\"{1}\")\n" +
-                "public void {2}({3}) '{'\n" +
+                "public void {2}({3}) throws Throwable '{'\n" +
                 "    // {4}\n" +
                 "{5}    throw new PendingException();\n" +
                 "'}'\n";
---------------
-------------
@@ -60,7 +60,7 @@
     
     @After({"@txn"})
     public void rollBackAfterHook() {
-//        obtainPlatformTransactionManager().rollback(txStatus);
+        obtainPlatformTransactionManager().rollback(txStatus);
     }
 
     PlatformTransactionManager obtainPlatformTransactionManager() {
---------------
-------------
@@ -37,7 +37,6 @@
 import com.jcabi.dynamo.Item;
 import com.jcabi.dynamo.QueryValve;
 import com.jcabi.dynamo.Region;
-import com.jcabi.dynamo.Table;
 import com.thindeck.api.Repo;
 import com.thindeck.api.Repos;
 import java.io.IOException;
---------------
-------------
@@ -53,8 +53,6 @@
 		}	
 		model.addAttribute("appointmentBlockList", appointmentBlockList);
 		model.addAttribute("appointmentTypeList", appointmentTypeList);
-		//Setting the tree view to be default
-		Context.getAdministrationService().saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCATION_WIDGET_TYPE, "tree"));
 	}
 	
 	
---------------
-------------
@@ -1,7 +1,7 @@
 /*
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
  *
- * Copyright (c) 2004-2012 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004-2013 Oracle and/or its affiliates. All rights reserved.
  *
  * The contents of this file are subject to the terms of either the GNU
  * General Public License Version 2 only ("GPL") or the Common Development
---------------
-------------
@@ -57,7 +57,7 @@
 /**
  * @author Rama Pulavarthi
  */
-@WebServiceProvider(targetNamespace="http://example.org/mtom", portName="HelloProviderPort", serviceName="HelloProviderService")
+@WebServiceProvider(targetNamespace="http://example.org/mtom", portName="HelloProviderPort", serviceName="HelloService")
 @ServiceMode(value= Mode.MESSAGE)
 @BindingType(value=HTTPBinding.HTTP_BINDING)
 public class HelloProviderImpl implements Provider<DataSource> {
---------------
-------------
@@ -57,7 +57,7 @@
 /**
  * @author Rama Pulavarthi
  */
-@WebServiceProvider(targetNamespace="http://example.org/mtom", portName="HelloProviderPort", serviceName="HelloService")
+@WebServiceProvider(targetNamespace="http://example.org/mtom", portName="HelloProviderPort", serviceName="HelloProviderService")
 @ServiceMode(value= Mode.MESSAGE)
 @BindingType(value=HTTPBinding.HTTP_BINDING)
 public class HelloProviderImpl implements Provider<DataSource> {
---------------
-------------
@@ -39,7 +39,7 @@
 
 	private static HudsonFixture current;
 
-	private static final HudsonFixture DEFAULT = new HudsonFixture(HUDSON_TEST_URL, "1.339", "REST");
+	private static final HudsonFixture DEFAULT = new HudsonFixture(HUDSON_TEST_URL, "1.367", "REST");
 
 	/**
 	 * Standard configurations for running all test against.
---------------
-------------
@@ -455,7 +455,7 @@
                                    int[] filterByCategories, boolean categoryRecursive, int[] filterByContentTypes )
     {
         boolean includeContentData = true;
-        return doGetContent( context, contentKeys, "", "", 0, contentKeys.length, parentLevel, childrenLevel, parentChildrenLevel,
+        return doGetContent( context, contentKeys, "", "@key asc", 0, contentKeys.length, parentLevel, childrenLevel, parentChildrenLevel,
                              includeContentData, !relatedTitlesOnly, includeUserRights, filterByCategories, categoryRecursive,
                              filterByContentTypes );
     }
---------------
-------------
@@ -36,7 +36,7 @@
     while (elements.size() < max) {
       Result result = super.parse(current);
       if (result.isFailure()) {
-        return result.success(elements);
+        return current.success(elements);
       }
       elements.add(result.get());
       current = result;
---------------
-------------
@@ -119,7 +119,7 @@
     def("whitespace", whitespace().plus());
 
     def("nameToken", ref("nameStartChar")
-      .seq(ref("nameStartChar").star())
+      .seq(ref("nameChar").star())
       .flatten());
     def("nameStartChar", pattern(NAME_START_CHARS));
     def("nameChar", pattern(NAME_CHARS));
---------------
-------------
@@ -36,7 +36,7 @@
 
     private ApiServer apiStarter;
     protected MidonetApi apiClient;
-    private EmbeddedMidolman midolman;
+    protected EmbeddedMidolman midolman;
     protected TestProbe probe;
     protected Host thisHost;
 
---------------
-------------
@@ -106,7 +106,7 @@
             for (int i = 0; i < keys.size(); i++) {
                 if (keys.get(i).equals(key)) {
                     V oldV = values.get(i);
-                    values.add(i, value);
+                    values.set(i, value);
                     return oldV;
                 }
             }
---------------
-------------
@@ -24,6 +24,7 @@
 
     @Override
     public <E2> Neo4jTraversal<S, E2> addStep(final Step<?, E2> step) {
+        if (this.strategies.complete()) throw Exceptions.traversalIsLocked();
         TraversalHelper.insertStep(step, this);
         return (Neo4jTraversal) this;
     }
---------------
-------------
@@ -79,7 +79,7 @@
         for (final Traversal<S, E> union : this.traversals) {
             clone.traversals.add(union.clone());
         }
-        this.executeTraversalOperations(NEST_OPERATIONS);
+        clone.executeTraversalOperations(NEST_OPERATIONS);
         return clone;
     }
 
---------------
-------------
@@ -36,8 +36,7 @@
  */
 public class DefaultSelectionStrategy extends LocatorSelectionStrategy implements FailoverStrategy {
 
-    // This field is made static as fix for TESB-13146
-    private static Map<QName, String> primaryAddresses = new HashMap<QName, String>();
+    private Map<QName, String> primaryAddresses = new HashMap<QName, String>();
 
     /* (non-Javadoc)
      * @see org.apache.cxf.clustering.FailoverStrategy#getAlternateAddresses(org.apache.cxf.message.Exchange)
---------------
-------------
@@ -44,7 +44,7 @@
       xtr.next();
       if (xtr.isStartElement()) {
         if (ELEMENT_EXECUTION_LISTENER.equals(xtr.getLocalName())) {
-          new ExecutionListenerParser().parseChildElement(xtr, activeProcess, model);
+          new ExecutionListenerParser().parseChildElement(xtr, parentElement, model);
         } else {
           ExtensionElement extensionElement = BpmnXMLUtil.parseExtensionElement(xtr);
           parentElement.addExtensionElement(extensionElement);
---------------
-------------
@@ -298,7 +298,7 @@
     List<IdentityLinkEntity> removedIdentityLinkEntities = new ArrayList<IdentityLinkEntity>();
     for (IdentityLinkEntity identityLinkEntity : this.getIdentityLinks()) {
       if (IdentityLinkType.CANDIDATE.equals(identityLinkEntity.getType())) {
-        if ((userId != null && identityLinkEntity.getUserId().equals(userId))
+        if ((userId != null && userId.equals(identityLinkEntity.getUserId()))
           || (groupId != null && identityLinkEntity.getGroupId().equals(groupId))) {
           Context
             .getCommandContext()
---------------
-------------
@@ -44,7 +44,7 @@
       xtr.next();
       if (xtr.isStartElement()) {
         if (ELEMENT_EXECUTION_LISTENER.equals(xtr.getLocalName())) {
-          new ExecutionListenerParser().parseChildElement(xtr, activeProcess, model);
+          new ExecutionListenerParser().parseChildElement(xtr, parentElement, model);
         } else {
           ExtensionElement extensionElement = BpmnXMLUtil.parseExtensionElement(xtr);
           parentElement.addExtensionElement(extensionElement);
---------------
-------------
@@ -298,7 +298,7 @@
     List<IdentityLinkEntity> removedIdentityLinkEntities = new ArrayList<IdentityLinkEntity>();
     for (IdentityLinkEntity identityLinkEntity : this.getIdentityLinks()) {
       if (IdentityLinkType.CANDIDATE.equals(identityLinkEntity.getType())) {
-        if ((userId != null && identityLinkEntity.getUserId().equals(userId))
+        if ((userId != null && userId.equals(identityLinkEntity.getUserId()))
           || (groupId != null && identityLinkEntity.getGroupId().equals(groupId))) {
           Context
             .getCommandContext()
---------------
-------------
@@ -50,7 +50,7 @@
       if (superExecution != null) {
         executeCatchInSuperProcess(superExecution);
       } else {
-        // TODO Shouldn't this be an exception as in executeCatchInSuperProcess()?
+        // TODO Shouldn't this be an exception as in executeCatchInSuperProcess() or is this dead code?
         LOG.info(execution.getActivity().getId() + " throws error event with errorCode '"
                 + errorCode + "', but no catching boundary event was defined. "
                 +   "Execution will simply be ended (none end event semantics).");
---------------
-------------
@@ -46,7 +46,7 @@
 			if(i % 8 == 0) countCache1[(i / 8) - 1] = sum;
 			sum += BITCOUNTS1[bytes[i] & 0xff];
 		}
-		if(countCache1.length > 0){
+		if(countCache1.length > n / 8){
 			countCache1[n / 8] = sum;
 		}
 	}
---------------
-------------
@@ -99,7 +99,7 @@
 
     private static final Logger LOG = Log.getLogger(JettyCachingLdapLoginModule.class);
 
-    private static final Pattern rolePattern = Pattern.compile("^cn=([^,]+)");
+    private static final Pattern rolePattern = Pattern.compile("^cn=([^,]+)", Pattern.CASE_INSENSITIVE);
 
     protected final String _roleMemberFilter = "member=*";
     /**
---------------
-------------
@@ -16,9 +16,6 @@
     private Point topLeftCorner;
     private Point bottomRightCorner;
 
-    /**
-     * IMPORTANT TO UNDERSTAND: the most top left corner of the plane this rectangle can be on is (0, 0)
-     */
     public Rectangle(Point topLeftCorner, Point bottomRightCorner) {
         int TLx = (int) topLeftCorner.getX();
         int TLy = (int) topLeftCorner.getY();
---------------
-------------
@@ -74,6 +74,8 @@
         this.instantiateAndSaveAllUnconnectedRegions
                 (regionParameterListInOrder);
 
+        // TODO: connect all Regions using parameter
+
         this.heapTracker.printAllHeapDataToFile("./src/test/java/model/experiments/vision/MARK_II/heapSizeLogData_BigNeocortex.txt");
     }
 
---------------
-------------
@@ -119,7 +119,7 @@
 	for (int x = 0; x < doubleIntArray.length; x++) {
 	    System.out.println();
 	    for (int y = 0; y < doubleIntArray[x].length; y++) {
-		System.out.printf("%4d", doubleIntArray[x][y]);
+		System.out.printf("%1d", doubleIntArray[x][y]);
 	    }
 	}
     }
---------------
-------------
@@ -118,7 +118,7 @@
 
 	public void printUsage() {
 		this.commandLineArgs = new String[] { "--help" };
-		run();
+		processArguments();
 	}
 
 	static {
---------------
-------------
@@ -359,7 +359,7 @@
 
 	public <T> void visitCtLiteral(CtLiteral<T> literal) {
 		if (literal.getValue() != null)
-			write(literal.getValue().toString());
+			write(literal.toString());
 		else write("null");
 	}
 
---------------
-------------
@@ -118,7 +118,7 @@
 
 	public void printUsage() {
 		this.commandLineArgs = new String[] { "--help" };
-		run();
+		processArguments();
 	}
 
 	static {
---------------
-------------
@@ -89,7 +89,7 @@
 	public <T> CtField<T> create(CtType<?> target, CtField<T> source) {
 		CtField<T> newField = factory.Core().clone(source);
 		if (target != null) {
-			target.getFields().add(newField);
+			target.addField(newField);
 		}
 		return newField;
 	}
---------------
-------------
@@ -353,6 +353,7 @@
 	public <T> void visitCtLiteral(CtLiteral<T> literal) {
 		if (literal.getValue() != null)
 			write(literal.getValue().toString());
+		else write("null");
 	}
 
 	public <T> void visitCtLocalVariable(CtLocalVariable<T> localVariable) {
---------------
-------------
@@ -98,6 +98,8 @@
                     throw new UnsupportedCallbackException(null, "Unsupported Callback Type Encountered");
                 }
             }
+        } catch (UnsupportedCallbackException ex) {
+            throw ex;
         } catch (Exception ex) {
             // catching all exceptions and making them IOExceptions. IO picked by flip of coin, neither IOException or
             // UnsupportedCallbackException are appropriate.
---------------
-------------
@@ -55,7 +55,7 @@
                     "Forbidden", HttpStatus.FORBIDDEN),ERROR_4041(4041,
             "Object not found with handle:%s", HttpStatus.NOT_FOUND),
     ERROR_4091(4091, "Object already exist for handle:%s",
-            HttpStatus.BAD_REQUEST);
+            HttpStatus.CONFLICT);
 
     private final int code;
 
---------------
-------------
@@ -51,7 +51,7 @@
     ERROR_4009(4009, "Unrecognized request URI", HttpStatus.BAD_REQUEST),
     ERROR_4010(4010, "Property '%s' value must between [%s,%s]",
             HttpStatus.BAD_REQUEST), ERROR_4041(4041,
-            "Object not found with handle:%s", HttpStatus.BAD_REQUEST),
+            "Object not found with handle:%s", HttpStatus.NOT_FOUND),
     ERROR_4091(4091, "Object already exist for handle:%s",
             HttpStatus.BAD_REQUEST);
 
---------------
-------------
@@ -55,7 +55,7 @@
                     "Forbidden", HttpStatus.FORBIDDEN),ERROR_4041(4041,
             "Object not found with handle:%s", HttpStatus.NOT_FOUND),
     ERROR_4091(4091, "Object already exist for handle:%s",
-            HttpStatus.BAD_REQUEST);
+            HttpStatus.CONFLICT);
 
     private final int code;
 
---------------
-------------
@@ -51,7 +51,7 @@
     ERROR_4009(4009, "Unrecognized request URI", HttpStatus.BAD_REQUEST),
     ERROR_4010(4010, "Property '%s' value must between [%s,%s]",
             HttpStatus.BAD_REQUEST), ERROR_4041(4041,
-            "Object not found with handle:%s", HttpStatus.BAD_REQUEST),
+            "Object not found with handle:%s", HttpStatus.NOT_FOUND),
     ERROR_4091(4091, "Object already exist for handle:%s",
             HttpStatus.BAD_REQUEST);
 
---------------
-------------
@@ -295,7 +295,7 @@
         String result = str;
         try {
             UriComponents uriComponents =
-                    UriComponentsBuilder.fromHttpUrl(str).build();
+                    UriComponentsBuilder.fromUriString(str).build();
             return uriComponents.encode().toUriString();
         } catch (Exception e) {
             LOGGER.error(e.getMessage());
---------------
-------------
@@ -295,7 +295,7 @@
         String result = str;
         try {
             UriComponents uriComponents =
-                    UriComponentsBuilder.fromHttpUrl(str).build();
+                    UriComponentsBuilder.fromUriString(str).build();
             return uriComponents.encode().toUriString();
         } catch (Exception e) {
             LOGGER.error(e.getMessage());
---------------
-------------
@@ -75,7 +75,7 @@
 public final class FCPClientReferenceImplementation {
 	
 	/** This is the core class name of the Web Of Trust plugin. Used to connect to it via FCP */
-	private static final String WOT_FCP_NAME = "plugins.WebOfTrust.WebOfTrust";
+	public static final String WOT_FCP_NAME = "plugins.WebOfTrust.WebOfTrust";
 
 	/** The amount of milliseconds between each attempt to connect to the WoT plugin */
 	private static final int WOT_RECONNECT_DELAY = 1 * 1000;
---------------
-------------
@@ -196,7 +196,7 @@
 
 	private Entity toEntity(EntityMetaData emd)
 	{
-		Entity entityMetaDataEntity = new MapEntity();
+		Entity entityMetaDataEntity = new MapEntity(META_DATA);
 		entityMetaDataEntity.set(FULL_NAME, emd.getName());
 		entityMetaDataEntity.set(SIMPLE_NAME, emd.getSimpleName());
 		if (emd.getPackage() != null)
---------------
-------------
@@ -24,7 +24,7 @@
 				public Long apply(Long input)
 				{
 					if (input == null) return null;
-					return input < threshold ? AGGREGATE_ANONYMIZATION_VALUE : input;
+					return input <= threshold ? AGGREGATE_ANONYMIZATION_VALUE : input;
 				}
 
 			});
---------------
-------------
@@ -62,6 +62,7 @@
 		// Genomebrowser stuff
 		Map<String, String> runtimePropertyMap = new HashMap<String, String>();
 
+		runtimePropertyMap.put("plugin.dataexplorer.genomebrowser", "false");
 		runtimePropertyMap.put(DataExplorerController.INITLOCATION,
 				"chr:'1',viewStart:10000000,viewEnd:10100000,cookieKey:'human',nopersist:true");
 		runtimePropertyMap.put(DataExplorerController.COORDSYSTEM,
---------------
-------------
@@ -46,6 +46,8 @@
 			molgenisRoleGroupLink.setIdentifier(UUID.randomUUID().toString());
 			molgenisRoleGroupLink.setRole(molgenisUser);
 			molgenisRoleGroupLink.setGroup(userGroup);
+			getDatabase().add(molgenisRoleGroupLink);
+
 		}
 
 		return count;
---------------
-------------
@@ -91,7 +91,7 @@
 		}
 		catch (TemplateException e)
 		{
-			throw new IOException("Backend generation failed for " + this.getClass().getSimpleName());
+			throw new IOException("Backend generation failed for " + this.getClass().getSimpleName() + "\n\nError is:\n" + e.toString());
 		}
 
 		// generate the tasks scripts
---------------
-------------
@@ -186,7 +186,7 @@
 					if (attr.getDataType() instanceof XrefField)
 					{
 						if (newValue != null) newValue = ((Entity) newValue).getIdValue();
-						if (oldValue != null) ((Entity) oldValue).getIdValue();
+						if (oldValue != null) oldValue = ((Entity) oldValue).getIdValue();
 					}
 
 					if (((null == newValue) && (null != oldValue))
---------------
-------------
@@ -196,7 +196,7 @@
 
 	private Entity toEntity(EntityMetaData emd)
 	{
-		Entity entityMetaDataEntity = new MapEntity();
+		Entity entityMetaDataEntity = new MapEntity(META_DATA);
 		entityMetaDataEntity.set(FULL_NAME, emd.getName());
 		entityMetaDataEntity.set(SIMPLE_NAME, emd.getSimpleName());
 		if (emd.getPackage() != null)
---------------
-------------
@@ -47,6 +47,6 @@
 	@Override
 	public Repository getRepositoryByEntityName(String name)
 	{
-		return new ElasticSearchRepository(client, INDEX_NAME, name);
+		return new ElasticsearchRepository(client, INDEX_NAME, name);
 	}
 }
---------------
-------------
@@ -557,7 +557,7 @@
 	{
 		Entity entity = new MapEntity();
 
-		for (AttributeMetaData attr : meta.getAttributes())
+		for (AttributeMetaData attr : meta.getAtomicAttributes())
 		{
 			String paramName = StringUtils.uncapitalize(attr.getName());
 			Object paramValue = request.get(paramName);
---------------
-------------
@@ -32,7 +32,7 @@
 
 	public Integer getNextStart()
 	{
-		if (this.start + this.num >= this.total - 1) return null;
+		if (this.start + this.num > this.total - 1) return null;
 		else return this.start + this.num;
 	}
 
---------------
-------------
@@ -183,7 +183,7 @@
 					if(value.equalsIgnoreCase(parameterName))
 					{
 						isRunTimeVariable = true;
-						continue;
+						break;
 					}
 				}
 			}
---------------
-------------
@@ -183,7 +183,7 @@
 					if(value.equalsIgnoreCase(parameterName))
 					{
 						isRunTimeVariable = true;
-						continue;
+						break;
 					}
 				}
 			}
---------------
-------------
@@ -60,6 +60,7 @@
 				{
 					occur = Operator.NOT;
 					queryRule = queryRules.get(i + 1);
+					i += 1;
 				}
 				else if (i + 1 < nrQueryRules)
 				{
---------------
-------------
@@ -31,7 +31,7 @@
 		}
 		else
 		{
-			searchRequestBuilder.setSize(100000);
+			searchRequestBuilder.setSize(1000);
 		}
 	}
 }
---------------
-------------
@@ -326,7 +326,7 @@
 
                 if (srcFiles.length > 0) {
                     if (file == null) {
-                        file = new File(srcFiles[0]);
+                        file = new File(ds.getBasedir(), srcFiles[0]);
                         filesets.removeElementAt(0);
                     } else {
                         throw new BuildException(
---------------
-------------
@@ -182,7 +182,7 @@
         benchmark.doTest(5, tests);
     }
 
-    private static abstract class TimeDateElementBenchmarkTestBase {
+    private abstract static class TimeDateElementBenchmarkTestBase {
         protected static final String months[] = { "Jan", "Feb", "Mar", "Apr",
                 "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
 
---------------
-------------
@@ -159,7 +159,7 @@
             return this;
         }
         int from = _offset+offset;
-        return new StorableKey(_buffer, from, from + _length);
+        return new StorableKey(_buffer, from, length);
     }
     
     public final byte[] rangeAsBytes(int offset, int length)
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -162,9 +162,10 @@
      *            file descriptor pointing to a full snapshot of the
      *            application's data.  The application should consume every
      *            entity represented in this data stream.
-     * @param appVersionCode The
-     *            {@link android.R.styleable#AndroidManifest_versionCode android:versionCode}
-     *            value of the application that backed up this particular data set. This
+     * @param appVersionCode The value of the <a
+     * href="{@docRoot}guide/topics/manifest/manifest-element.html#vcode">{@code
+     *            android:versionCode}</a> manifest attribute,
+     *            from the application that backed up this particular data set. This
      *            makes it possible for an application's agent to distinguish among any
      *            possible older data versions when asked to perform the restore
      *            operation.
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -93,7 +93,7 @@
                     webView.addJavascriptInterface(object, name);
                     webView.getSettings().setJavaScriptEnabled(true);
                     webView.setWebViewClient(mWebViewClient);
-                    webView.loadData("<html><head></head><body></body></html>", "text/html", null);
+                    webView.loadData("<!DOCTYPE html><title></title>", "text/html", null);
                 }
             });
             mWebViewClient.waitForOnPageFinished();
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -23,7 +23,6 @@
 
     public static String[] children() {
         return new String[] {
-                StringTest.class.getName(),
                 HashMapPerformanceTest.class.getName(),
                 ArrayListPerformanceTest.class.getName(),
                 TreeMapPerformanceTest.class.getName(),
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -56,7 +56,7 @@
     static Pattern sAddressPattern = Pattern.compile(
             /* scheme    */ "(?:(http|https|file)\\:\\/\\/)?" +
             /* authority */ "(?:([-A-Za-z0-9$_.+!*'(),;?&=]+(?:\\:[-A-Za-z0-9$_.+!*'(),;?&=]+)?)@)?" +
-            /* host      */ "([-" + GOOD_IRI_CHAR + "%_]+(?:\\.[-" + GOOD_IRI_CHAR + "%_]+)*|\\[[0-9a-fA-F:\\.]+\\])?" +
+            /* host      */ "([" + GOOD_IRI_CHAR + "%_-][" + GOOD_IRI_CHAR + "%_\\.-]*|\\[[0-9a-fA-F:\\.]+\\])?" +
             /* port      */ "(?:\\:([0-9]*))?" +
             /* path      */ "(\\/?[^#]*)?" +
             /* anchor    */ ".*", Pattern.CASE_INSENSITIVE);
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -152,7 +152,13 @@
             concatRef.refNumber = refNumber;
             concatRef.seqNumber = i + 1;  // 1-based sequence
             concatRef.msgCount = msgCount;
-            concatRef.isEightBits = false;
+            // TODO: We currently set this to true since our messaging app will never
+            // send more than 255 parts (it converts the message to MMS well before that).
+            // However, we should support 3rd party messaging apps that might need 16-bit
+            // references
+            // Note:  It's not sufficient to just flip this bit to true; it will have
+            // ripple effects (several calculations assume 8-bit ref).
+            concatRef.isEightBits = true;
             SmsHeader smsHeader = new SmsHeader();
             smsHeader.concatRef = concatRef;
 
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -26,7 +26,7 @@
     }
 
     public List<Invocation> getAll() {
-        return ListUtil.filter(invocations, new RemoveToString());
+        return ListUtil.filter(new LinkedList<Invocation>(invocations), new RemoveToString());
     }
     
     private static class RemoveToString implements Filter<Invocation> {
---------------
-------------
@@ -52,7 +52,7 @@
     public boolean matches(Invocation actual) {
         return invocation.getMock().equals(actual.getMock())
                 && hasSameMethod(actual)
-                && (argumentsMatch(actual.getArguments()) || argumentsMatch(actual.getRawArguments()));
+                && (argumentsMatch(actual.getArguments()));
     }
 
     private boolean argumentsMatch(Object[] actualArgs) {
---------------
-------------
@@ -83,6 +83,7 @@
         while (running) {
             execute(prompt());
         }
+        proxy.terminate();
     }
 
     private void displayOpening() {
---------------
-------------
@@ -182,7 +182,7 @@
         benchmark.doTest(5, tests);
     }
 
-    private static abstract class TimeDateElementBenchmarkTestBase {
+    private abstract static class TimeDateElementBenchmarkTestBase {
         protected static final String months[] = { "Jan", "Feb", "Mar", "Apr",
                 "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
 
---------------
-------------
@@ -61,7 +61,7 @@
                 .buildQueryBuilder().forEntity(Entry.class).get();
 
         org.apache.lucene.search.Query query = queryCreator.apply(queryBuilder);
-        org.apache.lucene.search.Sort sort = new Sort(new SortField("lastModifiedDate", SortField.STRING_VAL, true));
+        org.apache.lucene.search.Sort sort = new Sort(new SortField("lastModifiedDate", SortField.Type.STRING_VAL, true));
         Query jpaQuery = fullTextEntityManager
                 .createFullTextQuery(query, Entry.class)
                 .setSort(sort)
---------------
-------------
@@ -202,6 +202,11 @@
         }
     }
 
+    /**
+     * Select all and type a key.
+     * @param element to put key into
+     * @param key to enter
+     */
     public final void selectAllAndTypeKey(final int element, final Key key) {
         requestFocus(element);
 
---------------
-------------
@@ -86,7 +86,7 @@
     public static final String COMPONENT_NAME = COMPONENT_PID;
 
     public static final String DEFAULT_ADMIN_USER = "admin";
-    public static final String DEFAULT_ADMIN_ROLE = "admin";
+    public static final String DEFAULT_ADMIN_ROLE = "admin,manager,viewer";
     public static final String ROLE_DELIMITER = ",";
 
     @Reference
---------------
-------------
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) FuseSource, Inc.
  * http://fusesource.com
  *
---------------
-------------
@@ -77,7 +77,7 @@
         SchemaCompiler compiler = createSchemaCompiler();
 
         // our hashcode + timestamp ought to be enough.
-        String stem = toString() + "-" + System.currentTimeMillis();
+        String stem = toString().replaceAll("@", "_") + "-" + System.currentTimeMillis();
         File src = new File(tmpdir, stem + "-src");
         if (!src.mkdir()) {
             throw new IllegalStateException("Unable to create working directory " + src.getPath());
---------------
-------------
@@ -55,7 +55,7 @@
         String containerType = System.getProperty(CONTAINER_TYPE_PROPERTY, "child");
         int numberOfContainers = Math.max(minimumNumber, Integer.parseInt(System.getProperty(CONTAINER_NUMBER_PROPERTY, "1")));
 
-        if (maximumNumber < numberOfContainers) {
+        if (maximumNumber < numberOfContainers && maximumNumber != 0) {
             numberOfContainers = minimumNumber;
         }
 
---------------
-------------
@@ -109,7 +109,6 @@
         }
 
         bridgeConnector.setLocalBrokerConfig(createBrokerConfig(pid, "localBroker", properties));
-        bridgeConnector.setRemoteBrokerConfig(createBrokerConfig(pid, "remoteBroker", properties));
         bridgeConnector.setExportedBrokerConfig(createBrokerConfig(pid, "exportedBroker", properties));
 
 
---------------
-------------
@@ -179,7 +179,7 @@
 
             for (String key : getRestricted().keySet()) {
                 Type type = getRestricted().get(key);
-                if (type.getProvides() != null && !getEnums().containsKey(key)) {
+                if (type.getProvides() != null && !getEnums().containsKey(key) && !getDescribed().containsKey(key)) {
                     String className = getTypes() + "." + toJavaClassName(key);
                     restrictedTypes.add(new RestrictedType(this, className, type));
                 }
---------------
-------------
@@ -70,6 +70,8 @@
             .getResourceValidator(resourceId, Long.parseLong(savedReservation.getUserId())) ==
             null) {
           reservedResource.setStatus(ResourceStatus.STATUS_FOR_VALIDATION);
+        } else {
+          reservedResource.setStatus(ResourceStatus.STATUS_VALIDATE);
         }
       } else {
         reservedResource.setStatus(reservation.getStatus());
---------------
-------------
@@ -152,6 +152,7 @@
 		
 	FIREFOX(		Manufacturer.MOZILLA, null, 10, "Firefox", new String[] { "Firefox" }, null, BrowserType.WEB_BROWSER, RenderingEngine.GECKO, "Firefox\\/(([0-9]+)\\.?([\\w]+)?(\\.[\\w]+)?(\\.[\\w]+)?)"),  // using Gecko Engine
 		FIREFOX3MOBILE(	Manufacturer.MOZILLA, Browser.FIREFOX, 31, "Firefox 3 Mobile", new String[] { "Firefox/3.5 Maemo" }, null, BrowserType.MOBILE_BROWSER, RenderingEngine.GECKO, null ),  // using Gecko Engine
+		FIREFOX20(		Manufacturer.MOZILLA, Browser.FIREFOX, 101, "Firefox 20", new String[] { "Firefox/20" }, null, BrowserType.WEB_BROWSER, RenderingEngine.GECKO, null ),  // using Gecko Engine
 		FIREFOX19(		Manufacturer.MOZILLA, Browser.FIREFOX, 100, "Firefox 19", new String[] { "Firefox/19" }, null, BrowserType.WEB_BROWSER, RenderingEngine.GECKO, null ),  // using Gecko Engine
 		FIREFOX18(		Manufacturer.MOZILLA, Browser.FIREFOX, 99, "Firefox 18", new String[] { "Firefox/18" }, null, BrowserType.WEB_BROWSER, RenderingEngine.GECKO, null ),  // using Gecko Engine
 		FIREFOX17(		Manufacturer.MOZILLA, Browser.FIREFOX, 98, "Firefox 17", new String[] { "Firefox/17" }, null, BrowserType.WEB_BROWSER, RenderingEngine.GECKO, null ),  // using Gecko Engine
---------------
-------------
@@ -140,7 +140,7 @@
 
     private static Boolean qaSupplierEmailOk(String supplierEmail) {
         return Pattern.compile(
-            "digital-marketplace-development+test-supplier-\\d+@digital.cabinet-office.gov.uk"
+            "digital-marketplace-development\\+test-supplier-\\d+@digital.cabinet-office.gov.uk"
         ).matcher(supplierEmail).matches();
     }
 
---------------
-------------
@@ -140,7 +140,7 @@
 
     private static Boolean qaSupplierEmailOk(String supplierEmail) {
         return Pattern.compile(
-            "digital-marketplace-development\\+test-supplier-\\d+@digital.cabinet-office.gov.uk"
+            ".*@digital\\.cabinet-office\\.gov\\.uk"
         ).matcher(supplierEmail).matches();
     }
 
---------------
-------------
@@ -18,7 +18,7 @@
 }
 
 class CompatibilityReport{
-  boolean isCompatible;
+  boolean isCompatible=true;
   List<String> messages=new ArrayList<String>();
   public boolean isCompatible(){
     return isCompatible;
---------------
-------------
@@ -21,7 +21,7 @@
 
 class GroovycTest2 {
     static void main(String[] args) throws IOException {
-        File f = new File("build/test-classes/org/codehaus/groovy/ant/GroovycTest2_Result.txt");
+        File f = new File("build/classes/test/org/codehaus/groovy/ant/GroovycTest2_Result.txt");
         FileOutputStream fout = new FileOutputStream(f);
         try {
             fout.write("OK.".getBytes());
---------------
-------------
@@ -129,7 +129,9 @@
      */
     public void exec(String source, int lineNo, int columnNo, Object script) throws BSFException {
         try {
-            shell.run(script.toString(), source, EMPTY_ARGS);
+            // use evaluate to pass in the BSF variables
+            shell.evaluate(script.toString(), source);
+            //shell.run(script.toString(), source, EMPTY_ARGS);
         }
         catch (Exception e) {
             e.printStackTrace();
---------------
-------------
@@ -59,7 +59,7 @@
         suite.addTestSuite(FileSystemCompilerTest.class);
         suite.addTestSuite(ForTest.class);
         suite.addTestSuite(GetPropertyTest.class);
-        suite.addTestSuite(GroovyTest.class);
+        suite.addTest(GroovyTest.suite());
         suite.addTestSuite(GroovycTest.class);
         suite.addTestSuite(GroovyClassLoaderTest.class);
         suite.addTestSuite(GroovyDocToolTest.class);
---------------
-------------
@@ -361,7 +361,7 @@
     public boolean implementsInteface(String name) {
         ClassNode node = this;
         do {
-            if (declaresInterface(name)) {
+            if (node.declaresInterface(name)) {
                 return true;
             }
             node = node.getSuperClassNode();
---------------
-------------
@@ -24,7 +24,7 @@
         GeographicFacetTests.class,
         IncrementalUpdateTests.class,
 //        ItemDisplayCallnumLoppingTests.class //bad value for one test
-//        ItemInfoTests.class // bad value for one test
+        ItemInfoTests.class,
         ItemLACTests.class,
         ItemMissingTests.class,
         ItemNoCallNumberTests.class,
---------------
-------------
@@ -24,7 +24,7 @@
         GeographicFacetTests.class,
         IncrementalUpdateTests.class,
 //        ItemDisplayCallnumLoppingTests.class //bad value for one test
-//        ItemInfoTests.class // bad value for one test
+        ItemInfoTests.class,
         ItemLACTests.class,
         ItemMissingTests.class,
         ItemNoCallNumberTests.class,
---------------
-------------
@@ -86,7 +86,6 @@
    public void createCluster(
          @CliOption(key = { "name" }, mandatory = true, help = "The cluster name") final String name,
          @CliOption(key = { "distro" }, mandatory = false, help = "Hadoop Distro") final String distro,
-         @CliOption(key = { "topology" }, mandatory = false, help = "The topology type") final String topology,
          @CliOption(key = { "specFile" }, mandatory = false, help = "The spec file name path") final String specFilePath,
          @CliOption(key = { "rpNames" }, mandatory = false, help = "Resource Pools for the cluster: use \",\" among names.") final String rpNames,
          @CliOption(key = { "dsNames" }, mandatory = false, help = "Datastores for the cluster: use \",\" among names.") final String dsNames,
---------------
-------------
@@ -265,7 +265,7 @@
 
         for (final Map.Entry<String, String> entry : configuredRules.entrySet()) {
             final Pattern pattern = Pattern.compile(entry.getKey());
-            rules.put(pattern, entry.getValue().split(","));
+            rules.put(pattern, entry.getValue().split("&"));
         }
 
         return rules;
---------------
-------------
@@ -265,7 +265,7 @@
 
         for (final Map.Entry<String, String> entry : configuredRules.entrySet()) {
             final Pattern pattern = Pattern.compile(entry.getKey());
-            rules.put(pattern, entry.getValue().split(","));
+            rules.put(pattern, entry.getValue().split("&"));
         }
 
         return rules;
---------------
-------------
@@ -29,5 +29,5 @@
  * @author Ales Justin
  */
 public class JettyDeployments {
-    public static final Asset JETTY_ENV = new StringAsset("<Configure id=\"webAppCtx\" class=\"org.eclipse.jetty.webapp.WebAppContext\"><New class=\"org.eclipse.jetty.plus.naming.EnvEntry\"><Arg><Ref id=\"webAppCtx\"/></Arg><Arg>BeanManager</Arg><Arg><New class=\"javax.naming.Reference\"><Arg>javax.enterprise.inject.spi.BeanManager</Arg><Arg>org.jboss.weld.resources.ManagerObjectFactory</Arg><Arg/></New></Arg><Arg type=\"boolean\">true</Arg></New></Configure>");
+    public static final Asset JETTY_ENV = new StringAsset("<Configure id=\"webAppCtx\" class=\"org.eclipse.jetty.webapp.WebAppContext\"><New class=\"org.eclipse.jetty.plus.jndi.EnvEntry\"><Arg><Ref id=\"webAppCtx\"/></Arg><Arg>BeanManager</Arg><Arg><New class=\"javax.naming.Reference\"><Arg>javax.enterprise.inject.spi.BeanManager</Arg><Arg>org.jboss.weld.resources.ManagerObjectFactory</Arg><Arg/></New></Arg><Arg type=\"boolean\">true</Arg></New></Configure>");
 }
---------------
-------------
@@ -302,7 +302,7 @@
         if (builder != null) {
             parts.add(builder.toString());
         }
-        return parts.toArray(new String[parts.size()]);
+        return parts.isEmpty() ? null : parts.toArray(new String[parts.size()]);
     }
 
     static String detectContentType(String resourceName) {
---------------
-------------
@@ -29,5 +29,5 @@
  * @author Ales Justin
  */
 public class JettyDeployments {
-    public static final Asset JETTY_ENV = new StringAsset("<Configure id=\"webAppCtx\" class=\"org.eclipse.jetty.webapp.WebAppContext\"><New class=\"org.eclipse.jetty.plus.naming.EnvEntry\"><Arg><Ref id=\"webAppCtx\"/></Arg><Arg>BeanManager</Arg><Arg><New class=\"javax.naming.Reference\"><Arg>javax.enterprise.inject.spi.BeanManager</Arg><Arg>org.jboss.weld.resources.ManagerObjectFactory</Arg><Arg/></New></Arg><Arg type=\"boolean\">true</Arg></New></Configure>");
+    public static final Asset JETTY_ENV = new StringAsset("<Configure id=\"webAppCtx\" class=\"org.eclipse.jetty.webapp.WebAppContext\"><New class=\"org.eclipse.jetty.plus.jndi.EnvEntry\"><Arg><Ref id=\"webAppCtx\"/></Arg><Arg>BeanManager</Arg><Arg><New class=\"javax.naming.Reference\"><Arg>javax.enterprise.inject.spi.BeanManager</Arg><Arg>org.jboss.weld.resources.ManagerObjectFactory</Arg><Arg/></New></Arg><Arg type=\"boolean\">true</Arg></New></Configure>");
 }
---------------
-------------
@@ -364,8 +364,6 @@
 				 * without 'atusa' attribute to make sure an form action element is only clicked for
 				 * its defined values
 				 */
-			} else {
-				System.err.println("\n *** YOU SHOULDNT SEE MEE *** \n");
 			}
 		}
 	}
---------------
-------------
@@ -48,7 +48,7 @@
     }
 
     public boolean isCurrent() {
-        return driver.getTitle().equals("Config TOTP");
+        return driver.getTitle().equals("Google Authenticator Setup");
     }
 
     public void open() {
---------------
-------------
@@ -144,7 +144,7 @@
             UserModel admin = session.users().getUserByUsername("admin", adminRealm);
             ClientSessionModel clientSession = session.sessions().createClientSession(adminRealm, adminConsole);
             clientSession.setNote(OIDCLoginProtocol.ISSUER, AUTH_SERVER_URL + "/realms/master");
-            UserSessionModel userSession = session.sessions().createUserSession(adminRealm, admin, "admin", null, "form", false);
+            UserSessionModel userSession = session.sessions().createUserSession(adminRealm, admin, "admin", null, "form", false, null, null);
             AccessToken token = tm.createClientAccessToken(session, TokenManager.getAccess(null, adminConsole, admin), adminRealm, adminConsole, admin, userSession, clientSession);
             return tm.encodeToken(adminRealm, token);
         } finally {
---------------
-------------
@@ -219,6 +219,7 @@
 		//safe for incremental init at least the ShredBufferReaderProvider
 		//this.readerProvider = ReaderProviderFactory.createReaderProvider( cfg, this );
 		SearchFactoryImplementorWithShareableState factory = new ImmutableSearchFactory( factoryState );
+		factoryState.setActiveSearchFactory( factory );
 		rootFactory.setDelegate( factory );
 		return rootFactory;
 	}
---------------
-------------
@@ -27,7 +27,7 @@
 
 import org.hibernate.SessionFactory;
 import org.hibernate.cfg.Configuration;
-import org.hibernate.classic.Session;
+import org.hibernate.Session;
 import org.hibernate.search.test.SearchTestCase;
 
 /**
---------------
-------------
@@ -42,7 +42,7 @@
 	
 	@Override
 	public void close() {
-		lastProcessedQueue = null;
+		lastProcessedQueue = new ArrayList<LuceneWork>();
 		super.close();
 	}
 	
---------------
-------------
@@ -52,7 +52,7 @@
 public abstract class AbstractJMSHibernateSearchController implements MessageListener {
 	
 	private static final Log log = LoggerFactory.make();
-	static final String INDEX_NAME_JMS_PROPERTY = "hibernate.search.jms.indexNameProperty";
+	public static final String INDEX_NAME_JMS_PROPERTY = "hibernate.search.jms.indexNameProperty";
 
 	/**
 	 * Return the current or give a new session
---------------
-------------
@@ -49,7 +49,7 @@
 
         environment.jersey().register(new ListFilteringProvider());
 
-        environment.jersey().setUrlPattern("/api");
+        environment.jersey().setUrlPattern("/api/*");
 
         FilterRegistration.Dynamic filter = environment.servlets().addFilter("CORS", CrossOriginFilter.class);
         filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), true, "/*");
---------------
-------------
@@ -414,7 +414,7 @@
 		String whereCQL = String.format(
 			"id = %s AND shardid = %d %s",
 			uuid.toString(),
-			index.getShardingStrategy().getShardKey(uuid)+"",
+			index.getShardingStrategy().getShardKey(uuid),
 			makeAndedEqualList(def, indexValues)
 		);
 		return String.format(
---------------
-------------
@@ -419,7 +419,7 @@
 
 	protected static String makeCQLforDeleteUUIDFromIndex(CDefinition def, CIndex index, UUID uuid, Map<String,String> indexValues, long timestamp){
 		String whereCQL = String.format(
-			"id = %s AND shardid = %d %s",
+			"id = %s AND shardid = %d AND %s",
 			uuid.toString(),
 			index.getShardingStrategy().getShardKey(uuid),
 			makeAndedEqualList(def, indexValues)
---------------
-------------
@@ -330,6 +330,9 @@
 		module.setSaveState( 0 );
 		activityStack.sendNotifcations( new ActivityStackEvent( activityStack,
 				ActivityStackEvent.DONE ) );
+		
+		//Recheck module.
+		module.getModuleHandle( ).checkReport( );
 	}
 
 }
---------------
-------------
@@ -43,7 +43,7 @@
 		suite.addTestSuite( org.eclipse.birt.core.archive.compound.ArchiveFileTest.class );
 		suite.addTestSuite( org.eclipse.birt.core.archive.compound.ArchivePerformanceTest.class );
 		suite.addTestSuite( org.eclipse.birt.core.archive.compound.UpgradeArchiveTest.class );
-		suite.addTestSuite( org.eclipse.birt.core.archive.compound.AllocTableLoaderTest.class );
+//		suite.addTestSuite( org.eclipse.birt.core.archive.compound.AllocTableLoaderTest.class );
 		
 		/* in package: org.eclipse.birt.core.config */
 		suite.addTestSuite( org.eclipse.birt.core.config.FileConfigVarManagerTest.class );
---------------
-------------
@@ -352,7 +352,7 @@
 	}
 
 	public String convertUnicodeCharacterRepresentation(String input) {
-		if(! (input.contains("\\\\u") || input.contains("\\\\U")))
+		if(! (input.contains("\\u") || input.contains("\\U")))
 			return input;
 		final char[] chars = input.toCharArray();
 		for (int offset = 0; 6 + offset < chars.length;  offset++) {
---------------
-------------
@@ -24,7 +24,7 @@
 
 	private List<Builder> availableBuildersForPath(Entry childEntry) {
 		final List<Builder> buildersForPath = builders.get(childEntry.getPath());
-		return buildersForPath != null ? buildersForPath : Collections.emptyList();
+		return buildersForPath != null ? buildersForPath : Collections.<Builder>emptyList();
 	}
 
 	public void addBuilder(String path, Builder builder) {
---------------
-------------
@@ -15,6 +15,7 @@
             Callback callback) {
         if (query instanceof XFilteredQuery) {
             flattenQuery((XFilteredQuery)query, pathBoost, rewritten, reader, callback);
+            return true;
         }
         return false;
     }
---------------
-------------
@@ -84,7 +84,6 @@
 	/**
 	 * Date formats using for Date parsing.
 	 */
-	@SuppressWarnings("unchecked")
     private static final List<ThreadLocal<SimpleDateFormat>> DATETIME_FORMATS = Arrays.asList(
 			new ThreadLocal<SimpleDateFormat>()
 			{
---------------
-------------
@@ -56,6 +56,8 @@
                         .isDisplayed();
             }
         });
+        slightPause();
+        waitForPageSilence();
         return new VersionDocumentsTab(getDriver());
     }
 
---------------
-------------
@@ -7,7 +7,7 @@
  * @author Patrick Huang <a href="mailto:pahuang@redhat.com">pahuang@redhat.com</a>
  */
 @RunWith(Suite.class)
-@Suite.SuiteClasses(VersionGroupTest.class)
+@Suite.SuiteClasses({VersionGroupTest.class, VersionGroupBasicTest.class})
 public class VersionGroupTestSuite
 {
 }
---------------
-------------
@@ -114,7 +114,7 @@
             public Void call() throws Exception {
                 TranslationMemoryResourceService tmResource =
                         ServiceLocator.instance().getInstance(
-                                "translationMemoryService",
+                                "translationMemoryResource",
                                 TranslationMemoryResourceService.class);
                 String msg =
                         tmResource.deleteTranslationUnitsUnguarded(
---------------
-------------
@@ -67,7 +67,6 @@
       TextFlow stf = sr.getTextFlows().get(0);
 
       PotEntryHeader potEntryHeader = new PotEntryHeader();
-      potEntryHeader.setExtractedComment("exactedComment");
       potEntryHeader.setContext("potentrycontext");
       // for the convenience of test only
       potEntryHeader.getFlags().add("");
---------------
-------------
@@ -43,6 +43,8 @@
 import org.zanata.webtrans.shared.rpc.GetTransUnitList;
 import org.zanata.webtrans.shared.rpc.GetTransUnitListResult;
 
+import com.google.common.base.Strings;
+
 import lombok.extern.slf4j.Slf4j;
 import net.customware.gwt.dispatch.server.ExecutionContext;
 import net.customware.gwt.dispatch.shared.ActionException;
---------------
-------------
@@ -42,7 +42,7 @@
             "letters, numbers, periods, underscores and hyphens.";
 
     private By groupIdField = By.id("group-form:slugField:slug");
-    private By groupNameField = By.id("group-form:nameField:name");
+    public By groupNameField = By.id("group-form:nameField:name");
     private By groupDescriptionField = By.id("group-form:descriptionField:description");
     private By saveButton = By.id("group-form:group-create-new");
     private By createNewButton = By.id("group-form:group-create-new");
---------------
-------------
@@ -56,6 +56,8 @@
                         .isDisplayed();
             }
         });
+        slightPause();
+        waitForPageSilence();
         return new VersionDocumentsTab(getDriver());
     }
 
---------------
-------------
@@ -137,6 +137,8 @@
       registerHandler(eventBus.addHandler(UserConfigChangeEvent.TYPE, this));
 
       display.setListener(this);
+
+      display.updatePageSize(configHolder.getDocumentListPageSize());
    }
 
    @Override
---------------
-------------
@@ -71,7 +71,7 @@
          transIdStateMap.put(textFlow.getId(), textFlow.getTargets().get(hLocale.getId()).getState());
       }
 
-      GetTransUnitsNavigationService.log.debug("for action {} returned size: ", action, idIndexList.size());
+      log.info("for action {} returned size: {}", action, idIndexList.size());
       return new GetTransUnitsNavigationResult(idIndexList, transIdStateMap);
    }
 
---------------
-------------
@@ -119,7 +119,7 @@
 
    protected int lastPage()
    {
-      return pageCount - 1;
+      return pageCount == 0 ? 0 : pageCount - 1;
    }
 
    protected int getPageCount()
---------------
-------------
@@ -4,5 +4,4 @@
 
 public interface WebTransStyles extends CssResource
 {
-   String banner();
 }
---------------
-------------
@@ -120,7 +120,6 @@
       ContainerTranslationStatistics iterationStats = new ContainerTranslationStatistics();
       iterationStats.setId(iterationSlug);
       iterationStats.addRef(new Link(URI.create(zPathService.generatePathForProjectIteration(iteration)), "statSource", "PROJ_ITER"));
-
       long iterationTotalMssgs = projectIterationDAO.getTotalCountForIteration(iteration.getId());
       long iterationTotalWords = projectIterationDAO.getTotalWordCountForIteration(iteration.getId());
 
---------------
-------------
@@ -114,7 +114,7 @@
             public Void call() throws Exception {
                 TranslationMemoryResourceService tmResource =
                         ServiceLocator.instance().getInstance(
-                                "translationMemoryService",
+                                "translationMemoryResource",
                                 TranslationMemoryResourceService.class);
                 String msg =
                         tmResource.deleteTranslationUnitsUnguarded(
---------------
-------------
@@ -321,6 +321,7 @@
       }
    }
 
+   // TODO damason: add getByGlobalDocumentId(GlobalDocumentId) to documentDAO, use it, and inline this method
    protected boolean isNewDocument(GlobalDocumentId id)
    {
       return documentDAO.getByProjectIterationAndDocId(id.getProjectSlug(), id.getVersionSlug(), id.getDocId()) == null;
---------------
-------------
@@ -150,7 +150,7 @@
           
           // See if this elementary block is a NOT ( ) construct
           //
-          if (Pattern.matches("^NOT\\s*\\(.*\\)$", cleaned)) {
+          if (Pattern.matches("^NOT\\s*\\(.*\\)$", cleaned.toUpperCase())) {
             negation = true;
             cleaned = Const.trim(cleaned.substring(3));
           }
---------------
-------------
@@ -127,7 +127,7 @@
 
         // prepend/append common elements
         for (int i = 0; i < offset; i++)
-            lcs.add(0, first.get(i));
+            lcs.add(i, first.get(i));
         for (int i = firstSize - trim; i < firstSize; i++)
             lcs.add(first.get(i));
 
---------------
-------------
@@ -75,7 +75,7 @@
 
         String storage = System.getProperty("storage.location");
         if (storage == null) {
-            System.err.println("System property 'storage.file' is not set. \n" +
+            System.err.println("System property 'storage.location' is not set. \n" +
         		"This property needs to be set to the full path of the instance.properties file.");
             exit(-1);
         }
---------------
-------------
@@ -15,7 +15,8 @@
 public class EntitlementProducer {
 
     private static final String URN_SEPARATOR = ":";
-    private static final String ENTITLEMENT_SEPARATOR = "|";
+    // github/#88 - auth.sch needs semicolon as the separator, instead of a pipe
+    private static final String ENTITLEMENT_SEPARATOR = ";";
     private static final String ENTITLEMENT_PREFIX = "urn:geant:niif.hu:sch.bme.hu:entitlement:";
     private static final String MEMBER = "tag";
     // FIXME: #86 remove magic ids
---------------
-------------
@@ -35,7 +35,7 @@
         }
 
         this.url = url;
-        this.body = body;
+        this.body = body != null ? body : new byte[0];
         this.signature = signature;
         this.secret = secret;
         this.timestamp = timestamp;
---------------
-------------
@@ -839,6 +839,8 @@
     case SUPER:
     case NUMBER:
     case STRING:
+    case NO_SUBSTITUTION_TEMPLATE:
+    case TEMPLATE_HEAD:
     case NULL:
     case TRUE:
     case SLASH: // regular expression literal
---------------
-------------
@@ -1282,7 +1282,6 @@
 
       // Check if the sources need to be re-ordered.
       if (options.dependencyOptions.needsManagement() &&
-          !options.skipAllPasses &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
---------------
-------------
@@ -1140,6 +1140,7 @@
 
     private boolean validAssignmentTarget(Node target) {
       switch (target.getType()) {
+        case Token.CAST: // CAST is a bit weird, but syntactically valid.
         case Token.NAME:
         case Token.GETPROP:
         case Token.GETELEM:
---------------
-------------
@@ -1012,7 +1012,7 @@
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
-        case '\0': sb.append("\\000"); break;
+        case '\0': sb.append("\\x00"); break;
         case '\n': sb.append("\\n"); break;
         case '\r': sb.append("\\r"); break;
         case '\t': sb.append("\\t"); break;
---------------
-------------
@@ -1012,7 +1012,7 @@
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
-        case '\0': sb.append("\\000"); break;
+        case '\0': sb.append("\\x00"); break;
         case '\n': sb.append("\\n"); break;
         case '\r': sb.append("\\r"); break;
         case '\t': sb.append("\\t"); break;
---------------
-------------
@@ -79,6 +79,7 @@
     int i = 0;
     while (DecompositionType.DECOMPOSABLE == canExposeExpression(expression)) {
       exposeExpression(expression);
+      i++;
       if (i > MAX_INTERATIONS) {
         throw new IllegalStateException(
             "DecomposeExpression depth exceeded on :\n" +
---------------
-------------
@@ -40,6 +40,7 @@
 package com.google.javascript.rhino.testing;
 
 import com.google.javascript.rhino.ErrorReporter;
+
 import org.junit.Assert;
 
 /**
---------------
-------------
@@ -1140,6 +1140,7 @@
 
     private boolean validAssignmentTarget(Node target) {
       switch (target.getType()) {
+        case Token.CAST: // CAST is a bit weird, but syntactically valid.
         case Token.NAME:
         case Token.GETPROP:
         case Token.GETELEM:
---------------
-------------
@@ -1282,7 +1282,6 @@
 
       // Check if the sources need to be re-ordered.
       if (options.dependencyOptions.needsManagement() &&
-          !options.skipAllPasses &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
---------------
-------------
@@ -742,7 +742,7 @@
         return false;
       }
     }
-    return len > 0;
+    return len > 0 && s.charAt(0) != '0';
   }
 
   static double getSimpleNumber(String s) {
---------------
-------------
@@ -742,7 +742,7 @@
         return false;
       }
     }
-    return len > 0;
+    return len > 0 && s.charAt(0) != '0';
   }
 
   static double getSimpleNumber(String s) {
---------------
-------------
@@ -79,6 +79,7 @@
     int i = 0;
     while (DecompositionType.DECOMPOSABLE == canExposeExpression(expression)) {
       exposeExpression(expression);
+      i++;
       if (i > MAX_INTERATIONS) {
         throw new IllegalStateException(
             "DecomposeExpression depth exceeded on :\n" +
---------------
-------------
@@ -87,6 +87,8 @@
       } else if (callNode.getChildCount() == 3) {
         // goog.inherits(SubClass, SuperClass)
         subclass = callName.getNext();
+      } else {
+        return null;
       }
 
       if (type == SubclassType.MIXIN) {
---------------
-------------
@@ -87,6 +87,8 @@
       } else if (callNode.getChildCount() == 3) {
         // goog.inherits(SubClass, SuperClass)
         subclass = callName.getNext();
+      } else {
+        return null;
       }
 
       if (type == SubclassType.MIXIN) {
---------------
-------------
@@ -326,7 +326,7 @@
             block = cur.getLastChild();
             lastStm = block.getLastChild();
             cur = cur.getNext();
-            if (lastStm.isBreak()) {
+            if (lastStm != null && lastStm.isBreak()) {
               block.removeChild(lastStm);
               reportCodeChange();
               break;
---------------
-------------
@@ -326,7 +326,7 @@
             block = cur.getLastChild();
             lastStm = block.getLastChild();
             cur = cur.getNext();
-            if (lastStm.isBreak()) {
+            if (lastStm != null && lastStm.isBreak()) {
               block.removeChild(lastStm);
               reportCodeChange();
               break;
---------------
-------------
@@ -170,7 +170,7 @@
                     position.setCourse(Double.valueOf(value));
                     break;
                 case 'N':
-                    extendedInfo.set("battery", Double.valueOf(value));
+                    extendedInfo.set("battery", value);
                     break;
                 default:
                     // Unsupported
---------------
-------------
@@ -65,7 +65,7 @@
             "(\\p{XDigit}+)?\\|" +              // ADC3
             "(\\p{XDigit}+)\\|" +               // Battery
             "(\\p{XDigit}+)," +                 // Power
-            ".*"); // TODO: parse other stuff
+            ".*(\r\n)?");
 
     private Position decodeRegularMessage(ChannelBuffer buf) {
 
---------------
-------------
@@ -37,6 +37,7 @@
     }
 
     private static final Pattern pattern = Pattern.compile(
+            "(?:HI,\\d+)?" +
             "TK," +
             "(\\d+)," +                         // IMEI
             "(\\d{2})(\\d{2})(\\d{2})" +        // Date (YYMMDD)
---------------
-------------
@@ -57,7 +57,7 @@
             "(\\d{2})(\\d{2})(\\d{2})," +       // Date (DDMMYY)
             "[^\\|]+\\|(\\d+\\.\\d)\\|" +       // Dilution of precision
             "(\\d+)\\|" +                       // Altitude
-            "([0-9a-fA-F]+)\\|" +               // State
+            "([0-9a-fA-F]+)" +                  // State
             ".*"); // TODO: parse ADC
 
     /**
---------------
-------------
@@ -48,7 +48,7 @@
             "([AV])," +                         // Validity
             "([\\d]{2})([\\d]{2}.[\\d]{4})," +  // Latitude (DDMM.MMMM)
             "([NS])," +
-            "([\\d]{3})([\\d]{2}.[\\d]{4})," +  // Longitude (DDDMM.MMMM)
+            "([\\d]{2,3})([\\d]{2}.[\\d]{4})," + // Longitude (DDDMM.MMMM)
             "([EW])," +
             "([\\d]+.[\\d]+)," +                // Speed
             "([\\d]+.[\\d]+)?," +               // Course
---------------
-------------
@@ -42,7 +42,7 @@
      */
     static private Pattern pattern = Pattern.compile(
             "\\+RESP:GT...," +
-            "\\d{6}," +                         // Protocol version
+            "[0-9a-fA-F]{6}," +                 // Protocol version
             "(\\d{15})," +                      // IMEI
             "[^,]*," +                          // Device name
             "(?:(?:\\d," +                      // Report ID / Geo mode
---------------
-------------
@@ -42,7 +42,7 @@
             "([EW])" +
             "(\\d{3}\\.\\d{3})" +          // Speed
             "(\\d{2})(\\d{2})(\\d{2})" +   // Date (DDMMYY)
-            "\\d+\\)");
+            "\\d+.*\\)\\]?");
 
     @Override
     protected Object decode(
---------------
-------------
@@ -53,7 +53,7 @@
             "(\\d{3})" +                   // Course
             "\\d" +                        // Fix mode
             "(\\d)" +                      // Fix age
-            ".*");
+            ".*\r?\n?");
 
     private Date getTime(long week, long day, long seconds) {
         Calendar time = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
---------------
-------------
@@ -41,7 +41,7 @@
 
         // Read message
         int length = Integer.parseInt(buf.toString(2, 2, Charset.defaultCharset()), 16);
-        if (length >= buf.readableBytes()) {
+        if (length <= buf.readableBytes()) {
             return buf.readBytes(length);
         }
 
---------------
-------------
@@ -187,7 +187,7 @@
             "(\\d{2})(\\d{2}\\.\\d+)," +   // Latitude (DDMM.MMMM)
             "(\\d+\\.?\\d*)," +            // Altitude
             "(\\d+\\.?\\d*)," +            // Speed
-            "(\\d+)," +                    // Course
+            "(\\d+\\.?\\d*)," +            // Course
             "(\\d+)," +                    // Satellites
             "(\\d+\\.?\\d*)");             // HDOP
     
---------------
-------------
@@ -137,7 +137,7 @@
 
                 position.setLongitude(buf.readInt() / 10000000.0);
                 position.setLatitude(buf.readInt() / 10000000.0);
-                position.setAltitude((double) buf.readUnsignedShort());
+                position.setAltitude((double) buf.readShort());
                 position.setCourse((double) buf.readUnsignedShort());
 
                 int satellites = buf.readUnsignedByte();
---------------
-------------
@@ -45,7 +45,7 @@
             "([\\d]+)," +                       // IMEI
             "[^,]+," +
             "(\\d{2})(\\d{2})(\\d{2})[\\d]+," + // Date
-            "[+]?[\\d]*," +
+            "[^,]*," +
             "[FL]," +                           // F - full / L - low
             "([\\d]{2})([\\d]{2})([\\d]{2}).([\\d]{3})," + // Time (HHMMSS.SSS)
             "([AV])," +                         // Validity
---------------
-------------
@@ -54,7 +54,7 @@
             "(\\d+.\\d)?," +             // Speed
             "(\\d+.\\d)?," +             // Course
             "(\\d{2})(\\d{2})(\\d{2})," + // Date (DDMMYY)
-            ".*[\r\n]*");
+            ".*[\r\n\u0000]*");
 
     public static final int IMEI_LENGTH = 15;
 
---------------
-------------
@@ -44,7 +44,7 @@
     static private Pattern pattern = Pattern.compile(
             "[\r\n]*" +
             "(\\d+)," +                         // Serial
-            "(\\+\\d+)," +                      // Number
+            "(\\+?\\d+)," +                      // Number
             "GPRMC," +
             "(\\d{2})(\\d{2})(\\d{2})\\.(\\d{3})," + // Time (HHMMSS.SSS)
             "([AV])," +                         // Validity
---------------
-------------
@@ -83,7 +83,7 @@
             if (codec == CODEC_GH3000) {
 
                 long time = buf.readUnsignedInt() & 0x3fffffff;
-                time += 1199145600; // 2008-01-01 00:00:00
+                time += 1167609600; // 2007-01-01 00:00:00
                 position.setTime(new Date(time * 1000));
                 
                 globalMask = buf.readUnsignedByte();
---------------
-------------
@@ -41,7 +41,7 @@
         int b3 = buf.readUnsignedByte(); if (b3 > 0x80) b3 -= 0x80;
         int b4 = buf.readUnsignedByte();
         String serialNumber = String.format("%02d%02d%02d%02d", b1, b2, b3, b4);
-        return String.valueOf(Integer.valueOf(serialNumber));
+        return String.valueOf(Long.valueOf(serialNumber));
     }
 
     private static final int MSG_LOGIN = 0xB1;
---------------
-------------
@@ -41,7 +41,7 @@
             "(\\d{2}):?(\\d{2})(?:\\d{2})?," +  // Local Time
             "[^,]*," +
             "[FL]," +                           // F - full / L - low
-            "(\\d{2})(\\d{2})(\\d{2})\\.(\\d{3})," + // Time UTC (HHMMSS.SSS)
+            "(\\d{2})(\\d{2})(\\d{2})\\.(\\d+)," + // Time UTC (HHMMSS.SSS)
             "([AV])," +                         // Validity
             "(\\d+)(\\d{2}\\.\\d+)," +          // Latitude (DDMM.MMMM)
             "([NS])," +
---------------
-------------
@@ -30,7 +30,8 @@
      * @See: 
      *       http://en.wikipedia.org/wiki/Low-pass_filter#Discrete-time_realization
      */
-    static final float ALPHA = 0.25f; // if ALPHA = 1 OR 0, no filter applies.
+ // if ALPHA = 1 OR 0, no filter applies.
+    static final float ALPHA = 0.25f; 
 
     /*
      * (non-Javadoc)
---------------
-------------
@@ -93,7 +93,6 @@
      */
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
-        track = trackUtil.getLastTrack();
         Log.d(TAG, "onStartCommand");
         return START_STICKY;
     }
---------------
-------------
@@ -433,7 +433,7 @@
 	public String getMetaDescription() {
 		String fullMeta = getTitle() + " " + getMarkedDescription();
 		int index = Math.min(fullMeta.length(), 200);
-		return fullMeta.substring(0, index-1);
+		return fullMeta.substring(0, index);
 	}
 
 	public String getLinkPath() {
---------------
-------------
@@ -128,6 +128,9 @@
         processType(type);
       } catch (CompileException e) {
         // We abandoned this type, but continue with the next.
+      } catch (RuntimeException e) {
+        // Don't propagate this exception, which will confusingly crash the compiler.
+        reportError("@AutoValue processor threw an exception: " + e, type);
       }
     }
   }
---------------
-------------
@@ -68,7 +68,7 @@
 			if (href != null || name != null) {
 				Link link = new Link.Builder().label(text).href(href).name(name).build();
 				log.debug("constructed link: {} from {} must match: {}", new Object[] { link, linkElement, matcher });
-				if (matcher == null || link.getHref().contains(matcher)) {
+				if (matcher == null || (link.getHref() != null && link.getHref().contains(matcher))) {
 					links.add(link);
 				}
 			}
---------------
-------------
@@ -26,7 +26,7 @@
 
 		//super(new GLCapabilities( GLProfile.getDefault() )); //GLJPanel
 		//super(RendererJogl.caps); //GLJPanel or GLCanvas	
-		super(null);
+		super();
 	}
 
 	
---------------
-------------
@@ -58,7 +58,7 @@
 	OWLConnection conn = null;
 	OWLStatement st = null;
 	OBDADataFactory fac = OBDADataFactoryImpl.getInstance();
-	String owlFile = "//Users/timi/Documents/workspace/obdalib-parent/quest-owlapi3/src/test/resources/describeConstruct.owl";
+	String owlFile = "src/test/resources/describeConstruct.owl";
 	
 	@Override
 	public void setUp() throws Exception {
---------------
-------------
@@ -633,6 +633,7 @@
 			Variable var = ofac.getVariable(v.getName());
 			int direction = 0;
 			if (c.isAscending()) direction = 1;
+            else direction = 2;
 			pr.getQueryModifiers().addOrderCondition(var, direction);
 		}
 		te = order.getArg(); // narrow down the query
---------------
-------------
@@ -8,6 +8,7 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Cagatay Calli <ccalli@gmail.com> - [find/replace] retain caps when replacing - https://bugs.eclipse.org/bugs/show_bug.cgi?id=28949
+ *     Cagatay Calli <ccalli@gmail.com> - [find/replace] define & fix behavior of retain caps with other escapes and text before \C - https://bugs.eclipse.org/bugs/show_bug.cgi?id=217061
  *******************************************************************************/
 package org.eclipse.jface.text;
 
---------------
-------------
@@ -200,7 +200,7 @@
         {
             LOG.warn( "problem during normalizing path.", e );
         }
-        return out;
+        return out.replace( File.separatorChar, '/' );
     }
 
 }
---------------
-------------
@@ -252,7 +252,7 @@
 					break;
 				}
 			}
-			if (j == path.size()) {
+			if (j == path.size()-1) {
 				results.put(p, true);
 			} else {
 				results.put(p, false);
---------------
-------------
@@ -43,7 +43,7 @@
     private static final Pattern WMF_APP_RIM_UA_PAT     = Pattern.compile("Mozilla/5.0 \\(PlayBook; U; RIM Tablet OS.*\\).*");
     private static final Pattern WMF_APP_WINDOWS_UA_PAT = Pattern.compile(Pattern.quote("Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0; MSAppHost/1.0)")); //VERIFIED
     // TODO update iOS matching after WikipediaMobile is prepended to it once again
-    private static final Pattern WMF_APP_IOS            = Pattern.compile("Mozilla/5.0(?!Safari).*iPhone(?!Safari).*");
+    private static final Pattern WMF_APP_IOS            = Pattern.compile("Mozilla/5.0(?!.*\\bSafari\\b).*iPhone(?!.*\\bSafari\\b).*");
 
     private static final Map<String, Pattern> WMF_APP_PATTERNS = new HashMap<String, Pattern>();
     static {
---------------
-------------
@@ -265,7 +265,7 @@
      * size {@code n}, the mean is {@code n * m / N}.
      */
     public double getNumericalMean() {
-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();
+        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());
     }
 
     /**
---------------
-------------
@@ -375,6 +375,7 @@
      */
     public synchronized void clear() {
         numElements = 0;
+        startIndex = 0;
         internalArray = new double[initialCapacity];
     }
     
---------------
-------------
@@ -294,7 +294,7 @@
      */
     private SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {
         SubHyperplane<S> s = sub;
-        for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {
+        for (BSPTree<S> tree = this; tree.parent != null && s != null; tree = tree.parent) {
             if (tree == tree.parent.plus) {
                 s = s.split(tree.parent.cut.getHyperplane()).getPlus();
             } else {
---------------
-------------
@@ -1,3 +1,20 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package org.apache.commons.math3.ode.sampling;
 
 import static org.junit.Assert.assertArrayEquals;
---------------
-------------
@@ -409,7 +409,7 @@
      * @since 1.1
      */
     public static int gcd(int u, int v) {
-        if (u * v == 0) {
+        if ((u == 0) || (v == 0)) {
             return (Math.abs(u) + Math.abs(v));
         }
         // keep u and v negative, as negative integers range down to
---------------
-------------
@@ -38,7 +38,7 @@
 		page.addDriverLibrary(dd.getDriverLibrary());
 		page.setDriverClass(cfg.getDriverClass());
 		ddw.finish();
-		preferencePage.ok();
+		preferenceDialog.ok();
 	}
 
 	/**
---------------
-------------
@@ -20,7 +20,7 @@
  */
 public class AssignableBeansDialogExt extends AssignableBeansDialog {
 
-	private final String ELIMINATED_DEFAULT_BEAN = "Eliminated @DefaultBean";
+	private static final String ELIMINATED_DEFAULT_BEAN = "Eliminated @DefaultBean";
 	
 	public AssignableBeansDialogExt(SWTBotShell shell) {
 		super(shell);	
---------------
-------------
@@ -17,7 +17,7 @@
 	}
 	
 	public void open() {
-		new ContextMenu("JPA Tools","Generate Tables from Tables...").select();
+		new ContextMenu("JPA Tools","Generate Tables from Entities...").select();
 	}
 	
 	public void finish() {	
---------------
-------------
@@ -26,7 +26,7 @@
 		 String javaVersion = System.getProperty("java.specification.version");
 		  log.info("Is running on MacOS: " + SWTJBTExt.isRunningOnMacOs());
 		  log.info("Java version: " + javaVersion);
-		  if ("1.7".equals(javaVersion)){
+		  if ("1.7".equals(javaVersion) || "1.8".equals(javaVersion)){
 			  log.info("default AWT toolkit: " + System.getProperty("awt.toolkit"));
 			  System.setProperty("awt.toolkit", "sun.lwawt.macosx.LWCToolkit");
 			  log.info("AWT toolkit changed to: " + System.getProperty("awt.toolkit"));
---------------
-------------
@@ -38,6 +38,9 @@
 @Require(perspective="Java EE", 
 		server=@Server(type=ServerType.JbossAS, 
 		version = "7.1", operator = ">="))
+//@Require(perspective="Java EE", 
+//		server=@Server(type=ServerType.EAP, 
+//		version = "5.1", operator = ">="))
 @RunWith(RequirementAwareSuite.class)
 @SuiteClasses({ WSAllBotTests.class })
 public class WSTestBase extends SWTTestExt {
---------------
-------------
@@ -124,7 +124,7 @@
     }
 
     public Path getChunkPath(Vector3i chunkPos) {
-        return worldsPath.resolve(getChunkFilename(chunkPos));
+        return worldPath.resolve(getChunkFilename(chunkPos));
     }
 
     public Path getChunkTempPath(Vector3i chunkPos) {
---------------
-------------
@@ -50,7 +50,7 @@
     }
 
     public boolean isTemplate() {
-        return template;
+        return template || familyFactory == null;
     }
 
     public void setTemplate(boolean template) {
---------------
-------------
@@ -1393,7 +1393,7 @@
 
 				validateBlockElement(
 					fileName, element,
-					new String[] {"execute", "var", "property"},
+					new String[] {"execute", "property", "var"},
 					new String[] {"action", "macro", "test-case"},
 					new String[] {"var"}, new String[0]);
 			}
---------------
-------------
@@ -755,7 +755,7 @@
 			return null;
 		}
 
-		if (Validator.isNull(oldSub)) {
+		if ((oldSub == null) || (oldSub.equals(StringPool.BLANK))) {
 			return s;
 		}
 
---------------
-------------
@@ -519,7 +519,7 @@
 	protected void moveDependentsToTrash(long nodeId, long trashEntryId)
 		throws PortalException {
 
-		List<WikiPage> pages = wikiPagePersistence.findByN_H(nodeId, true);
+		List<WikiPage> pages = wikiPagePersistence.findByNodeId(nodeId);
 
 		for (WikiPage page : pages) {
 			wikiPageLocalService.moveDependentToTrash(page, trashEntryId);
---------------
-------------
@@ -29,7 +29,7 @@
 
 		testSuite.addTestSuite(AddQuestionTest.class);
 		testSuite.addTestSuite(AddVoteTest.class);
-		//testSuite.addTestSuite(ViewQuestionGraphsTest.class);
+		testSuite.addTestSuite(ViewQuestionGraphsTest.class);
 		testSuite.addTestSuite(AddQuestion2Test.class);
 		testSuite.addTestSuite(EditQuestionTest.class);
 		testSuite.addTestSuite(ExpireQuestionTest.class);
---------------
-------------
@@ -32,6 +32,7 @@
 
 		testSuite.addTestSuite(AssertNoLDAPUsersTest.class);
 		testSuite.addTestSuite(EnableLDAPTest.class);
+		testSuite.addTestSuite(AddLDAPServerTest.class);
 		testSuite.addTestSuite(AssertLDAPConnectionTest.class);
 		testSuite.addTestSuite(AssertLDAPUsersTest.class);
 		testSuite.addTestSuite(LogoutTest.class);
---------------
-------------
@@ -268,7 +268,7 @@
            } else if (stepStats instanceof LocalStepStats) {
                // map & reduce kind of run as one, so just add one to both if there's a group.
                incrementCounts(taskCounts, countsKey, flowName, stepName, 1, 0, 0, 0);
-               if (flowStep.getGroup() != null) {
+               if (flowStep.getGroups().size() > 0) {
                    incrementCounts(taskCounts, countsKey, flowName, stepName, 0, 1, 0, 0);
                }
            } else {
---------------
-------------
@@ -18,7 +18,7 @@
 
     public MinDaysBetweenDisbursalAndFirstRepaymentViolationException(final LocalDate disbursalDate, final LocalDate firstRepaymentDate,
             Integer minimumDaysBetweenDisbursalAndFirstRepayment) {
-        super("error.msg.loan.days.between.first.repayment.and.disbursal.are.less.than.minimum.allowed.numbers",
+        super("error.msg.loan.days.between.first.repayment.and.disbursal.are.less.than.minimum.allowed",
                 "Number of days between loan disbursal  (" + disbursalDate + ") and first repayment (" + firstRepaymentDate
                         + ") can't be less than (" + minimumDaysBetweenDisbursalAndFirstRepayment + ").", disbursalDate,
                 firstRepaymentDate, minimumDaysBetweenDisbursalAndFirstRepayment);
---------------
-------------
@@ -1,7 +1,6 @@
 package org.ethereum.core;
 
 import org.ethereum.crypto.HashUtil;
-import org.ethereum.manager.WorldManager;
 import org.ethereum.util.RLP;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
---------------
-------------
@@ -519,7 +519,7 @@
             // second, get the agent version info (by peeking into the agent update binary jar)
             JarFile binaryJarFile = new JarFile(binaryFile);
             try {
-                JarEntry binaryJarFileEntry = binaryJarFile.getJarEntry("rhq-agent-update-version.properties");
+                JarEntry binaryJarFileEntry = binaryJarFile.getJarEntry("/rhq-agent-update-version.properties");
                 InputStream binaryJarFileEntryStream = binaryJarFile.getInputStream(binaryJarFileEntry);
 
                 // now write the server and agent version info in our internal version file our servlet will use
---------------
-------------
@@ -125,7 +125,7 @@
                 } else {
                     Agent agentByAddressPort = getAgentManager().getAgentByAddressAndPort(request.getAddress(),
                         request.getPort());
-                    if (agentByAddressPort != null) {
+                    if (agentByAddressPort != null && !agentByAddressPort.getName().equals(request.getName())) {
                         // the agent request provided information about an authentic agent but it is trying to 
                         // steal another agent's host/port. Thus, we will abort this request.
                         String msg = "The agent asking for registration [" + request.getName()
---------------
-------------
@@ -251,7 +251,7 @@
 
             for (int bytesRead = input.read(buffer); bytesRead != -1; bytesRead = input.read(buffer)) {
                 if (htmlEscape) {
-                    String htmlEncodedStr = forHTMLTag(new String(buffer));
+                    String htmlEncodedStr = forHTMLTag(new String(buffer, 0, bytesRead));
                     bytesRead = htmlEncodedStr.length();
                     output.write(htmlEncodedStr.getBytes(), 0, bytesRead);
                 } else {
---------------
-------------
@@ -1271,6 +1271,7 @@
                 throw new InvalidExpressionException("Redundant 'memberof' expression[" + normalizedSubExpression
                     + "] - these expressions must be unique");
             }
+            memberSubExpressions.add(normalizedSubExpression);
         } else {
             if (groupedSubExpressions.contains(normalizedSubExpression)) {
                 throw new InvalidExpressionException(
---------------
-------------
@@ -261,7 +261,7 @@
     }
 
     private Map<Integer, DateTime> calculateAggregates(String fromColumnFamily, String toColumnFamily,
-                                                       Minutes interval, Minutes nextInterval, int ttl) {
+        Minutes interval, Minutes nextInterval, int ttl) {
         DateTime currentHour = getCurrentHour();
         DateTimeComparator dateTimeComparator = DateTimeComparator.getInstance();
 
---------------
-------------
@@ -90,7 +90,7 @@
         // We want to return the attached object but sessionmanager.put will return a detached copy of newSubject.
         // Copy over the sessionId and pass back the attached Subject.
         Subject sessionSubject = SessionManager.getInstance().put(newSubject, 1000 * 300);
-        newSubject.setSessionId(sessionSubject.getId());
+        newSubject.setSessionId(sessionSubject.getSessionId());
         return newSubject;
     }
 
---------------
-------------
@@ -127,7 +127,7 @@
     private long mtime = System.currentTimeMillis();
 
     @Column(name = "LAST_AVAILABILITY_REPORT")
-    private long lastAvailabilityReport;
+    private Long lastAvailabilityReport;
 
     @JoinColumn(name = "AFFINITY_GROUP_ID", referencedColumnName = "ID", nullable = true)
     @ManyToOne
---------------
-------------
@@ -872,7 +872,7 @@
             str.append(" [");
 
             // stored in seconds but present in minutes
-            String value = String.valueOf(Integer.valueOf(condition.getOption()) * 60);
+            String value = String.valueOf(Integer.valueOf(condition.getOption()) / 60);
             String formatted = MeasurementConverter.format(value, MeasurementUnits.MINUTES);
             str.append(formatted);
             str.append("]");
---------------
-------------
@@ -136,6 +136,7 @@
             details.setFileSize(pkg.getFileSize());
             details.setFileCreatedDate(pkg.getFileCreatedDate());
             details.setSHA256(pkg.getSha256());
+            details.setMD5(pkg.getMd5());
             details.setLicenseName(pkg.getLicenseName());
             details.setLicenseVersion(pkg.getLicenseVersion());
             if (pkg.getMetadata() != null) {
---------------
-------------
@@ -101,7 +101,7 @@
             for (int i = 0; i < len; i++) {
                 Object item = Array.get(obj, i);
                 if (item == null) {
-                    descriptor.setProperty(i++, null);
+                    descriptor.setProperty(i, null);
                 } else {
                     JavaBeanDescriptor itemDescriptor = createDescriptorIfAbsent(item, accessor, cache);
                     descriptor.setProperty(i, itemDescriptor);
---------------
-------------
@@ -46,7 +46,7 @@
             artifact.setExtendedType(KieJarModel.KieXmlDocument);
             return artifact;
         }
-        if (name.endsWith(".bpmn") || name.endsWith(".bpmn2")) { //$NON-NLS-1$
+        if (name.endsWith(".bpmn") || name.endsWith(".bpmn2")) { //$NON-NLS-1$ //$NON-NLS-2$
             ExtendedDocument artifact = new ExtendedDocument();
             artifact.setArtifactType(BaseArtifactEnum.EXTENDED_DOCUMENT);
             artifact.setExtendedType(KieJarModel.BpmnDocument);
---------------
-------------
@@ -48,7 +48,7 @@
         }
     }
 
-    private static Configuration configuration = null;
+    private Configuration configuration = null;
 
     protected synchronized void read() {
         try {
---------------
-------------
@@ -46,7 +46,7 @@
             artifact.setExtendedType(KieJarModel.KieXmlDocument);
             return artifact;
         }
-        if (name.endsWith(".bpmn") || name.endsWith(".bpmn2")) { //$NON-NLS-1$
+        if (name.endsWith(".bpmn") || name.endsWith(".bpmn2")) { //$NON-NLS-1$ //$NON-NLS-2$
             ExtendedDocument artifact = new ExtendedDocument();
             artifact.setArtifactType(BaseArtifactEnum.EXTENDED_DOCUMENT);
             artifact.setExtendedType(KieJarModel.BpmnDocument);
---------------
-------------
@@ -48,7 +48,7 @@
         }
     }
 
-    private static Configuration configuration = null;
+    private Configuration configuration = null;
 
     protected synchronized void read() {
         try {
---------------
-------------
@@ -148,7 +148,6 @@
 	 * @throws SrampClientException
 	 * @throws SrampServerException
 	 */
-	@SuppressWarnings("resource")
 	public Map<String, ?> uploadBatch(SrampArchive archive) throws SrampClientException, SrampServerException {
 		File packageFile = null;
 		InputStream packageStream = null;
---------------
-------------
@@ -1,4 +1,4 @@
-package org.gradle.api.plugins.sonar.runner.SonarRunnerSmokeIntegrationTest.shared.nested.nested2.nestedProject.src.test.java.org.gradle.test.nestedProject;
+package org.gradle.test.nestedProject;
 
 import static org.junit.Assert.*;
 
---------------
-------------
@@ -22,7 +22,7 @@
  * An enumeration of Java versions.
  */
 public enum JavaVersion {
-    VERSION_1_1(false), VERSION_1_2(false), VERSION_1_3(false), VERSION_1_4(false), VERSION_1_5(true), VERSION_1_6(true);
+    VERSION_1_1(false), VERSION_1_2(false), VERSION_1_3(false), VERSION_1_4(false), VERSION_1_5(true), VERSION_1_6(true), VERSION_1_7(true);
 
     private final boolean hasMajorVersion;
 
---------------
-------------
@@ -1,4 +1,4 @@
-package org.gradle.test.nestedProject;
+package org.gradle.api.plugins.sonar.runner.SonarRunnerSmokeIntegrationTest.shared.nested.nested2.nestedProject.src.test.java.org.gradle.test.nestedProject;
 
 import static org.junit.Assert.*;
 
---------------
-------------
@@ -45,7 +45,7 @@
     public String getClassName() {
         if (className == null) {
             URI sourceUri = resource.getURI();
-            String name = StringUtils.substringBeforeLast(StringUtils.substringAfterLast(sourceUri.getPath(), "/"), ".");
+            String name = StringUtils.substringBeforeLast(StringUtils.substringAfterLast(sourceUri.toString(), "/"), ".");
             StringBuilder className = new StringBuilder(name.length());
             for (int i = 0; i < name.length(); i++) {
                 char ch = name.charAt(i);
---------------
-------------
@@ -26,7 +26,7 @@
         if (x2 < x1) {
             x2 += 360;
         }
-        return rectangle(x1, lat1, x2, lon2);
+        return rectangle(x1, lat1, x2, lat2);
     }
 
     public static Point pointLatLong(double lon, double lat) {
---------------
-------------
@@ -9,6 +9,11 @@
 import org.opennaas.extensions.sdnnetwork.model.Port;
 import org.opennaas.extensions.sdnnetwork.model.Route;
 
+/**
+ * 
+ * @author Adrian Rosello (i2CAT)
+ * 
+ */
 public abstract class FlowRequestHelper {
 
 	public static FlowRequest generateSampleFlowRequest() {
---------------
-------------
@@ -94,6 +94,7 @@
 			// //// run the matching and mapping/////
 			// Global.rowNum=8;
 			// Global.cellNum=8;
+			Global.PNodeChoice = 1;
 			Global.pathChoice = 1;
 			Global.maxPathLinksNum = 5;
 			// Global.staticNet=1;
---------------
-------------
@@ -102,7 +102,7 @@
 	@Configuration
 	public static Option[] configuration() {
 		return options(opennaasDistributionConfiguration(),
-				includeFeatures("opennaas-router", "opennaas-junos", "itests-helpers"),
+				includeFeatures("opennaas-router", "opennaas-router-driver-junos", "itests-helpers"),
 				noConsole(),
 				keepRuntimeFolder());
 	}
---------------
-------------
@@ -119,7 +119,7 @@
 				paramsOK = false;
 			} else if (!IPUtilsHelper.isIPValidAddress(aParams[0])
 					||
-					(!aParams[1].equals("") && !IPUtilsHelper.isIPWithoutMaskValidAddress(aParams[1]))) {
+					(!aParams[1].equals("") && !(IPUtilsHelper.isIPWithoutMaskValidAddress(aParams[1])))) {
 				paramsOK = false;
 			} else if (IPUtilsHelper.isIPv4ValidAddress(aParams[0]) && (!aParams[1].equals("")) && (!IPUtilsHelper
 					.validateIpAddressPattern(aParams[1]))) {
---------------
-------------
@@ -70,7 +70,7 @@
 				return null;
 			}
 
-			IPProtocolEndpoint ipProtocolEndpoint = new IPProtocolEndpoint();
+			IPProtocolEndpoint ipProtocolEndpoint = getIPProtocolEndpoint();
 			NetworkPort networkPort = getNetworkPort();
 
 			if (networkPort == null) {
---------------
-------------
@@ -158,7 +158,7 @@
     @Override
     public boolean equals(final Object that) {
         if (that == this) return true;
-        if (getClass() != this.getClass()) return false;
+        if (getClass() != that.getClass()) return false;
         return name().equals(((Term)that).name());
     }
 
---------------
-------------
@@ -90,7 +90,7 @@
     private boolean isPlannable(final Term goal) {
         /** must be in the graph and have at least one incoming edge */
         if (implication.containsVertex(goal)) {
-            return implication.inDegreeOf(goal) > 0;
+            return implication.inDegreeOf(new PostCondition(goal)) > 0;
         }
         return false;
     }
---------------
-------------
@@ -48,7 +48,6 @@
                     if (Parameters.DEBUG) {
                         t.printStackTrace();
                     }
-                    r.notify(Exception.class, Event.wrap(t));
                     emit(Output.ERR.class, t);
                 }
             }
---------------
-------------
@@ -15,7 +15,7 @@
 public class NALTestSome extends NALTest {
 
    public static boolean include(String filename) {
-       return filename.startsWith("nal6.14");
+       return filename.startsWith("nal1.multistep");
    }
 
    
---------------
-------------
@@ -53,7 +53,7 @@
 
     private final boolean isNumeric(int type)
     {
-        return (type & ITokenType.TT_NUMERIC) != 0;
+        return (type & ITokenType.TYPE_MASK) == ITokenType.TT_NUMERIC;
     }
 
     public boolean isEnabled()
---------------
-------------
@@ -76,7 +76,7 @@
         }
 
         // Create regexp patterns for each query word
-        final String [] queryWords = query.split("\\s");
+        final String [] queryWords = query.split("\\s+");
         final Pattern [] queryPatterns = new Pattern [queryWords.length];
         for (int i = 0; i < queryWords.length; i++)
         {
---------------
-------------
@@ -67,8 +67,6 @@
  * <ol>
  * <li>{@link org.carrot2.source.microsoft.BingDocumentSource} through the
  * {@link org.carrot2.source.microsoft.BingDocumentSource#market} attribute,</li>
- * <li>{@link org.carrot2.source.boss.BossDocumentSource} through the
- * {@link org.carrot2.source.boss.BossSearchService#languageAndRegion} attribute,</li>
  * <li>{@link org.carrot2.source.etools.EToolsDocumentSource} through the
  * {@link org.carrot2.source.etools.EToolsDocumentSource#language} attribute.</li>
  * </ol>
---------------
-------------
@@ -75,7 +75,7 @@
         }
 
         // Create regexp patterns for each query word
-        final String [] queryWords = query.split("\\s+");
+        final String [] queryWords = query.replace("\"", "").split("\\s+");
         final Pattern [] queryPatterns = new Pattern [queryWords.length];
         for (int i = 0; i < queryWords.length; i++)
         {
---------------
-------------
@@ -149,7 +149,7 @@
                 }
 			});
 
-            for (int i=0;i<dependencies.length-1;i++) {
+            for (int i=0;i<dependencies.length;i++) {
                 ComponentDependency dependency = dependencies[i];
                 
                 if (dependency.getName().equals( component.getName() )) {
---------------
-------------
@@ -2390,7 +2390,7 @@
 
     @Override
     public void visit(NameIdentifierNode nameIdentifierNode) throws Exception {
-      EntityRef ref = em.getAlias(headEntity.getUuid(), collection.getName(), nameIdentifierNode.getName());
+      EntityRef ref = em.getAlias(headEntity.getUuid(), collection.getType(), nameIdentifierNode.getName());
 
       if(ref == null){
         this.results.push(new EmptyIterator());
---------------
-------------
@@ -43,6 +43,13 @@
  * will match a significant amount of the term dictionary. If you really want this, consider
  * using an n-gram indexing technique (such as the SpellChecker in the 
  * <a href="{@docRoot}/../suggest/overview-summary.html">suggest module</a>) instead.
+ *
+ * <p>NOTE: terms of length 1 or 2 will sometimes not match because of how the scaled
+ * distance between two terms is computed.  For a term to match, the edit distance between
+ * the terms must be less than the minimum length term (either the input term, or
+ * the candidate term).  For example, FuzzyQuery on term "abcd" with maxEdits=2 will
+ * not match an indexed term "ab", and FuzzyQuery on term "a" with maxEdits=2 will not
+ * match an indexed term "abc".
  */
 public class FuzzyQuery extends MultiTermQuery {
   
---------------
-------------
@@ -104,7 +104,7 @@
     addParser("literal", new ValueSourceParser() {
       @Override
       public ValueSource parse(FunctionQParser fp) throws ParseException {
-        return new LiteralValueSource(fp.getString());
+        return new LiteralValueSource(fp.parseArg());
       }
     });
     addParser("rord", new ValueSourceParser() {
---------------
-------------
@@ -1,5 +1,22 @@
 package org.apache.lucene.facet.search;
 
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Set;
---------------
-------------
@@ -450,6 +450,8 @@
       for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {
         Map.Entry<Token, String> entry = bestIter.next();
         Token tok = entry.getKey();
+        // we are replacing the query in order, but injected terms might cause illegal offsets due to previous replacements.
+        if (tok.getPositionIncrement() == 0) continue;
         collation.replace(tok.startOffset() + offset, 
           tok.endOffset() + offset, entry.getValue());
         offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());
---------------
-------------
@@ -228,7 +228,7 @@
    * This only supports bytes.length <= blockSize */
   public void copy(BytesRef bytes, BytesRef out) throws IOException {
     int left = blockSize - upto;
-    if (bytes.length > left) {
+    if (bytes.length > left || currentBlock==null) {
       if (currentBlock != null) {
         blocks.add(currentBlock);
         blockEnd.add(upto);
---------------
-------------
@@ -276,7 +276,7 @@
       if (o1.value > o2.value) {
         return 1;
       } else if (o1.value < o2.value) {
-        return 0;
+        return -1;
       }
 
       // otherwise on alphabetic order
---------------
-------------
@@ -202,7 +202,7 @@
       //then be sure all of the new words have the same optional/required/prohibited status in the query.
       while(indexOfSpace>-1 && indexOfSpace<corr.length()-1) {
         addParenthesis = true;
-        char previousChar = tok.startOffset()>0 ? collation.charAt(tok.startOffset()-1) : ' ';
+        char previousChar = tok.startOffset()>0 ? origQuery.charAt(tok.startOffset()-1) : ' ';
         if(previousChar=='-' || previousChar=='+') {
           corrSb.insert(indexOfSpace + bump, previousChar);
           if(requiredOrProhibited==null) {
---------------
-------------
@@ -227,7 +227,7 @@
       int endTerm = numTermsInField;  // one past the end
 
       TermsEnum te = getOrdTermsEnum(searcher.getAtomicReader());
-      if (prefix != null && prefix.length() > 0) {
+      if (te != null && prefix != null && prefix.length() > 0) {
         final BytesRef prefixBr = new BytesRef(prefix);
         if (te.seekCeil(prefixBr, true) == TermsEnum.SeekStatus.END) {
           startTerm = numTermsInField;
---------------
-------------
@@ -613,7 +613,6 @@
       resourceLoader.inform( resourceLoader );
       resourceLoader.inform( this );  // last call before the latch is released.
     } catch (Throwable e) {
-      log.error("Error in constructing the core", e);
       latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine
       //close down the searcher and any other resources, if it exists, as this is not recoverable
       close();
---------------
-------------
@@ -101,6 +101,7 @@
     if (len>0) {
       return pushed.charAt(len-1);
     }
+    numRead++;
     int ch = input.read();
     push(ch);
     return ch;
---------------
-------------
@@ -16,6 +16,7 @@
   // without breaking configs.
 
   private static final String SOURCE_HOME = determineSourceHome();
+  public static String WEBAPP_HOME = new File(SOURCE_HOME, "src/webapp/web").getAbsolutePath();
   public static String EXAMPLE_HOME = new File(SOURCE_HOME, "example/solr").getAbsolutePath();
   public static String EXAMPLE_MULTICORE_HOME = new File(SOURCE_HOME, "example/multicore").getAbsolutePath();
   public static String EXAMPLE_SCHEMA=EXAMPLE_HOME+"/conf/schema.xml";
---------------
-------------
@@ -76,7 +76,7 @@
   }
 
   void cleanup() {
-    assertU(delQ("id:[100 TO 110]"));
+    assertU(delQ("*:*"));
     assertU(commit());
   }
 
---------------
-------------
@@ -257,8 +257,6 @@
    * Returns true iff {@link Similarity#coord(int,int)} is disabled in scoring
    * for the high and low frequency query instance. The top level query will
    * always disable coords.
-   * 
-   * @see #CommonTermsQuery(Occur, Occur, float, boolean)
    */
   public boolean isCoordDisabled() {
     return disableCoord;
---------------
-------------
@@ -20,6 +20,7 @@
 /**
  * Exception thrown when an error happening while mapping UIMA CAS model to Solr fields
  */
+@SuppressWarnings("serial")
 public class FieldMappingException extends Exception {
   public FieldMappingException(Exception e) {
     super(e);
---------------
-------------
@@ -707,7 +707,7 @@
                 String key = tc.getKey().toString();
                 int i = key.indexOf('\n');
                 if (i == -1) i = key.indexOf('\r');
-                if (i > -1) {
+                if (i > 0) {
                     key = key.substring(0, i - 1) + "...";
                 }
                 if (key.length() > 80) key = key.substring(0, 80) + "...";
---------------
-------------
@@ -55,7 +55,7 @@
                         protected void output() {
                             s = compact(s);
                             s = s.replaceAll("(\\r?\\n)+", "\\\\n").replaceAll("\"", "\\\\\"");
-                            p("p(org.rythmengine.utils.S.escape(\"").p(s).p("\"));");
+                            p("p(org.rythmengine.utils.S.raw(\"").p(s).p("\"));");
                             pline();
                         }
                     };
---------------
-------------
@@ -913,7 +913,7 @@
         }
  
         List<RenderArgDeclaration> renderArgList = new ArrayList<RenderArgDeclaration>(renderArgs.values());
-        Collections.sort(renderArgList);
+        // comment to fix gh244: Collections.sort(renderArgList);
         
         // -- output __renderArgName method
         pn();
---------------
-------------
@@ -1818,7 +1818,7 @@
          * on Java 8 compiler. So use {@link #ofRange(Range)} instead
          */
         @Deprecated
-        public static <T extends Comparable> __Itr<T> valueOf(Range range) {
+        public static <T extends Comparable<T>> __Itr<T> valueOf(Range<T> range) {
             return ofRange(range);
         }
 
---------------
-------------
@@ -707,7 +707,7 @@
                 String key = tc.getKey().toString();
                 int i = key.indexOf('\n');
                 if (i == -1) i = key.indexOf('\r');
-                if (i > -1) {
+                if (i > 0) {
                     key = key.substring(0, i - 1) + "...";
                 }
                 if (key.length() > 80) key = key.substring(0, 80) + "...";
---------------
-------------
@@ -466,6 +466,7 @@
         tmpl.__renderArgs = new HashMap<String, Object>(__renderArgs.size());
         //tmpl.layoutContent = "";
         tmpl.layoutSections = new HashMap<String, String>();
+        tmpl.layoutSections0 = new HashMap<String, String>();
         tmpl.renderProperties = new HashMap<String, Object>();
         //tmpl.section = null;
         //tmpl.tmpCaller = null;
---------------
-------------
@@ -81,7 +81,7 @@
                     s1 = ExpressionParser.processPositionPlaceHolder(s1);
                     s1 = "\n} else if (org.rythmengine.utils.Eval.eval(" + s1 + ")) {";
                 } else {
-                    Pattern p = Pattern.compile(".*\\{\\s?", Pattern.DOTALL);
+                    Pattern p = Pattern.compile(".*\\{\\s?\\n?", Pattern.DOTALL);
                     if (!p.matcher(s1).matches()) s1 = s1 + "{";
                     if (!s1.startsWith("}")) s1 = "}" + s1;
                 }
---------------
-------------
@@ -22,7 +22,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
-import org.neo4j.helpers.Function;
+import org.neo4j.function.Function;
 import org.neo4j.kernel.configuration.Config;
 import org.neo4j.kernel.lifecycle.LifeSupport;
 import org.neo4j.kernel.lifecycle.Lifecycle;
---------------
-------------
@@ -150,7 +150,7 @@
                                     PaxosInstance.State.delivered ) )
                             {
                                 // Retry
-                                message = context.unbookInstance( instance.id );
+//                                message = context.unbookInstance( instance.id );
                                 outgoing.offer( Message.internal( ProposerMessage.propose, message.getPayload() ) );
                             }
                             break;
---------------
-------------
@@ -595,7 +595,7 @@
         fw.append( "\n" );
     }
     
-    private String createGraphViz( GraphDatabaseService graphDatabaseService )
+    public String createGraphViz( GraphDatabaseService graphDatabaseService )
     {
         OutputStream out = new ByteArrayOutputStream();
         GraphvizWriter writer = new GraphvizWriter(new AsciiDocStyle());
---------------
-------------
@@ -114,7 +114,7 @@
         }
     }
 
-    public String filterVersionForUDC( String version )
+    public static String filterVersionForUDC( String version )
     {
         if ( !version.contains( "+" ) )
         {
---------------
-------------
@@ -23,7 +23,6 @@
 import java.net.URISyntaxException;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
---------------
-------------
@@ -394,7 +394,6 @@
     {
         String sql = "CREATE TABLE " + identifierQuoteString + name
                      + identifierQuoteString + "(" + definition + ")";
-        System.out.println( sql );
         Statement statement = sqldb.createStatement();
         statement.execute( sql );
     }
---------------
-------------
@@ -51,7 +51,7 @@
         }
         catch ( NotFoundException e )
         {
-            serializer.putString( "reference_node","null" );
+//            serializer.putString( "reference_node","null" );
         }
         serializer.putUri( "node_index", "index/node" );
         serializer.putUri( "relationship_index", "index/relationship" );
---------------
-------------
@@ -595,7 +595,7 @@
         fw.append( "\n" );
     }
     
-    private String createGraphViz( GraphDatabaseService graphDatabaseService )
+    public String createGraphViz( GraphDatabaseService graphDatabaseService )
     {
         OutputStream out = new ByteArrayOutputStream();
         GraphvizWriter writer = new GraphvizWriter(new AsciiDocStyle());
---------------
-------------
@@ -98,7 +98,7 @@
 
             return countsStore;
         }
-        catch ( RuntimeException e )
+        catch ( Exception e )
         {
             pageCache.unmap( storeFile );
             throw e;
---------------
-------------
@@ -1,3 +1,22 @@
+/**
+ * Copyright (c) 2002-2014 "Neo Technology,"
+ * Network Engine for Objects in Lund AB [http://neotechnology.com]
+ *
+ * This file is part of Neo4j.
+ *
+ * Neo4j is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
 package org.neo4j.server;
 
 import java.net.URI;
---------------
-------------
@@ -1,3 +1,23 @@
+/**
+ * Copyright (c) 2002-2010 "Neo Technology,"
+ * Network Engine for Objects in Lund AB [http://neotechnology.com]
+ *
+ * This file is part of Neo4j.
+ *
+ * Neo4j is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as
+ * published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package org.neo4j.server.configuration.validation;
 
 import java.net.URI;
---------------
-------------
@@ -29,7 +29,6 @@
 
 import org.junit.Before;
 import org.junit.BeforeClass;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.neo4j.kernel.impl.annotations.Documented;
 import org.neo4j.server.helpers.FunctionalTestHelper;
---------------
-------------
@@ -60,7 +60,7 @@
         data.get();
         gen.get().setGraph( graphdb );
         assertNotNull(data.get().get( "I" ));
-        gen.get().document();
+        gen.get().document("target/testdocs", "testsection");
     }
 
     @Override
---------------
-------------
@@ -96,6 +96,7 @@
         setCharacterEncoding( encoding );
         setRequestURI( null );
         setQueryString( null );
+        setScheme(uri.getScheme());
     }
 
     @Override
---------------
-------------
@@ -93,7 +93,7 @@
                 } else if (result instanceof Long || result instanceof Integer) {
                     return ValueRepresentation.number(((Number) result).longValue());
                 } else {
-                    return ValueRepresentation.string(result.toString());
+                    return ValueRepresentation.string(result+"");
                 }
             }
         } catch (final ScriptException e) {
---------------
-------------
@@ -96,6 +96,7 @@
         setCharacterEncoding( encoding );
         setRequestURI( null );
         setQueryString( null );
+        setScheme(uri.getScheme());
     }
 
     @Override
---------------
-------------
@@ -24,7 +24,7 @@
 
 /**
  * This class is deprecated. You should not parse queries manually -
- * end the string directly to the execution engine
+ * send the string directly to the execution engine
  */
 @Deprecated
 public class CypherParser
---------------
-------------
@@ -51,7 +51,7 @@
     public @Rule
     TestData<JavaTestDocsGenerator> gen = TestData.producedThrough( JavaTestDocsGenerator.PRODUCER );
 
-    String directory = "target"+System.getProperty("path.separator")+"testdocs";
+    String directory = "target"+File.separator+"testdocs";
     String sectionName = "testsection";
     
     @Documented(value="Title1.\n\nhej\n@@snippet1\n\nmore docs\n@@snippet2.")
---------------
-------------
@@ -51,7 +51,7 @@
         }
         catch ( NotFoundException e )
         {
-            serializer.putString( "reference_node","null" );
+//            serializer.putString( "reference_node","null" );
         }
         serializer.putUri( "node_index", "index/node" );
         serializer.putUri( "relationship_index", "index/relationship" );
---------------
-------------
@@ -1,3 +1,23 @@
+/**
+ * Copyright (c) 2002-2010 "Neo Technology,"
+ * Network Engine for Objects in Lund AB [http://neotechnology.com]
+ *
+ * This file is part of Neo4j.
+ *
+ * Neo4j is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as
+ * published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package org.neo4j.server.configuration.validation;
 
 import java.net.URI;
---------------
-------------
@@ -71,6 +71,6 @@
     /**
      * Unique registration id
      */
-    public static final Setting<String> udc_registration_key = setting( "neo4j.ext.udc.source", STRING, "unreg",
+    public static final Setting<String> udc_registration_key = setting( "neo4j.ext.udc.reg", STRING, "unreg",
             illegalValueMessage( "Must be a valid registration id", matches( ANY ) ) );
 }
\ No newline at end of file
---------------
-------------
@@ -1,3 +1,23 @@
+/**
+ * Copyright (c) 2002-2010 "Neo Technology,"
+ * Network Engine for Objects in Lund AB [http://neotechnology.com]
+ *
+ * This file is part of Neo4j.
+ *
+ * Neo4j is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as
+ * published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package org.neo4j.server.configuration.validation;
 
 import java.net.URI;
---------------
-------------
@@ -71,6 +71,6 @@
     /**
      * Unique registration id
      */
-    public static final Setting<String> udc_registration_key = setting( "neo4j.ext.udc.source", STRING, "unreg",
+    public static final Setting<String> udc_registration_key = setting( "neo4j.ext.udc.reg", STRING, "unreg",
             illegalValueMessage( "Must be a valid registration id", matches( ANY ) ) );
 }
\ No newline at end of file
---------------
-------------
@@ -51,7 +51,7 @@
     {
         super(
                 logging,
-                Arrays.<Class<?>>asList( GraphDatabaseSettings.class ),
+                Arrays.<Class<?>>asList( settingsClasses ),
                 Service.load( IndexProvider.class ),
                 Iterables.<KernelExtensionFactory<?>,KernelExtensionFactory>cast( Service.load( KernelExtensionFactory.class ) ),
                 Service.load( CacheProvider.class ),
---------------
-------------
@@ -38,6 +38,7 @@
         // Guard against getting run in too rapid succession.
         if ( ( new Date().getTime() - lastRun ) >= MIN_STEP_TIME )
         {
+        	lastRun = new Date().getTime();
             sampler.updateSample();
         }
     }
---------------
-------------
@@ -111,7 +111,7 @@
     {
         MonitorListenerInvocationHandler monitorListenerInvocationHandler = tags.length == 0 ? new
                 UntaggedMonitorListenerInvocationHandler( monitorListener ) :
-                new TaggedMonitorListenerInvocationHandler( monitorListener );
+                new TaggedMonitorListenerInvocationHandler( monitorListener, tags );
         for ( Class<?> monitorInterface : getInterfacesOf( monitorListener.getClass() ) )
         {
             for ( final Method method : monitorInterface.getMethods() )
---------------
-------------
@@ -1,3 +1,23 @@
+/**
+ * Copyright (c) 2002-2010 "Neo Technology,"
+ * Network Engine for Objects in Lund AB [http://neotechnology.com]
+ *
+ * This file is part of Neo4j.
+ *
+ * Neo4j is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as
+ * published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package org.neo4j.server.configuration.validation;
 
 import java.net.URI;
---------------
-------------
@@ -139,7 +139,7 @@
         if (root == null) {
             throw new Exception("Invalid instance document : no root element");
         }
-        return new QName(root.getNamespaceURI(), root.getNodeName());
+        return new QName(root.getNamespaceURI(), root.getLocalName());
     }
     
     /**
---------------
-------------
@@ -34,7 +34,7 @@
     }
 
     public boolean intersectsWith(TimeRange other) {
-        return includes(other.getStartDate()) || includes(other.getStopDate());
+        return includes(other.getStartDate()) || includes(other.getStopDate()) || other.includes(startDate) || other.includes(stopDate);
     }
 
     public TimeRange getCenterMonth() {
---------------
-------------
@@ -39,7 +39,7 @@
 	}
 
 	public static Test suite() {
-		if (System.getProperty("standalone") != null) {
+		if (System.getProperty("standalone") != null) { //$NON-NLS-1$
 			// running tests stand-alone:  must set up the environment registry
 			Environment.Registry.INSTANCE.registerEnvironment(
 					EcoreEnvironmentFactory.INSTANCE.createEnvironment());
---------------
-------------
@@ -7,7 +7,7 @@
 
 public class AvoidUsingOctalValues extends AbstractRule {
 
-    public static final Pattern OCTAL_PATTERN = Pattern.compile("0[0-7]+");
+    public static final Pattern OCTAL_PATTERN = Pattern.compile("0[0-7]+[lL]?");
 
     public Object visit(ASTLiteral node, Object data) {
         String img = node.getImage();
---------------
-------------
@@ -90,7 +90,7 @@
                         continue;
                     }
                     ASTExpression e = (ASTExpression) se.jjtGetChild(2);
-                    if (e.jjtGetChild(0) instanceof ASTEqualityExpression) {
+                    if (e.findChildrenOfType(ASTEqualityExpression.class).size() > 0) {
                         continue;
                     }
                     String val = getFirstNameImage(e);
---------------
-------------
@@ -45,7 +45,7 @@
 		    RuleViolation rv = violations.next();
 		    buf.append(rv.getFilename());
 		    buf.append(':').append(Integer.toString(rv.getBeginLine()));
-		    buf.append('\t').append(rv.getDescription()).append(PMD.EOL);
+		    buf.append(":\t").append(rv.getDescription()).append(PMD.EOL);
 		    writer.write(buf.toString());
 		}
     }
---------------
-------------
@@ -52,7 +52,7 @@
         }
 
         //if (immediateLiterals > 1) { // see patch http://sourceforge.net/tracker/index.php?func=detail&aid=1455282&group_id=56262&atid=479923
-        if (immediateLiterals == 2) {
+        if (immediateLiterals > 1) {
             return data;
         }
 
---------------
-------------
@@ -25,7 +25,7 @@
             List usages = (List) params.get(decl);
             for (Iterator j = usages.iterator(); j.hasNext();) {
                 NameOccurrence occ = (NameOccurrence) j.next();
-                if (occ.isOnLeftHandSide() && occ.getNameForWhichThisIsAQualifier() == null && !decl.isArray()) {
+                if ((occ.isOnLeftHandSide() || occ.isSelfAssignment()) && occ.getNameForWhichThisIsAQualifier() == null && !decl.isArray()) {
                     ((RuleContext) data).getReport().addRuleViolation(createRuleViolation((RuleContext) data, decl.getNode(), MessageFormat.format(getMessage(), new Object[]{decl.getImage()})));
                 }
             }
---------------
-------------
@@ -68,7 +68,7 @@
         return properties;
     }
 
-    public boolean isInclude()
+    public boolean include()
     {
         return true;
     }
---------------
-------------
@@ -279,6 +279,8 @@
             http.setHost_header(hm.getHostHeader());
             if (hm.getType().equals(HealthMonitorType.HTTPS)) {
                 basic.setUse_ssl(true);
+            } else {
+                basic.setUse_ssl(false);
             }
             properties.setHttp(http);
         }
---------------
-------------
@@ -22,6 +22,7 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.openstack.atlas.adapter.helpers.ZxtmNameBuilder;
+import sun.nio.cs.ext.ISO_8859_11;
 
 import java.rmi.RemoteException;
 import java.util.*;
---------------
-------------
@@ -53,7 +53,7 @@
         }
 
         @Before
-        public void standUp() {
+        public void initializeVars() {
             noTypeorIP = new NetworkItem();
             noTypeOrIpInaccesslist = new AccessList();
             noTypeOrIpInaccesslist.getNetworkItems().add(noTypeorIP);
---------------
-------------
@@ -227,7 +227,7 @@
       int endTerm = numTermsInField;  // one past the end
 
       TermsEnum te = getOrdTermsEnum(searcher.getAtomicReader());
-      if (prefix != null && prefix.length() > 0) {
+      if (te != null && prefix != null && prefix.length() > 0) {
         final BytesRef prefixBr = new BytesRef(prefix);
         if (te.seekCeil(prefixBr, true) == TermsEnum.SeekStatus.END) {
           startTerm = numTermsInField;
---------------
-------------
@@ -228,7 +228,7 @@
    * This only supports bytes.length <= blockSize */
   public void copy(BytesRef bytes, BytesRef out) throws IOException {
     int left = blockSize - upto;
-    if (bytes.length > left) {
+    if (bytes.length > left || currentBlock==null) {
       if (currentBlock != null) {
         blocks.add(currentBlock);
         blockEnd.add(upto);
---------------
-------------
@@ -101,6 +101,7 @@
     if (len>0) {
       return pushed.charAt(len-1);
     }
+    numRead++;
     int ch = input.read();
     push(ch);
     return ch;
---------------
-------------
@@ -104,7 +104,7 @@
     addParser("literal", new ValueSourceParser() {
       @Override
       public ValueSource parse(FunctionQParser fp) throws ParseException {
-        return new LiteralValueSource(fp.getString());
+        return new LiteralValueSource(fp.parseArg());
       }
     });
     addParser("rord", new ValueSourceParser() {
---------------
-------------
@@ -613,7 +613,6 @@
       resourceLoader.inform( resourceLoader );
       resourceLoader.inform( this );  // last call before the latch is released.
     } catch (Throwable e) {
-      log.error("Error in constructing the core", e);
       latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine
       //close down the searcher and any other resources, if it exists, as this is not recoverable
       close();
---------------
-------------
@@ -450,6 +450,8 @@
       for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {
         Map.Entry<Token, String> entry = bestIter.next();
         Token tok = entry.getKey();
+        // we are replacing the query in order, but injected terms might cause illegal offsets due to previous replacements.
+        if (tok.getPositionIncrement() == 0) continue;
         collation.replace(tok.startOffset() + offset, 
           tok.endOffset() + offset, entry.getValue());
         offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());
---------------
-------------
@@ -76,7 +76,7 @@
   }
 
   void cleanup() {
-    assertU(delQ("id:[100 TO 110]"));
+    assertU(delQ("*:*"));
     assertU(commit());
   }
 
---------------
-------------
@@ -16,6 +16,7 @@
   // without breaking configs.
 
   private static final String SOURCE_HOME = determineSourceHome();
+  public static String WEBAPP_HOME = new File(SOURCE_HOME, "src/webapp/web").getAbsolutePath();
   public static String EXAMPLE_HOME = new File(SOURCE_HOME, "example/solr").getAbsolutePath();
   public static String EXAMPLE_MULTICORE_HOME = new File(SOURCE_HOME, "example/multicore").getAbsolutePath();
   public static String EXAMPLE_SCHEMA=EXAMPLE_HOME+"/conf/schema.xml";
---------------
-------------
@@ -296,7 +296,7 @@
      * @throws ContradictionException
      */
     private boolean updateAbsX() throws ContradictionException {
-        return absX.updateLowerBound(absZ.getLB() * absY.getLB(), aCause) & absX.updateUpperBound((absZ.getUB() * absY.getUB()) + absY.getUB() - 1, aCause);
+        return absX.updateLowerBound(absZ.getLB() * absY.getLB(), aCause) | absX.updateUpperBound((absZ.getUB() * absY.getUB()) + absY.getUB() - 1, aCause);
     }
 
     /**
---------------
-------------
@@ -296,7 +296,7 @@
      * @throws ContradictionException
      */
     private boolean updateAbsX() throws ContradictionException {
-        return absX.updateLowerBound(absZ.getLB() * absY.getLB(), aCause) & absX.updateUpperBound((absZ.getUB() * absY.getUB()) + absY.getUB() - 1, aCause);
+        return absX.updateLowerBound(absZ.getLB() * absY.getLB(), aCause) | absX.updateUpperBound((absZ.getUB() * absY.getUB()) + absY.getUB() - 1, aCause);
     }
 
     /**
---------------
-------------
@@ -126,7 +126,7 @@
         Solver solver = BOOLVAR.getSolver();
         PropSat sat = solver.getMinisat().getPropSat();
         int lit = sat.Literal(BOOLVAR);
-        sat.addClause(SatSolver.negated(lit));
+        sat.addClause(lit);
         return true;
     }
 
---------------
-------------
@@ -296,7 +296,7 @@
      * @throws ContradictionException
      */
     private boolean updateAbsX() throws ContradictionException {
-        return absX.updateLowerBound(absZ.getLB() * absY.getLB(), aCause) & absX.updateUpperBound((absZ.getUB() * absY.getUB()) + absY.getUB() - 1, aCause);
+        return absX.updateLowerBound(absZ.getLB() * absY.getLB(), aCause) | absX.updateUpperBound((absZ.getUB() * absY.getUB()) + absY.getUB() - 1, aCause);
     }
 
     /**
---------------
-------------
@@ -67,6 +67,7 @@
 			}catch (ContradictionException e){
 				throw new UnsupportedOperationException("restoring the last solution ended in a failure");
 			}
+            solver.getEngine().flush();
 		}
 	}
 
---------------
-------------
@@ -408,7 +408,7 @@
             return -1;
         }
 
-        if (fromIndex >= 64)
+        if (fromIndex >= 32)
             return length() - 1;
 
         int word = this.word.get() & (WORD_MASK >>> -(fromIndex + 1));
---------------
-------------
@@ -47,8 +47,8 @@
         Connection connectionToPostgres = null;
         Connection connectionToSeqware = null;
         try {
-            connectionToPostgres = createConnection(POSTGRE_DB, POSTGRE_USER, POSTGRE_PASSWORD);
-            loadDatabase(connectionToPostgres);
+            // connectionToPostgres = createConnection(POSTGRE_DB, POSTGRE_USER, POSTGRE_PASSWORD);
+            // loadDatabase(connectionToPostgres);
             connectionToSeqware = createConnection(SEQWARE_DB, POSTGRE_USER, POSTGRE_PASSWORD);
             loadDBStructure(connectionToSeqware);
         } catch (Exception e) {
---------------
-------------
@@ -57,7 +57,7 @@
             if (t instanceof ParameterizedType)
             {
                 final Class<?> genericType = (Class<?>) ((ParameterizedType) t).getActualTypeArguments()[0];
-                if (!genericType.equals(String.class) && !genericType.equals(Integer.class))
+                if (!genericType.equals(String.class) && !genericType.equals(Integer.class) && !genericType.equals(Long.class))
                 {
                     throw new IllegalArgumentException(method.getReturnType().toString());
                 }
---------------
-------------
@@ -21,6 +21,9 @@
  * Execution listener that forces a context reload before the test method is executed on methods/classes annotated with
  * {@link ReloadContext}.
  * 
+ * WARNING: if used in conjunction with {@link DependencyInjectionTestExecutionListener}, the
+ * {@link ReloadContextTestExecutionListener} should come first!
+ * 
  * @author Jan De Moerloose
  * 
  */
---------------
-------------
@@ -69,7 +69,7 @@
 			}
 		}
 		if (list.size() > compare.length) {
-			return "more recorded messages then tested" + list;
+			return "more recorded messages then tested, " + list;
 		}
 		return "";
 	}
---------------
-------------
@@ -136,7 +136,7 @@
 					String geomName = vectorLayer.getLayerInfo().getFeatureInfo().getGeometryType().getName();
 
 					// Transform geometry to layer CRS:
-					Geometry layerGeometry = geoService.transform(geometry, crs, vectorLayer.getCrs());
+					Geometry layerGeometry = geoService.transform(geometry, crs, layerService.getCrs(vectorLayer));
 					log.trace("on layer " + serverLayerId + " use " + layerGeometry);
 
 					// Create the correct Filter object:
---------------
-------------
@@ -36,7 +36,7 @@
 import com.google.gwt.core.client.Callback;
 
 /**
- * Default implementation of the {@link FeaturesSupportedWmsLayer}.
+ * Server-based implementation of {@link FeatureSearchSupported} WMS layer.
  *
  * @author Jan De Moerloose
  */
---------------
-------------
@@ -747,7 +747,7 @@
 					}
 					if (yCenter < minCoordinate.getY()) {
 						yCenter = minCoordinate.getY();
-					} else if (yCenter > maxCoordinate.getX()) {
+					} else if (yCenter > maxCoordinate.getY()) {
 						yCenter = maxCoordinate.getY();
 					}
 				}
---------------
-------------
@@ -238,7 +238,7 @@
 			double west = Double.parseDouble(area.getChildText("west"));
 			if (Math.abs(north - south) > DELTA || Math.abs(east - west) > DELTA) {
 				// return point when bbox is a point
-				Bbox bbox = new Bbox(south, west, north - south, east - west);
+				Bbox bbox = new Bbox(west, south, east - west, north - south);
 				location.setEnvelope(dtoConverterService.toInternal(bbox));
 			}
 		}
---------------
-------------
@@ -21,7 +21,6 @@
  * the entire context (which contains the authorizations) will need to change because of the refresh, this should not
  * be a problem.
  *
- *
  * @author Joachim Van der Auwera
  */
 public interface AuthorizationNeedsWiring {
---------------
-------------
@@ -27,7 +27,7 @@
 
 	private static final long serialVersionUID = 100L;
 
-	private transient final Logger log = LoggerFactory.getLogger(CacheContextImpl.class);
+	private final transient Logger log = LoggerFactory.getLogger(CacheContextImpl.class);
 
 	private Map<String, Object> map = new HashMap<String, Object>();
 
---------------
-------------
@@ -53,7 +53,7 @@
          Multimap<String, String> headers, Map<String, String> metadata, Payload payload) {
       this.name = checkNotNull(name, "name");
       this.uri = checkNotNull(uri, "uri of %s", uri);
-      this.etag = checkNotNull(etag, "etag of %s", name).replace("\"", "");
+      this.etag = etag != null ? etag.replace("\"", "") : null;
       this.lastModified = checkNotNull(lastModified, "lastModified of %s", name);
       this.headers = headers == null ? ImmutableMultimap.<String, String> of() : checkNotNull(headers, "headers of %s", name);
       this.metadata = metadata == null ? ImmutableMap.<String, String> of() : metadata;
---------------
-------------
@@ -34,7 +34,7 @@
 
    @Override
    public <R extends HttpRequest> R bindToRequest(R request, Object payload ) {
-      super.bindToRequest(request, String.format("{\"is_completed\":\"%s\"}", payload));
+      super.bindToRequest(request, String.format("{\"is_completed\":%s}", payload));
       request.getPayload().getContentMetadata().setContentType(MediaType.APPLICATION_JSON);
       return request;
    }
---------------
-------------
@@ -408,7 +408,7 @@
       }
 
       public boolean apply(StorageMetadata metadata) {
-         if (prefix == null)
+         if (prefix == null || prefix.isEmpty())
             return metadata.getName().indexOf(delimiter) == -1;
          // ensure we don't accidentally append twice
          String toMatch = prefix.endsWith("/") ? prefix : prefix + delimiter;
---------------
-------------
@@ -435,6 +435,8 @@
       Multimap<String, String> queryParams = addQueryParams(tokenValues.entries(), method, args);
       Multimap<String, String> matrixParams = addMatrixParams(tokenValues.entries(), method, args);
       Multimap<String, String> headers = buildHeaders(tokenValues.entries(), method, args);
+      if (r != null)
+         headers.putAll(r.getHeaders());
 
       if (shouldAddHostHeader(method))
          headers.put(HOST, endpoint.getHost());
---------------
-------------
@@ -79,6 +79,7 @@
       NodeMetadataBuilder builder = new NodeMetadataBuilder();
       builder.ids(from.getId());
       builder.name(from.getName());
+      builder.loginPort(from.getLoginPort());
       builder.hostname(from.getHostname());
       builder.location(findLocationWithId(from.getLocationId()));
       builder.group(from.getGroup());
---------------
-------------
@@ -73,7 +73,7 @@
       FileType fileType = UriParser.normalisePath(name);
       String path = name.toString();
 
-      return new BlobStoreFileName(auth.getHostName(), creds.account, creds.key, path, fileType,
+      return new BlobStoreFileName(auth.hostName, creds.account, creds.key, path, fileType,
                container);
    }
 
---------------
-------------
@@ -67,7 +67,7 @@
          .apiMetadata(new SoftLayerApiMetadata())
          .homepage(URI.create("http://www.softlayer.com"))
          .console(URI.create("https://manage.softlayer.com"))
-         .iso3166Codes("SG", "US-CA", "US-TX", "US-VA", "US-WA", "NL", "HK", "NSFTW-IL", "AU", "CA-ON", "GB")  // NSFTW-IL is a weird isoCode returned by Softlayer
+         .iso3166Codes("SG", "US-CA", "US-TX", "US-VA", "US-WA", "NL", "HK", "NSFTW-IL", "AU", "CA-ON", "GB", "FR", "IT", "DE", "JP", "MX", "CA-ON", "CA-QC")
          .endpoint("https://api.softlayer.com/rest")
          .defaultProperties(SoftLayerProviderMetadata.defaultProperties());
       }
---------------
-------------
@@ -261,7 +261,7 @@
             for (String o : commonPrefixes) {
                MutableStorageMetadata md = new MutableStorageMetadataImpl();
                md.setType(StorageType.RELATIVE_PATH);
-               if (prefix != null) {
+               if (prefix != null && !prefix.isEmpty()) {
                   if (!prefix.endsWith(delimiter)) {
                      o = prefix + delimiter + o;
                   } else {
---------------
-------------
@@ -104,7 +104,7 @@
    @DELETE
    @Path("/os-security-groups/{id}")
    @ExceptionParser(ReturnNullOnNotFoundOr404.class)
-   @Consumes
+   @Consumes(MediaType.APPLICATION_JSON)
    ListenableFuture<Boolean> deleteSecurityGroup(@PathParam("id") String id);
 
    /**
---------------
-------------
@@ -104,7 +104,7 @@
    @DELETE
    @Path("/os-security-groups/{id}")
    @ExceptionParser(ReturnNullOnNotFoundOr404.class)
-   @Consumes
+   @Consumes(MediaType.APPLICATION_JSON)
    ListenableFuture<Boolean> deleteSecurityGroup(@PathParam("id") String id);
 
    /**
---------------
-------------
@@ -1,5 +1,5 @@
 /*
- * Licensed to jclouds, Inc. (jclouds) under one or more
+U * Licensed to jclouds, Inc. (jclouds) under one or more
  * contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  jclouds licenses this file
---------------
-------------
@@ -320,7 +320,7 @@
       public boolean apply(Image input) {
          boolean returnVal = true;
          if (imageDescription != null) {
-            if (input.getName() == null)
+            if (input.getDescription() == null)
                returnVal = false;
             else
                returnVal = input.getDescription().equals(imageDescription)
---------------
-------------
@@ -80,7 +80,7 @@
    @GET
    @Path("objects/{id}")
    @ExceptionParser(FooOnException.class)
-   String synchException(@PathParam("id") String id, @HeaderParam("Content-Range") String header);
+   String synchException(@PathParam("id") String id, @HeaderParam("Range") String header);
 
    @PUT
    @Path("objects/{id}")
---------------
-------------
@@ -48,7 +48,7 @@
 @Path("/v{jclouds.api-version}")
 public interface VirtualGuestAsyncClient {
    public static String LIST_GUEST_MASK = "virtualGuests.powerState;virtualGuests.networkVlans;virtualGuests.operatingSystem.passwords;virtualGuests.datacenter;virtualGuests.billingItem";
-   public static String GUEST_MASK = "powerState;networkVlans;operatingSystem.passwords;datacenter;virtualGuests.billingItem";
+   public static String GUEST_MASK = "powerState;networkVlans;operatingSystem.passwords;datacenter;billingItem";
 
    /**
     * @see VirtualGuestClient#listVirtualGuests
---------------
-------------
@@ -137,7 +137,7 @@
    @SerializedName("virtualmachinename")
    private String virtualMachineName;
    @SerializedName("cidrlist")
-   private Set<String> CIDRs;
+   private Set<String> CIDRs = ImmutableSet.of();
    @SerializedName("privateendport")
    private int privateEndPort;
    @SerializedName("publicendport")
---------------
-------------
@@ -39,7 +39,7 @@
    private final DirectionalRecord record;
 
    private DirectionalRecordDetail(String zoneName, String name, String id,
-         Optional<DirectionalGroup> geolocationGroup, Optional<DirectionalGroup> group,
+         Optional<DirectionalGroup> group, Optional<DirectionalGroup> geolocationGroup,
          Optional<DirectionalGroup> sourceIpGroup, DirectionalRecord record) {
       this.zoneName = checkNotNull(zoneName, "zoneName");
       this.name = checkNotNull(name, "name");
---------------
-------------
@@ -163,7 +163,7 @@
 
    @Override
    public int hashCode() {
-      return Objects.hashCode(containerFormat, diskFormat, size, checksum);
+      return Objects.hashCode(super.hashCode(), containerFormat, diskFormat, size, checksum);
    }
 
    @Override
---------------
-------------
@@ -44,7 +44,7 @@
       xtr.next();
       if (xtr.isStartElement()) {
         if (ELEMENT_EXECUTION_LISTENER.equals(xtr.getLocalName())) {
-          new ExecutionListenerParser().parseChildElement(xtr, activeProcess, model);
+          new ExecutionListenerParser().parseChildElement(xtr, parentElement, model);
         } else {
           ExtensionElement extensionElement = BpmnXMLUtil.parseExtensionElement(xtr);
           parentElement.addExtensionElement(extensionElement);
---------------
-------------
@@ -298,7 +298,7 @@
     List<IdentityLinkEntity> removedIdentityLinkEntities = new ArrayList<IdentityLinkEntity>();
     for (IdentityLinkEntity identityLinkEntity : this.getIdentityLinks()) {
       if (IdentityLinkType.CANDIDATE.equals(identityLinkEntity.getType())) {
-        if ((userId != null && identityLinkEntity.getUserId().equals(userId))
+        if ((userId != null && userId.equals(identityLinkEntity.getUserId()))
           || (groupId != null && identityLinkEntity.getGroupId().equals(groupId))) {
           Context
             .getCommandContext()
---------------
-------------
@@ -115,7 +115,7 @@
     
     // switch all sub-executions of the process instance to the new process definition version
     List<ExecutionEntity> childExecutions = executionManager
-      .findChildExecutionsByParentExecutionId(processInstanceId);
+      .findChildExecutionsByProcessInstanceId(processInstanceId);
     for (ExecutionEntity executionEntity : childExecutions) {
       validateAndSwitchVersionOfExecution(commandContext, executionEntity, newProcessDefinition);
     }
---------------
-------------
@@ -44,7 +44,7 @@
       xtr.next();
       if (xtr.isStartElement()) {
         if (ELEMENT_EXECUTION_LISTENER.equals(xtr.getLocalName())) {
-          new ExecutionListenerParser().parseChildElement(xtr, activeProcess, model);
+          new ExecutionListenerParser().parseChildElement(xtr, parentElement, model);
         } else {
           ExtensionElement extensionElement = BpmnXMLUtil.parseExtensionElement(xtr);
           parentElement.addExtensionElement(extensionElement);
---------------
-------------
@@ -298,7 +298,7 @@
     List<IdentityLinkEntity> removedIdentityLinkEntities = new ArrayList<IdentityLinkEntity>();
     for (IdentityLinkEntity identityLinkEntity : this.getIdentityLinks()) {
       if (IdentityLinkType.CANDIDATE.equals(identityLinkEntity.getType())) {
-        if ((userId != null && identityLinkEntity.getUserId().equals(userId))
+        if ((userId != null && userId.equals(identityLinkEntity.getUserId()))
           || (groupId != null && identityLinkEntity.getGroupId().equals(groupId))) {
           Context
             .getCommandContext()
---------------
-------------
@@ -50,7 +50,7 @@
       if (superExecution != null) {
         executeCatchInSuperProcess(superExecution);
       } else {
-        // TODO Shouldn't this be an exception as in executeCatchInSuperProcess()?
+        // TODO Shouldn't this be an exception as in executeCatchInSuperProcess() or is this dead code?
         LOG.info(execution.getActivity().getId() + " throws error event with errorCode '"
                 + errorCode + "', but no catching boundary event was defined. "
                 +   "Execution will simply be ended (none end event semantics).");
---------------
-------------
@@ -103,6 +103,7 @@
 
             Method activateBeanValidation = activator.getDeclaredMethod( TYPE_SAFE_ACTIVATOR_METHOD_NAME,
                     Set.class, SessionManagerConfig.class );
+            activateBeanValidation.setAccessible( true );
             activateBeanValidation.invoke( null, bapiInterceptors, sessionManagerConfig );
         }
         catch ( ClassNotFoundException e )
---------------
-------------
@@ -91,6 +91,7 @@
                     .templateCode(templateCode)
                     .params(params),
                     new FileOutputStream(cmd.getOptionValue(OUTPUT_PATH)));
+            System.exit(0);
         } catch (Exception e) {
             e.printStackTrace();
             System.exit(-1);
---------------
-------------
@@ -152,7 +152,7 @@
 	 */
 	public int degree(Argument key) {
 		Integer r = this.arg1.get(key.getName());
-		if (r!=null) {
+		if (r==null) {
 			return 0;
 		}
 		else {
---------------
-------------
@@ -40,6 +40,7 @@
 
     public void register(InterceptorManager mgr) {
         mgr.registerInterceptor(UID_SEQ, this, InterceptPoint.PRE_CRUD_INSERT_DOC,
+                                InterceptPoint.PRE_MEDIATOR_SAVE,
                 InterceptPoint.PRE_CRUD_UPDATE_DOC,
                 InterceptPoint.PRE_MEDIATOR_INSERT);
     }
---------------
-------------
@@ -40,6 +40,7 @@
 
     public void register(InterceptorManager mgr) {
         mgr.registerInterceptor(UID_SEQ, this, InterceptPoint.PRE_CRUD_INSERT_DOC,
+                                InterceptPoint.PRE_MEDIATOR_SAVE,
                 InterceptPoint.PRE_CRUD_UPDATE_DOC,
                 InterceptPoint.PRE_MEDIATOR_INSERT);
     }
---------------
-------------
@@ -47,7 +47,7 @@
         if (p.matchingPrefix(field)) {
             if (include) {
                 return Boolean.TRUE;
-            } else if (p.equals(field)) {
+            } else if (p.matches(field)) {
                 return Boolean.FALSE;
             }
         } else if (recursive && p.numSegments() > field.numSegments() && p.prefix(field.numSegments()).matches(field)) {
---------------
-------------
@@ -61,7 +61,7 @@
 
     @Override
     public boolean send(byte[] buf, MessageFlag flag) {
-        return send(buf, 0, flag);
+        return socket.send(buf, flag.getFlag());
     }
 
     @Override
---------------
-------------
@@ -384,7 +384,7 @@
 
         List<String> authorizedUserSLEAs = new LinkedList<String>();
         authorizedUserSLEAs.addAll(appAuthorizedUserLEAs);
-        Entity lea = helper.byId(appAuthorizedUserLEAs.get(0));
+        Entity lea = helper.byId(appAuthorizedUserLEAs.get(0));  // First LEA is as good as any.
         String seaId = helper.getSEAOfEdOrg(lea);
         if (seaId != null) {
             authorizedUserSLEAs.add(seaId);
---------------
-------------
@@ -63,7 +63,7 @@
         int RESOURCE_SEGMENT_INDEX = 1;
         int VERSION_INDEX = 0;
         if (uriInfo.getPathSegments().size() > RESOURCE_SEGMENT_INDEX
-                && uriInfo.getPathSegments().get(VERSION_INDEX).equals(PathConstants.V1)) {
+                && uriInfo.getPathSegments().get(VERSION_INDEX).getPath().equals(PathConstants.V1)) {
 
             String resourceName = uriInfo.getPathSegments().get(RESOURCE_SEGMENT_INDEX).getPath();
             EntityDefinition def = store.lookupByResourceName(resourceName);
---------------
-------------
@@ -54,7 +54,6 @@
  * @author kmyers
  * 
  */
-@Component
 public class SliSchemaVersionValidator {
 
     private static final Logger LOG = LoggerFactory.getLogger(SliSchemaVersionValidator.class);
---------------
-------------
@@ -170,7 +170,8 @@
                         if (strategyMap.containsKey(elementName)) {
                             parentElement = parentStack.elementAt((parentStack.size() - 2));
                             resolutionStrategy = applicationContext.getBean(strategyMap.get(elementName), ReferenceResolutionStrategy.class);
-                            String resolvedReference = resolutionStrategy.resolveReference(elementName, refValue, parentElement, idObject.get(refValue), interchangeName);
+//                            String resolvedReference = resolutionStrategy.resolveReference(elementName, refValue, parentElement, idObject.get(refValue), interchangeName);
+                            String resolvedReference = resolutionStrategy.resolve(interchangeName, parentElement, refValue, idObject.get(refValue));
                             boolean contentReplaced = writeResolvedReference(event, xmlw, resolvedReference);
                             if (contentReplaced) {
                                 referenceReplaced = elementName;
---------------
-------------
@@ -120,7 +120,7 @@
 
         if (section != null) {
             student.put(Constants.ATTR_SECTION_ID, section.get(Constants.ATTR_UNIQUE_SECTION_CODE));
-            GenericEntity teacher = getApiClient().getTeacherForSection(section.getString(Constants.ATTR_ID), token);
+            GenericEntity teacher = getApiClient().getTeacherForSection(token, section.getString(Constants.ATTR_ID));
 
             if (teacher != null) {
                 @SuppressWarnings("unchecked")
---------------
-------------
@@ -21,7 +21,6 @@
 import org.slc.sli.api.representation.EntityBody;
 import org.slc.sli.api.resources.Resource;
 import org.slc.sli.api.security.SLIPrincipal;
-import org.slc.sli.api.service.EntityNotFoundException;
 import org.slc.sli.api.service.EntityService;
 import org.slc.sli.domain.Entity;
 import org.slc.sli.domain.NeutralCriteria;
---------------
-------------
@@ -50,7 +50,7 @@
     public Set<String> validate(String entityType, Set<String> ids) throws IllegalStateException {
         LOG.trace(">>>GenericToEdOrgValidator.validate()");
         LOG.trace("  entityType: " + entityType);
-        LOG.trace("  ids: " + ids.toString());
+        LOG.trace("  ids: " + ids);
 
         if (!areParametersValid(Arrays.asList(EntityNames.SCHOOL, EntityNames.EDUCATION_ORGANIZATION), entityType, ids)) {
             LOG.trace("  ...return empty set - areParametersValid");
---------------
-------------
@@ -54,7 +54,6 @@
  * @author kmyers
  * 
  */
-@Component
 public class SliSchemaVersionValidator {
 
     private static final Logger LOG = LoggerFactory.getLogger(SliSchemaVersionValidator.class);
---------------
-------------
@@ -70,7 +70,7 @@
         int RESOURCE_SEGMENT_INDEX = 1;
         int VERSION_INDEX = 0;
         if (uriInfo.getPathSegments().size() > RESOURCE_SEGMENT_INDEX
-                && uriInfo.getPathSegments().get(VERSION_INDEX).equals(PathConstants.V1)) {
+                && uriInfo.getPathSegments().get(VERSION_INDEX).getPath().equals(PathConstants.V1)) {
 
             String resourceName = uriInfo.getPathSegments().get(RESOURCE_SEGMENT_INDEX).getPath();
             EntityDefinition def = store.lookupByResourceName(resourceName);
---------------
-------------
@@ -4,6 +4,9 @@
 
 import org.slc.sli.domain.Student;
 
+/**
+ * Fake service for testing authentication service.
+ */
 @Service
 public class SecureFakeServiceImpl implements SecureFakeService {
     
---------------
-------------
@@ -63,7 +63,7 @@
         int RESOURCE_SEGMENT_INDEX = 1;
         int VERSION_INDEX = 0;
         if (uriInfo.getPathSegments().size() > RESOURCE_SEGMENT_INDEX
-                && uriInfo.getPathSegments().get(VERSION_INDEX).getPath().equals(PathConstants.V1)) {
+                && uriInfo.getPathSegments().get(VERSION_INDEX).equals(PathConstants.V1)) {
 
             String resourceName = uriInfo.getPathSegments().get(RESOURCE_SEGMENT_INDEX).getPath();
             EntityDefinition def = store.lookupByResourceName(resourceName);
---------------
-------------
@@ -63,7 +63,7 @@
         int RESOURCE_SEGMENT_INDEX = 1;
         int VERSION_INDEX = 0;
         if (uriInfo.getPathSegments().size() > RESOURCE_SEGMENT_INDEX
-                && uriInfo.getPathSegments().get(VERSION_INDEX).equals(PathConstants.V1)) {
+                && uriInfo.getPathSegments().get(VERSION_INDEX).getPath().equals(PathConstants.V1)) {
 
             String resourceName = uriInfo.getPathSegments().get(RESOURCE_SEGMENT_INDEX).getPath();
             EntityDefinition def = store.lookupByResourceName(resourceName);
---------------
-------------
@@ -103,8 +103,9 @@
                 for (int j = 0; j < argTokens.length; j += 2) {
                     arg += argTokens[j];
                 }
-                // Remove curly braces and colons.
-                arg = arg.replaceAll("[{:}]", "");
+                // Remove colons.
+/*                arg = arg.replaceAll("[{:}]", "");*/
+                arg = arg.replaceAll(":", "");
                 messageArgs[i] = arg;
         }
 
---------------
-------------
@@ -54,7 +54,7 @@
         for (String id : ids) {
             EntityBody body = service.get(id);
             Role tempRole = getRoleWithBodyAndID(id, body);
-            if(tempRole.getSpringRoleName().equals(springName))
+            if (tempRole.getSpringRoleName().equals(springName))
                 return tempRole;
         }
         return null;
---------------
-------------
@@ -46,7 +46,7 @@
         repo.put("sectionSchoolAssociation", new LinkedHashMap<String, Entity>());
         repo.put("aggregation", new LinkedHashMap<String, Entity>());
         repo.put("staffschoolassociation", new LinkedHashMap<String, Entity>());
-        repo.put("aggregationdefinition", new LinkedHashMap<String, Entity>());
+        repo.put("aggregationDefinition", new LinkedHashMap<String, Entity>());
         repo.put("educationOrganizationassociation", new LinkedHashMap<String, Entity>());
     }
     
---------------
-------------
@@ -15,8 +15,6 @@
  */
 package org.slc.sli.api.resources.generic.config;
 
-import org.apache.commons.io.IOUtils;
-import org.codehaus.jackson.JsonParseException;
 import org.codehaus.jackson.map.ObjectMapper;
 import org.slc.sli.api.resources.generic.util.ResourceHelper;
 import org.slc.sli.api.resources.generic.util.ResourceTemplate;
---------------
-------------
@@ -102,7 +102,7 @@
     }*/
 
     /**
-     * Attempt to create and new landing zone routes based on the tenant DB collection.
+     * Attempt to create new landing zones based on the tenant DB collection.
      */
     private void createNewLandingZones() {
         try {
---------------
-------------
@@ -112,7 +112,7 @@
                 assertEquals(exp, rec);
 
             } else if (exp instanceof Boolean) {
-                assertTrue("Missing expected String value type for key: " + key, rec instanceof Boolean);
+                assertTrue("Missing expected Boolean value type for key: " + key, rec instanceof Boolean);
                 assertEquals(exp, rec);
 
             } else if (exp instanceof Map) {
---------------
-------------
@@ -525,6 +525,13 @@
             }
         }
     }
+
+    /**
+     * This method will apply the date filter for schoolYears query param.
+     * Assumption: the entities for which the criteria is valid have the end date i.e endDate $exists check is ignored
+     * @param entities
+     * @param apiQuery
+     */
     private void addGranularAccessCriteria(String entities, ApiQuery apiQuery) {
 
         if (granularAccessFilterProvider.hasFilter()) {
---------------
-------------
@@ -60,7 +60,7 @@
     @Column
     private Integer version;
     
-     @ManyToOne(optional=false)
+    @ManyToOne(optional=false)
     private Empresa empresa;
 
     public Empresa getEmpresa() {
---------------
-------------
@@ -105,7 +105,7 @@
 				
 				condition = exprInterpreter.doSwitch(block.getCondition());
 				timeout++;
-				if (!ValueUtil.isBool(condition)||timeout<1000) {
+				if (!ValueUtil.isBool(condition)||timeout>1000) {
 					nullWasNormal=false;
 					throw new OrccRuntimeException(
 							"Condition not boolean at line "
---------------
-------------
@@ -665,7 +665,7 @@
 
         if ((current instanceof MinusExprToken || current instanceof PlusExprToken)
                 && (next instanceof IntegerExprToken || next instanceof DoubleExprToken
-                        || next instanceof HexExprValue)){
+                        || next instanceof HexExprValue || next instanceof BinaryExprValue)){
 
             if (!(previous instanceof ValueExprToken
                     || previous instanceof ArrayGetExprToken || previous instanceof DynamicAccessExprToken
---------------
-------------
@@ -103,7 +103,7 @@
 
     @Immutable
     public static String dirname(String path){
-        return new File(path).getPath();
+        return new File(path).getParent();
     }
 
     public static Memory disk_free_space(String path){
---------------
-------------
@@ -57,7 +57,7 @@
     }
 
     public static boolean isDelimiter(char ch){
-        return "~+-=/*:<>!?%@&^.|([{}]);,\t\n\r ".indexOf(ch) > -1;
+        return "~+-=/*:<>!?%@&^.|([{}]);'\",\t\n\r ".indexOf(ch) > -1;
     }
 
     public static boolean isNewline(char ch){
---------------
-------------
@@ -665,7 +665,7 @@
 
         if ((current instanceof MinusExprToken || current instanceof PlusExprToken)
                 && (next instanceof IntegerExprToken || next instanceof DoubleExprToken
-                        || next instanceof HexExprValue)){
+                        || next instanceof HexExprValue || next instanceof BinaryExprValue)){
 
             if (!(previous instanceof ValueExprToken
                     || previous instanceof ArrayGetExprToken || previous instanceof DynamicAccessExprToken
---------------
-------------
@@ -103,7 +103,7 @@
 
     @Immutable
     public static String dirname(String path){
-        return new File(path).getPath();
+        return new File(path).getParent();
     }
 
     public static Memory disk_free_space(String path){
---------------
-------------
@@ -141,7 +141,7 @@
 	}
 	
 	private static String quoteIfNeeded(String string) {
-		if (string.contains(" ") || Strings.containsAnyOf(string, true, SADLTokeniser.tokenEndingOperators())) {
+		if (string.isEmpty() || string.contains(" ") || Strings.containsAnyOf(string, true, SADLTokeniser.tokenEndingOperators())) {
 			return "\"" + escapeIfNeeded(string) + "\"";
 		} else {
 			return string;
---------------
-------------
@@ -1,3 +1,11 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+
 /** Generally useful classes, not particularly tied to any other package. */
 
 package org.dspace.util;
---------------
-------------
@@ -380,7 +380,7 @@
         InboundAdminClient inboundAdmin = new InboundAdminClient(backEndUrl, sessionCookie);
        InboundEndpointDTO inboundEndpointDTO = inboundAdmin.getInboundEndpointbyName(name);
         Assert.assertNotNull(inboundEndpointDTO);
-        
+
     }
 
     public void deleteInboundEndpointDeployed(String backEndUrl, String sessionCookie,String name)
---------------
-------------
@@ -96,7 +96,7 @@
         to.setPzxid(stat.getPzxid());
         to.setVersion(stat.getVersion());
         to.setEphemeralOwner(stat.getEphemeralOwner());
-        to.setDataLength(data.length);
+        to.setDataLength(data == null ? 0 : data.length);
         to.setNumChildren(children.size());
     }
 
---------------
-------------
@@ -152,7 +152,7 @@
   /** Returns true if a byte buffer of the given size will fit in memory. */
   public static boolean canFitInMemory(long bufferSize) {
     Runtime r = Runtime.getRuntime();
-    long mem = r.freeMemory();
+    long mem = r.freeMemory() / 2;
     return bufferSize < mem;
   }
 
---------------
-------------
@@ -112,7 +112,7 @@
     BufferedReader br = null;
     try {
       fis = new FileInputStream(file);
-      isr = new InputStreamReader(fis);
+      isr = new InputStreamReader(fis, Constants.ENCODING);
       br = new BufferedReader(isr);
       return parseINI(br);
     } finally {
---------------
-------------
@@ -587,7 +587,7 @@
       stripByteCounts[tileNumber] *= pixel;
     }
     int size = (int) (tileWidth * tileLength * pixel * effectiveChannels);
-   
+
     if (buf == null) buf = new byte[size];
     if (stripByteCounts[tileNumber] == 0 ||
       stripOffsets[tileNumber] >= in.length())
---------------
-------------
@@ -385,7 +385,7 @@
             } else if (Collection.class.isInstance(payload)) {
                 answer = JmsMessageType.Map;
             } else if (InputStream.class.isInstance(payload)) {
-                answer = JmsMessageType.Bytes;
+                answer = JmsMessageType.Stream;
             } else if (ByteBuffer.class.isInstance(payload)) {
                 answer = JmsMessageType.Bytes;
             } else if (File.class.isInstance(payload)) {
---------------
-------------
@@ -77,6 +77,7 @@
 
         if (callable != null) {
             Message reply = callable.call();
+            exchange.getOut().getHeaders().putAll(camelMessage.getHeaders());
             exchange.getOut().setBody(reply);
         }
     }
---------------
-------------
@@ -42,7 +42,7 @@
      * @param exchange the exchange
      * @param schema   the schema
      * @param result   the result
-     * @throws ValidationException is thrown in case of validatation errors
+     * @throws ValidationException is thrown in case of validation errors
      */
     void handleErrors(Exchange exchange, Schema schema, Result result) throws ValidationException;
 }
---------------
-------------
@@ -22,5 +22,5 @@
  * Processes splunk results
  */
 public interface SplunkResultProcessor {
-    public void process(SplunkEvent splunkData);
+    void process(SplunkEvent splunkData);
 }
---------------
-------------
@@ -38,7 +38,8 @@
         ClientFactoryBean clientBean = proxyFactory.getClientFactoryBean();
         clientBean.setAddress(address);
         clientBean.setServiceClass(LoanBrokerWS.class);
-        clientBean.setBus(BusFactory.getDefaultBus());
+        // just create a new bus for use
+        clientBean.setBus(BusFactory.newInstance().createBus());
         return (LoanBrokerWS) proxyFactory.create();
     }
 
---------------
-------------
@@ -458,7 +458,7 @@
         if (body != null) {
             TypeConverter tc = exchange.getContext().getTypeConverterRegistry().lookup(Source.class, body.getClass());
             if (tc != null) {
-                source = tc.convertTo(Source.class, body);
+                source = tc.convertTo(Source.class, exchange, body);
             }
         }
 
---------------
-------------
@@ -51,7 +51,7 @@
             catch (InterruptedException e) {
                 break;
             }
-            if (exchange != null) {
+            if (exchange != null && !isStopping()) {
                 try {
                     processor.process(exchange);
                 }
---------------
-------------
@@ -33,7 +33,7 @@
     private final String url;
     private final String username;
     private final String password;
-	
+
     public TestDataSource(String url, String user, String password) {
         this.url = url;
         this.username = user;
---------------
-------------
@@ -54,6 +54,9 @@
     }
 
     public void readRequest(HttpServletRequest request, HttpMessage message) {
+        // lets parser the parameterMap first to avoid consuming the POST parameters as InputStream
+        request.getParameterMap();
+        
         // lets force a parse of the body and headers
         message.getBody();
         // populate the headers from the request
---------------
-------------
@@ -44,7 +44,7 @@
  * @version 
  */
 public class WireTapProcessor extends ServiceSupport implements AsyncProcessor, Traceable {
-    private final static transient Logger LOG = LoggerFactory.getLogger(WireTapProcessor.class);
+    private static final transient Logger LOG = LoggerFactory.getLogger(WireTapProcessor.class);
     private final Endpoint destination;
     private final Processor processor;
     private final ExchangePattern exchangePattern;
---------------
-------------
@@ -512,7 +512,7 @@
     }
 
     public Route getRoute(String id) {
-        for (Route route : routes) {
+        for (Route route : getRoutes()) {
             if (route.getId().equals(id)) {
                 return route;
             }
---------------
-------------
@@ -191,7 +191,7 @@
             buffer.append("\n    ");
             buffer.append(JsonSchemaHelper.toJson(path.getName(), path.getType(), "", path.getDocumentation(), false, null));
         }
-        buffer.append("\n  }");
+        buffer.append("\n  },");
 
         // endpoint properties was named properties at first, and hence we stick with that naming to be compatible
         buffer.append("\n  \"properties\": {");
---------------
-------------
@@ -34,7 +34,7 @@
  *
  * @version $Revision$
  */
-@XmlRootElement(name = "consumer")
+@XmlRootElement(name = "consumerTemplate")
 @XmlAccessorType(XmlAccessType.FIELD)
 public class CamelConsumerTemplateFactoryBean extends IdentifiedType implements FactoryBean, InitializingBean, CamelContextAware {
     @XmlTransient
---------------
-------------
@@ -16,7 +16,6 @@
  */
 package org.apache.camel.component.atmosphere.websocket;
 
-import org.apache.camel.component.atmosphere.websocket.CamelWebSocketServlet;
 import org.apache.camel.test.AvailablePortFinder;
 import org.apache.camel.test.junit4.CamelTestSupport;
 import org.eclipse.jetty.server.Connector;
---------------
-------------
@@ -1341,7 +1341,7 @@
      * @param expressions the list of expressions on which to compare messages in order
      * @return the builder
      */
-    public ResequenceDefinition resequencer(Expression... expressions) {
+    public ResequenceDefinition resequence(Expression... expressions) {
         List<Expression> list = new ArrayList<Expression>();
         list.addAll(Arrays.asList(expressions));
         return resequence(list);
---------------
-------------
@@ -46,6 +46,7 @@
     public void process(Exchange exchange) throws Exception {
         JobParameters jobParameters = prepareJobParameters(exchange.getIn().getHeaders());
         JobExecution jobExecution = jobLauncher.run(job, jobParameters);
+        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
         exchange.getOut().setBody(jobExecution);
     }
 
---------------
-------------
@@ -506,6 +506,7 @@
         exchange.getIn().removeHeader(Exchange.REDELIVERED);
         exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER);
         exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER);
+        exchange.removeProperty(Exchange.FAILURE_HANDLED);
         // keep the Exchange.EXCEPTION_CAUGHT as property so end user knows the caused exception
 
         // create log message
---------------
-------------
@@ -174,7 +174,6 @@
             } else {
                 buffer.append(",");
             }
-            buffer.append(entry.getKey());
             buffer.append("\n    ");
             buffer.append(entry.getValue().toJson());
         }
---------------
-------------
@@ -233,6 +233,7 @@
             }
             aggregationRepository.add(exchange.getContext(), key, answer);
         } else {
+            // TODO: if we are completed from batch consumer then they should all complete (trigger that like timeout map)
             answer.setProperty(Exchange.AGGREGATED_COMPLETED_BY, complete);
             onCompletion(key, answer, false);
         }
---------------
-------------
@@ -71,6 +71,8 @@
         messageHeaderFiltersMap = new HashMap<String, MessageHeaderFilter>();
         addToMessageHeaderFilterMap(new SoapMessageHeaderFilter());
         
+        // filter headers begin with "Camel" or "org.apache.camel"
+        setOutFilterPattern("(Camel|org\\.apache\\.camel)[\\.|a-z|A-z|0-9]*");
     }
 
     @SuppressWarnings("unchecked")
---------------
-------------
@@ -97,7 +97,7 @@
                 if (current != null) {
                     LOGGER.debug("read zipEntry {}", current.getName());
                     answer = new DefaultMessage();
-                    answer.setHeaders(inputMessage.getHeaders());
+                    answer.getHeaders().putAll(inputMessage.getHeaders());
                     answer.setHeader("zipFileName", current.getName());
                     answer.setHeader(Exchange.FILE_NAME, current.getName());
                     answer.setBody(new ZipInputStreamWrapper(zipInputStream));
---------------
-------------
@@ -313,6 +313,9 @@
                 int size = exchange.getProperty(Exchange.AGGREGATED_SIZE, 1, Integer.class);
                 if (size >= value) {
                     return "size";
+                } else {
+                    // not completed yet
+                    return null;
                 }
             }
         }
---------------
-------------
@@ -36,7 +36,7 @@
     private Boolean prettyPrint;
 
     public XMLBeansDataFormat() {
-        super("org.apache.camel.dataformat.converter.XmlBeansDataType");
+        super("org.apache.camel.converter.xmlbeans.XmlBeansDataFormat");
     }
 
     public Boolean getPrettyPrint() {
---------------
-------------
@@ -55,7 +55,7 @@
     private AtomicBoolean bindingInitialized = new AtomicBoolean(false);
     private AtomicBoolean getBusHasBeenCalled = new AtomicBoolean(false);
 
-	private boolean isSetDefaultBus;
+    private boolean isSetDefaultBus;
 
     public CxfRsEndpoint(String endpointUri, CamelContext camelContext) {
         super(endpointUri, camelContext);
---------------
-------------
@@ -131,7 +131,7 @@
 
             // using the features to install the camel components             
             scanFeatures(getCamelKarafFeatureUrl(),                         
-                "camel-core", "camel-spring", "camel-test"),
+                "xml-specs-api", "camel-core", "camel-spring", "camel-test"),
                                    
             workingDirectory("target/paxrunner/"));
 
---------------
-------------
@@ -34,7 +34,7 @@
     }
 
     public SourceCache(String data) {
-        new StringSource(data);
+        super(data);
     }
 
     public void reset() {
---------------
-------------
@@ -71,7 +71,7 @@
     private int maxMessagesPerTask = 1;
     private ServerSessionFactory serverSessionFactory;
     private int cacheLevel = -1;
-    private String cacheLevelName = "CACHE_CONSUMER";
+    private String cacheLevelName = "CACHE_CONNECTION";
     private long recoveryInterval = -1;
     private long receiveTimeout = -1;
     private int idleTaskExecutionLimit = 1;
---------------
-------------
@@ -340,7 +340,7 @@
         if (body != null) {
             TypeConverter tc = exchange.getContext().getTypeConverterRegistry().lookup(Source.class, body.getClass());
             if (tc != null) {
-                source = tc.convertTo(Source.class, body);
+                source = tc.convertTo(Source.class, exchange, body);
             }
         }
 
---------------
-------------
@@ -68,7 +68,7 @@
         if (xmppMessage != null) {
             XmppBinding binding = ExchangeHelper.getBinding(getExchange(), XmppBinding.class);
             if (binding != null) {
-                binding.extractBodyFromXmpp(getExchange(), xmppMessage);
+                return binding.extractBodyFromXmpp(getExchange(), xmppMessage);
             }
         }
         return null;
---------------
-------------
@@ -48,7 +48,6 @@
 import org.springframework.jms.support.converter.MessageConverter;
 import org.springframework.jms.support.destination.DestinationResolver;
 import org.springframework.transaction.PlatformTransactionManager;
-import org.springframework.transaction.support.TransactionSynchronizationManager;
 import org.springframework.util.Assert;
 
 import static org.apache.camel.util.ObjectHelper.removeStartingCharacters;
---------------
-------------
@@ -120,6 +120,7 @@
             }
         } else {
             serializer.setTypeHintsEnabled(false);
+            serializer.setTypeHintsCompatibility(false);
         }
     }
 
---------------
-------------
@@ -122,7 +122,7 @@
 
     static class XMLTokenIterator implements Iterator<Object>, Closeable {
         private static final Logger LOG = LoggerFactory.getLogger(XMLTokenIterator.class);
-        private static final Pattern NAMESPACE_PATTERN = Pattern.compile("xmlns(:\\w+|)\\s*=\\s*('[^']+'|\"[^\"]+\")");
+        private static final Pattern NAMESPACE_PATTERN = Pattern.compile("xmlns(:\\w+|)\\s*=\\s*('[^']*'|\"[^\"]*\")");
 
         private AttributedQName[] splitpath;
         private int index;
---------------
-------------
@@ -30,7 +30,6 @@
 
 import org.apache.camel.Exchange;
 import org.apache.camel.StreamCache;
-import org.apache.camel.impl.SynchronizationAdapter;
 import org.apache.camel.util.FileUtil;
 import org.apache.camel.util.IOHelper;
 import org.apache.commons.logging.Log;
---------------
-------------
@@ -113,7 +113,7 @@
                 if (folder.isOpen()) {
                     folder.close(true);
                 }
-            } catch (MessagingException e) {
+            } catch (Exception e) {
                 // some mail servers will lock the folder so we ignore in this case (CAMEL-1263)
                 LOG.debug("Could not close mailbox folder: " + folder.getName(), e);
             }
---------------
-------------
@@ -40,7 +40,7 @@
         getOutFilter().add(Exchange.HTTP_PATH);
         getOutFilter().add(Exchange.DESTINATION_OVERRIDE_URL);
         // filter headers begin with "Camel" or "org.apache.camel"
-        setOutFilterPattern("((Camel|org\\.apache\\.camel)[\\.|a-z|A-z|0-9]|(?i)Content-Type)*");
+        setOutFilterPattern("((Camel|org\\.apache\\.camel)[\\.|a-z|A-z|0-9]*)|(?i)Content-Type");
 
     }
 
---------------
-------------
@@ -49,7 +49,7 @@
         context.stop();
     }
 
-    protected CamelContext createCamelContext() {
+    protected CamelContext createCamelContext() throws Exception {
         return new DefaultCamelContext();
     }
 
---------------
-------------
@@ -72,6 +72,8 @@
                 try {
                     // cleanup temporary file
                     if (tempFile != null) {
+                        // close the stream first and than delete the file
+                        close();
                         boolean deleted = tempFile.delete();
                         if (!deleted) {
                             LOG.warn("Cannot delete temporary cache file: " + tempFile);
---------------
-------------
@@ -38,8 +38,6 @@
  */
 @RunWith(Suite.class)
 @Suite.SuiteClasses({org.openscience.smsd.IsomorphismTest.class,
-    org.openscience.smsd.SMSDBondSensitiveTest.class,
-    org.openscience.smsd.SMSDBondInsensitiveTest.class,
     org.openscience.smsd.global.GlobalSuite.class,
     org.openscience.smsd.helper.HelperSuite.class,
     //        org.openscience.cdk.smsd.interfaces.InterfacesSuite.class,
---------------
-------------
@@ -63,7 +63,7 @@
 public class DomainValidator implements Serializable {
 
     // Regular expression strings for hostnames (derived from RFC2396 and RFC 1123)
-    private static final String DOMAIN_LABEL_REGEX = "\\p{Alnum}[\\p{Alnum}-]*\\p{Alnum}";
+    private static final String DOMAIN_LABEL_REGEX = "\\p{Alnum}(?:[\\p{Alnum}-]*\\p{Alnum})*";
     private static final String TOP_LABEL_REGEX = "\\p{Alpha}{2,}";
     private static final String DOMAIN_NAME_REGEX =
             "^(?:" + DOMAIN_LABEL_REGEX + "\\.)+" + "(" + TOP_LABEL_REGEX + ")$";
---------------
-------------
@@ -143,6 +143,8 @@
 				String[] macro = StringSplitter.splitIgnoreInQuotes(items[i], MACRO_SEPARATOR, true);
 				if(macro.length == 2)
 					macrosInput.getMacrosMap().put(macro[0], macro[1]);
+				else if(macro.length == 1) //if it is an empty value macro
+		        	macrosInput.getMacrosMap().put(macro[0], ""); //$NON-NLS-1$
 			}				
 		}
 		return macrosInput;
---------------
-------------
@@ -58,7 +58,7 @@
 		
 		
 		if(pvName.startsWith("const://")) {//$NON-NLS-1$			
-			final int value_start = pvName.indexOf('('); //$NON-NLS-1$
+			final int value_start = pvName.lastIndexOf('('); //$NON-NLS-1$
 			if (value_start > 0) {
 				final int value_end = pvName.lastIndexOf(')'); //$NON-NLS-1$
 				if (value_end > 0) {
---------------
-------------
@@ -19,7 +19,7 @@
 		
 		int localStart = startIndex;
 		while (preMatcher.find(localStart)) {
-			localStart = preMatcher.start();
+			localStart = preMatcher.end();
 			
 			while (postMatcher.find(localStart + 1)) {
 				final int end = postMatcher.end();
---------------
-------------
@@ -494,7 +494,7 @@
             Set<ExternalIdentifierEntity> externalIdentifierEntities = null;
 
             if (existingExternalIdentifiers == null) {
-                externalIdentifierEntities = new HashSet<ExternalIdentifierEntity>();
+                externalIdentifierEntities = new TreeSet<ExternalIdentifierEntity>();
             } else {
                 // To allow for orphan deletion
                 existingExternalIdentifiers.clear();
---------------
-------------
@@ -54,7 +54,7 @@
 
 public class Jpa2JaxbAdapterImpl implements Jpa2JaxbAdapter {
 
-    @Value("${org.orcid.core.baseUri:}")
+    @Value("${org.orcid.core.baseUri:http://orcid.org}")
     private String baseUri = null;
 
     private DatatypeFactory datatypeFactory = null;
---------------
-------------
@@ -109,6 +109,8 @@
             CacheConfiguration config = createConfig();
             this.cache = new Cache(config);
             cacheManager.addCache(this.cache);
+        } else {
+            this.cache = existingCache;
         }
     }
 
---------------
-------------
@@ -494,7 +494,7 @@
             Set<ExternalIdentifierEntity> externalIdentifierEntities = null;
 
             if (existingExternalIdentifiers == null) {
-                externalIdentifierEntities = new HashSet<ExternalIdentifierEntity>();
+                externalIdentifierEntities = new TreeSet<ExternalIdentifierEntity>();
             } else {
                 // To allow for orphan deletion
                 existingExternalIdentifiers.clear();
---------------
-------------
@@ -31,7 +31,7 @@
   public Value execute(SandboxImpl sandbox) {
     try {
       Value result = function.invoke(sandbox, calculateArguments());
-      if (result == null && !isNullResultAllowed()) {
+      if (result == null && !isNullResultAllowed() && !sandbox.messageGroup().containsProblems()) {
         sandbox.report(new NullResultError());
       } else {
         return result;
---------------
-------------
@@ -37,7 +37,7 @@
 
   private Function createFunction(Class<?> klass) {
     try {
-      return pluginFactory.create(klass);
+      return pluginFactory.create(klass, true);
     } catch (PluginImplementationException e) {
       throw new RuntimeException("Builtin plugin " + klass.getCanonicalName()
           + " has implementation problem.", e);
---------------
-------------
@@ -35,7 +35,7 @@
   }
 
   private Path readPathImpl() throws IOException {
-    int size = inputStream.readInt();
+    int size = readInt();
     byte[] bytes = readBytes(size, "path");
 
     /*
---------------
-------------
@@ -34,7 +34,7 @@
   private static final String STRING_A_N = "String[]";
   private static final String BLOB_A_N = "Blob[]";
   private static final String FILE_A_N = "File[]";
-  private static final String EMPTY_A_N = "Any[]";
+  private static final String EMPTY_A_N = "Nothing[]";
 
   /*
    * Smooth types. Used by smooth-build code to represent smooth types.
---------------
-------------
@@ -33,7 +33,7 @@
   public void report(MessageGroup messageGroup) {
     String groupHeader = GROUP_PREFIX + messageGroup.name();
     if (messageGroup.isResultFromCache()) {
-      groupHeader = Strings.padEnd(messageGroup.name(), 42, ' ') + " CACHE";
+      groupHeader = Strings.padEnd(groupHeader, 42, ' ') + " CACHE";
     }
     println(groupHeader);
 
---------------
-------------
@@ -40,7 +40,7 @@
 
   @Override
   public boolean hasChild(String name) {
-    throw new UnsupportedOperationException();
+    return false;
   }
 
   @Override
---------------
-------------
@@ -18,7 +18,7 @@
   private final CodeLocation codeLocation;
 
   public static Argument explicitArg(String name, DefinitionNode node, CodeLocation codeLocation) {
-    return new Argument(name, node, codeLocation);
+    return new Argument(checkNotNull(name), node, codeLocation);
   }
 
   public static Argument implicitArg(DefinitionNode node, CodeLocation codeLocation) {
---------------
-------------
@@ -59,7 +59,7 @@
 	 * @param c
 	 * @throws ConfigException In case of invalid configuration.
 	 */
-	public void configure(C newConfig) throws ConfigException {
+	public void configureDirectly(C newConfig) throws ConfigException {
 		if (newConfig != null && newConfig.isValid()) {
 			config = newConfig;
 		} else {
---------------
-------------
@@ -38,7 +38,7 @@
 @JsonAutoDetect(fieldVisibility = ANY, setterVisibility = NONE, getterVisibility = NONE)
 public class ContainerInfo {
 
-  @JsonProperty("ID") private String id;
+  @JsonProperty("Id") private String id;
   @JsonProperty("Created") private Date created;
   @JsonProperty("Path") private String path;
   @JsonProperty("Args") private ImmutableList<String> args;
---------------
-------------
@@ -38,7 +38,7 @@
 @JsonAutoDetect(fieldVisibility = ANY, setterVisibility = NONE, getterVisibility = NONE)
 public class ContainerInfo {
 
-  @JsonProperty("ID") private String id;
+  @JsonProperty("Id") private String id;
   @JsonProperty("Created") private Date created;
   @JsonProperty("Path") private String path;
   @JsonProperty("Args") private ImmutableList<String> args;
---------------
-------------
@@ -131,7 +131,7 @@
 	 * @return DateFormat instance for ISO format
 	 */
 	public static DateFormat getISODateFormat() {
-		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
+		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXX");
 		sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
 		sdf.setLenient(false);
 		return sdf;
---------------
-------------
@@ -131,7 +131,7 @@
 	 * @return DateFormat instance for ISO format
 	 */
 	public static DateFormat getISODateFormat() {
-		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
+		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXX");
 		sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
 		sdf.setLenient(false);
 		return sdf;
---------------
-------------
@@ -239,7 +239,7 @@
 		XContentParser parser = null;
 		try {
 			parser = XContentFactory.xContent(XContentType.JSON).createParser(TestUtils.class.getResourceAsStream(filePath));
-			return parser.mapAndClose();
+			return parser.mapOrderedAndClose();
 		} catch (IOException e) {
 			throw new RuntimeException(e.getMessage(), e);
 		} finally {
---------------
-------------
@@ -73,7 +73,7 @@
     @Override
     public void onStart(ITestContext iTestContext) {
         getLifecycle().fire(new TestSuiteStartedEvent(
-                getSuiteUid(iTestContext), iTestContext.getSuite().getName()
+                getSuiteUid(iTestContext), getCurrentSuiteTitle(iTestContext)
         ).withTitle(
                 getCurrentSuiteTitle(iTestContext)
         ).withLabels(
---------------
-------------
@@ -73,7 +73,7 @@
     @Override
     public void onStart(ITestContext iTestContext) {
         getLifecycle().fire(new TestSuiteStartedEvent(
-                getSuiteUid(iTestContext), iTestContext.getSuite().getName()
+                getSuiteUid(iTestContext), getCurrentSuiteTitle(iTestContext)
         ).withTitle(
                 getCurrentSuiteTitle(iTestContext)
         ).withLabels(
---------------
-------------
@@ -460,6 +460,8 @@
 
 				// check whether we can create a condition for them (i.e. the condition is parseable)
 				final EObjectCondition condition = OCLConditionHelper.getWhereCondition(oclCondition);
+				if (condition == null)
+					OCLConditionHelper.getWhereCondition(oclCondition);
 				assertNotNull("The OCL expression could not be processed: " + oclCondition.getExpression(), condition);
 
 			} else
---------------
-------------
@@ -99,7 +99,7 @@
     }catch(TokenMgrError tme){
       errors.add(new Error(
             tme.getMessage(),
-            toFile(uri),
+            super.toFile(uri), // need to use the super version
             tme.getErrorLine(),
             1,
             false
---------------
-------------
@@ -177,6 +177,7 @@
                         currentToken = RobotTokenTypes.GHERKIN;
                         level.push(GHERKIN);
                     } else if (isVariableDeclaration(word)) {
+                        goToNextNewLineOrSuperSpace();
                         currentToken = RobotTokenTypes.VARIABLE_DEFINITION;
                         level.push(VARIABLE_DEFINITION);
                     } else {
---------------
-------------
@@ -23,6 +23,7 @@
     public static Map<String, String> makeTestConfig() {
         HashMap<String, String> config = new HashMap<>(play.test.Helpers.inMemoryDatabase());
         config.put("ebean.default", "models.*");
+        config.put("application.secret", "foo");
         return config;
     }
 
---------------
-------------
@@ -236,7 +236,7 @@
                     new BufferedInputStream(new FileInputStream(file)), meta);
             this.mimeType = mediaType.toString();
             if (mediaType.getType().toLowerCase().equals("text")) {
-                this.mimeType += " ;charset=" + FileUtil.detectCharset(new FileInputStream(file));
+                this.mimeType += "; charset=" + FileUtil.detectCharset(new FileInputStream(file));
             }
         }
 
---------------
-------------
@@ -44,7 +44,7 @@
     public Long id;
     public String name;
 
-    @Pattern(value = "^[a-zA-Z0-9_]*$", message = "user.wrongloginId.alert") @Required
+    @Pattern(value = "^[a-zA-Z0-9-]+([_.][a-zA-Z0-9-]+)*$", message = "user.wrongloginId.alert") @Required
     public String loginId;
     public String password;
     public String passwordSalt;
---------------
-------------
@@ -3547,7 +3547,7 @@
         return true;
     }
 
-    private static final Pattern PAT_JAVA_VERSION = Pattern.compile("(?<major>\\d+)\\.(?<minor>\\d+)\\.(?<patch>\\d+)(_(?<update>\\d+))?(-(?<pre>[^-]+))?(-(?<build>.+))?");
+    private static final Pattern PAT_JAVA_VERSION = Pattern.compile("(?<major>\\d+)\\.(?<minor>\\d+)(?:\\.(?<patch>\\d+))?(_(?<update>\\d+))?(-(?<pre>[^-]+))?(-(?<build>.+))?");
 
     // visible for testing
     static int[] parseJavaVersion(String v) {
---------------
-------------
@@ -796,7 +796,7 @@
     protected final boolean hasCaplet(String name) {
         for (Capsule c = cc; c != null; c = c.sup) {
             for (Class<?> cls = c.getClass(); cls != null; cls = cls.getSuperclass()) {
-                if (name.equals(cls.getClass().getName()))
+                if (name.equals(cls.getName()))
                     return true;
             }
         }
---------------
-------------
@@ -2341,7 +2341,7 @@
 
     private static boolean isJavaHome(Path dir) {
         if (Files.isDirectory(dir))
-            return findFile(dir, "bin" + FILE_SEPARATOR + "{java|java.exe}", true) != null;
+            return findFile(dir, "bin" + FILE_SEPARATOR + "java{.exe,}", true) != null;
         return false;
     }
 
---------------
-------------
@@ -121,6 +121,7 @@
                 } catch (NoSuchMethodException ex) { /* do nothing */ }
                 if (null != valueMethod) {
                     try {
+                        valueMethod.setAccessible(true);
                         return valueMethod.invoke(annotation);
                     } catch (Exception e) {
                         throw new RuntimeException(e);
---------------
-------------
@@ -120,6 +120,7 @@
 
         if (metaBean instanceof DynamicMetaBean) {
             metaBean = metaBean.resolveMetaBean(ObjectUtils.defaultIfNull(validationContext.getBean(), rawType));
+            validationContext.setMetaBean(metaBean);
         }
         MetaProperty mp = metaBean.getProperty(token);
         if (mp == null) {
---------------
-------------
@@ -110,6 +110,8 @@
             return TO_SHORT;
         if (clazz == Byte.class)
             return TO_BYTE;
+        if (clazz == Character.class)
+            return TO_CHARACTER;
 
         return null;
     }
---------------
-------------
@@ -516,6 +516,7 @@
                         continue;
                     }
                     if (c == '"' || c == '\'') {
+                        stringChar = c;
                         inString = true;
                     }
                 }
---------------
-------------
@@ -238,6 +238,7 @@
             } else {
                 // handle updated names from transformed columns.
                 checkBox.setText(col.getName());
+                checkBox.setSelected(true);
             }
         }
 
---------------
-------------
@@ -432,7 +432,7 @@
     @Override
     public String getCheckClause(String clause) {
         clause = getScriptQuoted(clause);
-        if (!clause.startsWith("(") && !clause.endsWith(")")) {
+        if (clause != null && (!clause.startsWith("(") || !clause.endsWith(")"))) {
             return "(" + clause + ")";
         } else {
             return clause;
---------------
-------------
@@ -78,7 +78,7 @@
         Backup backup = rowSet.getBackup();
         ConnectionSpec connectionSpec = database.getConnectionSpec();
         if ((connectionSpec.getCatalog() != null || connectionSpec.getSchema() != null) &&
-                backup.getDatabase() != null && backup.getDatabase().getSchemas().size() == 1) {
+                backup.getDatabase() != null && backup.getDatabase().getSchemas().size() <= 1) {
             addIgnoreNull(qualifiers, connectionSpec.getCatalog());
             addIgnoreNull(qualifiers, connectionSpec.getSchema());
         } else {
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -162,9 +162,10 @@
      *            file descriptor pointing to a full snapshot of the
      *            application's data.  The application should consume every
      *            entity represented in this data stream.
-     * @param appVersionCode The
-     *            {@link android.R.styleable#AndroidManifest_versionCode android:versionCode}
-     *            value of the application that backed up this particular data set. This
+     * @param appVersionCode The value of the <a
+     * href="{@docRoot}guide/topics/manifest/manifest-element.html#vcode">{@code
+     *            android:versionCode}</a> manifest attribute,
+     *            from the application that backed up this particular data set. This
      *            makes it possible for an application's agent to distinguish among any
      *            possible older data versions when asked to perform the restore
      *            operation.
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -93,7 +93,7 @@
                     webView.addJavascriptInterface(object, name);
                     webView.getSettings().setJavaScriptEnabled(true);
                     webView.setWebViewClient(mWebViewClient);
-                    webView.loadData("<html><head></head><body></body></html>", "text/html", null);
+                    webView.loadData("<!DOCTYPE html><title></title>", "text/html", null);
                 }
             });
             mWebViewClient.waitForOnPageFinished();
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -23,7 +23,6 @@
 
     public static String[] children() {
         return new String[] {
-                StringTest.class.getName(),
                 HashMapPerformanceTest.class.getName(),
                 ArrayListPerformanceTest.class.getName(),
                 TreeMapPerformanceTest.class.getName(),
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -56,7 +56,7 @@
     static Pattern sAddressPattern = Pattern.compile(
             /* scheme    */ "(?:(http|https|file)\\:\\/\\/)?" +
             /* authority */ "(?:([-A-Za-z0-9$_.+!*'(),;?&=]+(?:\\:[-A-Za-z0-9$_.+!*'(),;?&=]+)?)@)?" +
-            /* host      */ "([-" + GOOD_IRI_CHAR + "%_]+(?:\\.[-" + GOOD_IRI_CHAR + "%_]+)*|\\[[0-9a-fA-F:\\.]+\\])?" +
+            /* host      */ "([" + GOOD_IRI_CHAR + "%_-][" + GOOD_IRI_CHAR + "%_\\.-]*|\\[[0-9a-fA-F:\\.]+\\])?" +
             /* port      */ "(?:\\:([0-9]*))?" +
             /* path      */ "(\\/?[^#]*)?" +
             /* anchor    */ ".*", Pattern.CASE_INSENSITIVE);
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -152,7 +152,13 @@
             concatRef.refNumber = refNumber;
             concatRef.seqNumber = i + 1;  // 1-based sequence
             concatRef.msgCount = msgCount;
-            concatRef.isEightBits = false;
+            // TODO: We currently set this to true since our messaging app will never
+            // send more than 255 parts (it converts the message to MMS well before that).
+            // However, we should support 3rd party messaging apps that might need 16-bit
+            // references
+            // Note:  It's not sufficient to just flip this bit to true; it will have
+            // ripple effects (several calculations assume 8-bit ref).
+            concatRef.isEightBits = true;
             SmsHeader smsHeader = new SmsHeader();
             smsHeader.concatRef = concatRef;
 
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -43,7 +43,7 @@
 
     public String generateMappingKey() {
         StringBuilder builder = new StringBuilder();
-        final String requestAsString = request.getResourceRef().toString();
+        String requestAsString =getHttpServletRequest().getContextPath();
         final String pathTemplate = StringUtils.substringAfter(requestAsString, API_EXTENSION_TEMPLATE_PREFIX);
 
         builder.append(MAPPING_KEY_PREFIX)
---------------
-------------
@@ -27,7 +27,7 @@
  */
 public class URLProtector {
 
-    protected List<String> tokens = Arrays.asList("https", "http", "www", "HTTPS", "HTTP", "WWW");
+    protected List<String> tokens = Arrays.asList("https", "http", "www", "HTTPS", "HTTP", "WWW", "//");
 
     public String protectRedirectUrl(String redirectUrl) {
         if (redirectUrl != null && !redirectUrl.startsWith("portal")) {
---------------
-------------
@@ -127,7 +127,7 @@
                 request.getRequestDispatcher(apiPath).forward(request, response);
             } else {
                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,
-                        "One of the separator '/content', '/them' or '/API' is expected in the URL after the application token and the page token.");
+                        "One of the separator '/content', '/theme' or '/API' is expected in the URL after the application token and the page token.");
             }
 
         } else {
---------------
-------------
@@ -40,6 +40,7 @@
         mapping.put(ArchivedHumanTaskItem.ATTRIBUTE_PRIORITY, ArchivedActivityInstanceSearchDescriptor.PRIORITY);
         mapping.put(ArchivedHumanTaskItem.ATTRIBUTE_TYPE, ArchivedActivityInstanceSearchDescriptor.ACTIVITY_TYPE);
         mapping.put(ArchivedActivityItem.ATTRIBUTE_SOURCE_OBJECT_ID, ArchivedActivityInstanceSearchDescriptor.SOURCE_OBJECT_ID);
+        mapping.put(ArchivedActivityItem.ATTRIBUTE_ARCHIVED_DATE, ArchivedActivityInstanceSearchDescriptor.ARCHIVE_DATE);
     }
 
     public ArchivedActivitySearchDescriptorConverter() {
---------------
-------------
@@ -27,7 +27,7 @@
  */
 public class URLProtector {
 
-    protected List<String> tokens = Arrays.asList("https", "http", "www", "HTTPS", "HTTP", "WWW");
+    protected List<String> tokens = Arrays.asList("https", "http", "www", "HTTPS", "HTTP", "WWW", "//");
 
     public String protectRedirectUrl(String redirectUrl) {
         if (redirectUrl != null && !redirectUrl.startsWith("portal")) {
---------------
-------------
@@ -30,7 +30,7 @@
 
     @Override
     public String defineDefaultSearchOrder() {
-        return TaskItem.ATTRIBUTE_DISPLAY_NAME + ISearchDirection.SORT_ORDER_ASCENDING;
+        return TaskItem.ATTRIBUTE_LAST_UPDATE_DATE + ISearchDirection.SORT_ORDER_DESCENDING;
     }
 
 }
---------------
-------------
@@ -222,7 +222,7 @@
             ResourcesPermissionsMapping resourcesPermissionsMapping) {
         List<String> resourcePermissions = resourcesPermissionsMapping.getResourcePermissions(method, apiName, resourceName, resourceId);
         if(resourcePermissions.isEmpty()){
-            resourcePermissions = resourcesPermissionsMapping.getResourcePermissions(method, apiName, resourceName,null);
+            resourcePermissions = resourcesPermissionsMapping.getResourcePermissions(method, apiName, resourceName, null);
         }
         //get the resource permission mapping
         for (String resourcePermission : resourcePermissions) {
---------------
-------------
@@ -33,7 +33,7 @@
     public Long resolvePageId(APISession apiSession) throws BonitaException {
         final HttpServletRequest httpServletRequest = getHttpServletRequest();
         final PageReference pageReference;
-        pageReference = pageMappingService.getPage(httpServletRequest, apiSession, generateMappingKey(), httpServletRequest.getLocale());
+        pageReference = pageMappingService.getPage(httpServletRequest, apiSession, generateMappingKey(), httpServletRequest.getLocale(),false);
         return pageReference.getPageId();
     }
 
---------------
-------------
@@ -27,7 +27,7 @@
  */
 public class URLProtector {
 
-    protected List<String> tokens = Arrays.asList("https", "http", "www", "HTTPS", "HTTP", "WWW");
+    protected List<String> tokens = Arrays.asList("https", "http", "www", "HTTPS", "HTTP", "WWW", "//");
 
     public String protectRedirectUrl(String redirectUrl) {
         if (redirectUrl != null && !redirectUrl.startsWith("portal")) {
---------------
-------------
@@ -257,7 +257,7 @@
         findTransformerForWrite( content.getClass() ) );
     session.save();
     JcrRepositoryFileUtils.checkinNearestVersionableFileIfNecessary( session, pentahoJcrConstants, file.getId(),
-        versionMessage, new java.util.Date(), true );
+        versionMessage, file.getCreatedDate() != null ? file.getCreatedDate() : new java.util.Date(), true );
     lockHelper.removeLockTokenFromSessionIfNecessary( session, pentahoJcrConstants, file.getId() );
     return JcrRepositoryFileUtils.nodeIdToFile( session, pentahoJcrConstants, pathConversionHelper, lockHelper, file
         .getId() );
---------------
-------------
@@ -119,7 +119,7 @@
     return true;
   }
 
-  @Override
+  //don't add @Override annotation for Java 6 compatibility (class Driver doesn't have getParentLogger method in Java 6)
   public Logger getParentLogger() throws SQLFeatureNotSupportedException {
     throw new SQLFeatureNotSupportedException( "Impossible to know which Driver to fetch the logger from" );
   }
---------------
-------------
@@ -257,7 +257,7 @@
         findTransformerForWrite( content.getClass() ) );
     session.save();
     JcrRepositoryFileUtils.checkinNearestVersionableFileIfNecessary( session, pentahoJcrConstants, file.getId(),
-        versionMessage, new java.util.Date(), true );
+        versionMessage, file.getCreatedDate() != null ? file.getCreatedDate() : new java.util.Date(), true );
     lockHelper.removeLockTokenFromSessionIfNecessary( session, pentahoJcrConstants, file.getId() );
     return JcrRepositoryFileUtils.nodeIdToFile( session, pentahoJcrConstants, pathConversionHelper, lockHelper, file
         .getId() );
---------------
-------------
@@ -143,7 +143,7 @@
             UserSetting setting = new UserSetting();
             setting.setSettingName( key.substring( SETTING_PREFIX.length() ) );
             setting.setSettingValue( tenantMetadata.get( key ).toString() );
-            if ( setting.getSettingValue().equals( settingName ) ) {
+            if ( setting.getSettingName().equals( settingName ) ) {
               return setting;
             }
           }
---------------
-------------
@@ -17,6 +17,8 @@
 import java.io.Serializable;
 import java.util.*;
 
+import javax.jcr.AccessDeniedException;
+
 import org.pentaho.platform.api.locale.IPentahoLocale;
 import org.pentaho.platform.api.repository2.unified.IRepositoryFileData;
 import org.pentaho.platform.api.repository2.unified.IUnifiedRepository;
---------------
-------------
@@ -17,6 +17,8 @@
 import java.io.Serializable;
 import java.util.*;
 
+import javax.jcr.AccessDeniedException;
+
 import org.pentaho.platform.api.locale.IPentahoLocale;
 import org.pentaho.platform.api.repository2.unified.IRepositoryFileData;
 import org.pentaho.platform.api.repository2.unified.IUnifiedRepository;
---------------
-------------
@@ -84,9 +84,6 @@
     this.applicationMasterMem = applicationMasterMem;
     this.defaultFs = defaultFs;
     this.yarnSiteXml = yarnSiteXml;
-    
-    //TODO: this variable should be removed
-    this.containerCount = 1;
   }
   
   
---------------
-------------
@@ -35,7 +35,6 @@
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import java.lang.reflect.*;
 
 /**
  * $Id$
---------------
-------------
@@ -33,7 +33,6 @@
 package org.lwjgl.opengl;
 
 import org.lwjgl.*;
-import org.lwjgl.Window;
 
 /**
  * $Id$
---------------
-------------
@@ -226,7 +226,7 @@
             String password = jsc.getPassword();
 
             log.info("Triggering jenkins build id " + jenkinsBuildId + " on hash " + hashToBuild
-                + " (" + user + "@" + url + " pw: " + password + ")");
+                + " (" + user + "@" + url + " pw: " + password.replaceAll(".", "*") + ")");
 
             final JenkinsServer js = jenkinsClientManager.getJenkinsServer(jsc, rc);
             Map<String, Job> jobMap = js.getJobs();
---------------
-------------
@@ -51,7 +51,7 @@
                                 final RiemannFacade facade, final TimeUnit timeUnit,
                                 final long interval) {
     super("zookeeper");
-    this.scheduler = Executors.newScheduledThreadPool(1);
+    this.scheduler = Executors.newScheduledThreadPool(2);
     this.cache = new PathChildrenCache(zooKeeperClient.getCuratorFramework(), path, true, false,
         scheduler);
     this.facade = facade.stack("zookeeper-connection");
---------------
-------------
@@ -62,7 +62,7 @@
   private static final Logger log = LoggerFactory.getLogger(TaskConfig.class);
 
   private static final Pattern CONTAINER_NAME_FORBIDDEN = Pattern.compile("[^a-zA-Z0-9_-]");
-  private static final int HOST_NAME_MAX = 64;
+  private static final int HOST_NAME_MAX = 63;
 
   private final String host;
   private final Map<String, Integer> ports;
---------------
-------------
@@ -43,6 +43,8 @@
         IOException, ClassNotFoundException {
     // BSP job configuration
     HamaConfiguration conf = new HamaConfiguration();
+    conf.setFloat(GradientDescentBSP.ALPHA, 0.002f);
+    conf.setFloat(GradientDescentBSP.THRESHOLD, 0.2f);
 
     BSPJob bsp = new BSPJob(conf, GradientDescentExample.class);
     // Set the job name
---------------
-------------
@@ -50,7 +50,7 @@
         }
 
         @Override public String getDisplayName() {
-            return "Catch Error and Continue";
+            return "Catch error and set build result";
         }
 
         @Override public boolean takesImplicitBlockArgument() {
---------------
-------------
@@ -39,7 +39,7 @@
       while (start > -1) {
         if (start > 0 && src[start - 1] == '\\') {
           // the variable is escaped. remove the backslash.
-          builder.append(src, offset, start - 1).append(openToken);
+          builder.append(src, offset, start - offset - 1).append(openToken);
           offset = start + openToken.length();
         } else {
           int end = text.indexOf(closeToken, start);
---------------
-------------
@@ -455,7 +455,7 @@
           if(constructor == null) {
             binder.bind(assistedReturnType).to((Key)returnType);
           } else {
-            binder.bind(assistedReturnType).toConstructor((Constructor)constructor);
+            binder.bind(assistedReturnType).toConstructor((Constructor)constructor, (TypeLiteral)returnType.getTypeLiteral());
           }
         }
       }
---------------
-------------
@@ -40,7 +40,10 @@
       T t = injector.callInContext(new ContextualCallable<T>() {
         public T call(InternalContext context) throws ErrorsException {
           Dependency dependency = context.getDependency();
-          return internalFactory.get(errors, context, dependency, false);
+          // Always pretend that we are a linked binding, to support
+          // scoping implicit bindings.  If we are not actually a linked
+          // binding, we'll fail properly elsewhere in the chain.
+          return internalFactory.get(errors, context, dependency, true);
         }
       });
       errors.throwIfNewErrors(0);
---------------
-------------
@@ -91,6 +91,7 @@
 		Session session = this.getSessionFactory().getCurrentSession();
 		try {
 			Criteria criteria = session.createCriteria(Synchronization.class);
+			criteria.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);
 			ret = criteria.list();
 		} catch (Exception e) {
 			logger.error("error in findAll()", e);
---------------
-------------
@@ -56,7 +56,7 @@
 
 	@Override
 	public Tag getTagValue() throws JargonException {
-		Tag message = new Tag("authPlugReqInp_PI", new Tag[] {
+		Tag message = new Tag(PI_TAG, new Tag[] {
 				new Tag(L1_DESC_INX, getFileDescriptor()),
 				new Tag(BYTES_WRITTEN, getBytesWritten()) });
 		return message;
---------------
-------------
@@ -788,7 +788,7 @@
 				fBuffer.append(" extends "); //$NON-NLS-1$
 				for (int j= 0; j < bounds.length; j++) {
 					if (j > 0) {
-						fBuffer.append(JavaElementLabels.COMMA_STRING);
+						fBuffer.append(" & "); //$NON-NLS-1$
 					}
 					appendTypeSignatureLabel(typeParameter, bounds[j], flags);
 				}
---------------
-------------
@@ -39,6 +39,7 @@
 		suite.addTest(JavaModelUtilTest.allTests());
 		suite.addTest(NameProposerTest.allTests());
 		suite.addTest(TextEditTests.allTests());
+		suite.addTest(PrimaryWorkingCopyTest.allTests());
 		suite.addTest(TypeInfoTest.allTests());	
 		suite.addTest(CallHierarchyTest.allTests());
 		suite.addTest(ScopeAnalyzerTest.allTests());
---------------
-------------
@@ -617,7 +617,7 @@
 		AST ast= node.getAST();
 		ITypeBinding stringBinding= ast.resolveWellKnownType("java.lang.String"); //$NON-NLS-1$
 
-		if (node instanceof StringLiteral || node instanceof SimpleName) {
+		if (node instanceof Expression && !(node instanceof InfixExpression)) {
 			node= node.getParent();
 		}
 		if (node instanceof VariableDeclarationFragment) {
---------------
-------------
@@ -1627,7 +1627,7 @@
 		}
 		
 		ASTNode selectedNode= problem.getCoveringNode(context.getASTRoot());
-		if (selectedNode instanceof Name && selectedNode.getParent() instanceof SwitchStatement) {
+		if (selectedNode instanceof Expression && selectedNode.getLocationInParent() == SwitchStatement.EXPRESSION_PROPERTY) {
 			SwitchStatement statement= (SwitchStatement) selectedNode.getParent();
 			ITypeBinding binding= statement.getExpression().resolveTypeBinding();
 			if (binding == null || !binding.isEnum()) {
---------------
-------------
@@ -1346,6 +1346,7 @@
 												typeArgument= typeArguments[k];
 												typeArgumentsList.add(importRewrite.addImport(typeArgument, ast));
 											}
+											break;
 										}
 									}
 								}
---------------
-------------
@@ -250,7 +250,7 @@
 			ASTNode node= ASTResolving.findParentType(fNode);
 			if (targetTypeDecl.equals(node)) {
 				modifiers |= Modifier.PRIVATE;
-			} else if (node instanceof AnonymousClassDeclaration) {
+			} else if (node instanceof AnonymousClassDeclaration && ASTNodes.isParent(node, targetTypeDecl)) {
 				modifiers |= Modifier.PROTECTED;
 			} else {
 				modifiers |= Modifier.PUBLIC;
---------------
-------------
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Tom Eicher - bug 238746
  *******************************************************************************/
 package org.eclipse.jdt.internal.ui.javaeditor;
 
---------------
-------------
@@ -69,6 +69,7 @@
 		options.put(DefaultCodeFormatterConstants.FORMATTER_TAB_SIZE, "4");
 		options.put(DefaultCodeFormatterConstants.FORMATTER_NUMBER_OF_EMPTY_LINES_TO_PRESERVE, String.valueOf(99));
 		options.put(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER, JavaCore.ERROR);
+		options.put(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION, JavaCore.IGNORE);
 		
 		JavaCore.setOptions(options);			
 
---------------
-------------
@@ -104,6 +104,8 @@
             throw new CitrusRuntimeException(e);
         } catch (IllegalAccessException e) {
             throw new CitrusRuntimeException(e);
+        } catch (AssertionError e) {
+            throw new CitrusRuntimeException("Groovy script validation failed with assertion error:\n" + e.getMessage(), e);
         }
     }
 
---------------
-------------
@@ -149,8 +149,8 @@
     servletContainerBridge.destroy();
     try {
       httpService.unregister( rootPath );
-    } catch( IllegalArgumentException iae ) {
-      // do nothing
+    } catch( Exception jerseyShutdownException ) {
+      // do nothing because jersey sometimes throws an exception during shutdown
     }
     return new ArrayList<Object>( getRootApplication().getSingletons() );
   }
---------------
-------------
@@ -68,6 +68,6 @@
     if( interval == null ){
       return DEFAULT_PUBLISH_DELAY;
     }
-    return Long.parseLong( ( String )interval );
+    return ( ( Long )interval );
   }
 }
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -162,9 +162,10 @@
      *            file descriptor pointing to a full snapshot of the
      *            application's data.  The application should consume every
      *            entity represented in this data stream.
-     * @param appVersionCode The
-     *            {@link android.R.styleable#AndroidManifest_versionCode android:versionCode}
-     *            value of the application that backed up this particular data set. This
+     * @param appVersionCode The value of the <a
+     * href="{@docRoot}guide/topics/manifest/manifest-element.html#vcode">{@code
+     *            android:versionCode}</a> manifest attribute,
+     *            from the application that backed up this particular data set. This
      *            makes it possible for an application's agent to distinguish among any
      *            possible older data versions when asked to perform the restore
      *            operation.
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -93,7 +93,7 @@
                     webView.addJavascriptInterface(object, name);
                     webView.getSettings().setJavaScriptEnabled(true);
                     webView.setWebViewClient(mWebViewClient);
-                    webView.loadData("<html><head></head><body></body></html>", "text/html", null);
+                    webView.loadData("<!DOCTYPE html><title></title>", "text/html", null);
                 }
             });
             mWebViewClient.waitForOnPageFinished();
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -23,7 +23,6 @@
 
     public static String[] children() {
         return new String[] {
-                StringTest.class.getName(),
                 HashMapPerformanceTest.class.getName(),
                 ArrayListPerformanceTest.class.getName(),
                 TreeMapPerformanceTest.class.getName(),
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -56,7 +56,7 @@
     static Pattern sAddressPattern = Pattern.compile(
             /* scheme    */ "(?:(http|https|file)\\:\\/\\/)?" +
             /* authority */ "(?:([-A-Za-z0-9$_.+!*'(),;?&=]+(?:\\:[-A-Za-z0-9$_.+!*'(),;?&=]+)?)@)?" +
-            /* host      */ "([-" + GOOD_IRI_CHAR + "%_]+(?:\\.[-" + GOOD_IRI_CHAR + "%_]+)*|\\[[0-9a-fA-F:\\.]+\\])?" +
+            /* host      */ "([" + GOOD_IRI_CHAR + "%_-][" + GOOD_IRI_CHAR + "%_\\.-]*|\\[[0-9a-fA-F:\\.]+\\])?" +
             /* port      */ "(?:\\:([0-9]*))?" +
             /* path      */ "(\\/?[^#]*)?" +
             /* anchor    */ ".*", Pattern.CASE_INSENSITIVE);
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -152,7 +152,13 @@
             concatRef.refNumber = refNumber;
             concatRef.seqNumber = i + 1;  // 1-based sequence
             concatRef.msgCount = msgCount;
-            concatRef.isEightBits = false;
+            // TODO: We currently set this to true since our messaging app will never
+            // send more than 255 parts (it converts the message to MMS well before that).
+            // However, we should support 3rd party messaging apps that might need 16-bit
+            // references
+            // Note:  It's not sufficient to just flip this bit to true; it will have
+            // ripple effects (several calculations assume 8-bit ref).
+            concatRef.isEightBits = true;
             SmsHeader smsHeader = new SmsHeader();
             smsHeader.concatRef = concatRef;
 
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -188,7 +188,7 @@
 		return this.APPLICATION_DATA_FOLDER;
 	}
 	/**
-	 * With an '/' at the end
+	 * With an '/'
 	 * @return
 	 */
 	public String getApplicationDataFolderAbsolutePath(){
---------------
-------------
@@ -51,6 +51,7 @@
             // group and setuid/gid are ignored, no way to do them fast. Should we fall back on slow?
             if (!setPermissions(file, other, false)) return -1;
             if (!setPermissions(file, user, true)) return -1;
+            return 0;
         } else {
             // slow version
             try {
---------------
-------------
@@ -350,7 +350,7 @@
             try {
                 if (getConnection() != null) {
                     String collation = ExecutorService.getInstance().getExecutor(this).queryForObject(new RawSqlStatement("SELECT CONVERT(varchar(100), SERVERPROPERTY('COLLATION'))"), String.class);
-                    caseSensitive = collation.contains("_CI_");
+                    caseSensitive = ! collation.contains("_CI_");
                 }
             } catch (Exception e) {
                 LogFactory.getLogger().warning("Cannot determine case sensitivity from MSSQL", e);
---------------
-------------
@@ -346,7 +346,7 @@
             try {
                 if (getConnection() != null) {
                     String collation = ExecutorService.getInstance().getExecutor(this).queryForObject(new RawSqlStatement("SELECT CONVERT(varchar(100), SERVERPROPERTY('COLLATION'))"), String.class);
-                    caseSensitive = collation.contains("_CI_");
+                    caseSensitive = ! collation.contains("_CI_");
                 }
             } catch (Exception e) {
                 LogFactory.getLogger().warning("Cannot determine case sensitivity from MSSQL", e);
---------------
-------------
@@ -138,7 +138,6 @@
     }
 
     downloadPercent = (int) ((1 - ((double) blocksLeft / startingBlock)) * 100);
-
   }
 }
 
---------------
-------------
@@ -281,7 +281,7 @@
 
 		String encodingOption = "";
 		if (encoding != null)
-			encoding = " encoding=" + encoding;
+			encodingOption = " encoding=" + encoding;
 
 		String partitionOption = "";
 		if (usePartition)
---------------
-------------
@@ -70,7 +70,7 @@
 		int p = QueryTokenizer.findKeyword(s, AS);
 		if (p > 0) {
 			funcPart = s.substring(0, p).trim();
-			alias = s.substring(p + AS.length());
+			alias = s.substring(p + AS.length()).trim();
 		}
 
 		// find aggregation function
---------------
-------------
@@ -76,7 +76,7 @@
 		//	throw new QueryParseException("missing-parameter", r.next);
 			throw new QueryParseException("21000", getCommandName().length() + 1, commandString.length() - 1, null);
 		
-		if (QueryTokenizer.findKeyword(remainder, "as") == -1) {
+		if (QueryTokenizer.tokenize(remainder).size() == 1) {
 			return newParserFromRegistry(overlay, remainder);
 		}
 		
---------------
-------------
@@ -271,7 +271,7 @@
 
 	@Override
 	public String toString() {
-		String overwriteOption = " ";
+		String overwriteOption = "";
 		if (overwrite)
 			overwriteOption = " overwrite=t ";
 
---------------
-------------
@@ -134,6 +134,6 @@
 
 	@Override
 	public String toString() {
-		return "parseKv field=" + field + " overlay=" + overlay + " pairdelim=\"" + pairDelim + "\" kvdelim=\"" + kvDelim + "\"";
+		return "parsekv field=" + field + " overlay=" + overlay + " pairdelim=\"" + pairDelim + "\" kvdelim=\"" + kvDelim + "\"";
 	}
 }
---------------
-------------
@@ -29,7 +29,7 @@
 
 		if (rhs instanceof StringConstant) {
 			String needle = (String) rhs.eval(null);
-			p = tryBuildPattern(needle);
+			p = tryBuildPattern2(needle);
 		}
 	}
 
---------------
-------------
@@ -102,7 +102,10 @@
         // The casts are to make sure we don't call replace(String regex, String replacement)
         output = output.replace((CharSequence) currencySymbol, (CharSequence) "");
 
-        // Step 3: replace parentheses with negation
+        // Step 3: trim whitespace that might precede or follow currency symbol
+        output = output.trim();
+
+        // Step 4: replace parentheses with negation
         if (output.startsWith("(") && output.endsWith(")")) {
             output = "-" + output.substring(1, output.length() - 1);
         }
---------------
-------------
@@ -13,8 +13,6 @@
 import org.apache.commons.io.FileUtils;
 import org.json.JSONArray;
 import org.oscim.android.MapView;
-import org.oscim.map.Map;
-import org.oscim.map.TestMap;
 import org.robolectric.shadows.ShadowLocationManager;
 import org.robolectric.tester.android.view.TestMenu;
 
---------------
-------------
@@ -324,8 +324,7 @@
     }
 
     public void onLocationChanged(Location location) {
-        // This is for demo purposes
-        if (!shouldAdvancePagerAutomatically()) {
+        if (!shouldAdvancePagerAutomatically() || isReRouting) {
             return;
         }
         Location correctedLocation = snapTo(location);
---------------
-------------
@@ -4,7 +4,6 @@
 import com.mapzen.entity.SimpleFeature;
 import com.mapzen.search.OnPoiClickListener;
 import com.mapzen.util.IntentReceiver;
-import com.mapzen.util.Logger;
 import com.mapzen.util.MapzenTheme;
 import com.mapzen.util.PoiLayer;
 
---------------
-------------
@@ -3,7 +3,7 @@
 import android.content.Context;
 import android.util.AttributeSet;
 import android.widget.TextView;
-import com.mapzen.geo.DistanceFormatter;
+import com.mapzen.helpers.DistanceFormatter;
 
 public class DistanceView extends TextView {
     private int distance;
---------------
-------------
@@ -152,7 +152,7 @@
 
     private void showDirectionListFragment() {
         final Fragment fragment = DirectionListFragment.newInstance(instructions, this);
-        getActivity().getSupportFragmentManager().beginTransaction()
+        act.getSupportFragmentManager().beginTransaction()
                 .add(R.id.full_list, fragment, DirectionListFragment.TAG)
                 .addToBackStack(null)
                 .commit();
---------------
-------------
@@ -9,6 +9,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.Button;
+import android.widget.FrameLayout;
 import android.widget.Toast;
 
 import com.android.volley.Response;
---------------
-------------
@@ -51,7 +51,7 @@
      */
     public static Style addStyle(Style s){
         if (styles.contains(s)) styles.remove(s);
-        else styles.add(s);
+        styles.add(s);
         return s;
     }
 
---------------
-------------
@@ -43,7 +43,7 @@
         while (start < size) {
             long objNumber = (start + offset) / stripeSize;
             int osdOffset = (int) (objNumber % osdCount);
-            int reqOffset = (int) (start + offset) % stripeSize;
+            int reqOffset = (int) ((start + offset) % stripeSize);
             int reqSize = Math.min(size - start, stripeSize - reqOffset);
             
             operations.add(new ReadOperation(objNumber, osdOffset, reqSize, reqOffset, start));
---------------
-------------
@@ -102,7 +102,7 @@
     public static final String KEYTRANSPORT_RSAOEP = 
         "http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p";
     public static final String KEYTRANSPORT_RSAOEP_XENC11 =
-            "http://www.w3.org/2009/xmlenc11#rsa-oaep";
+        "http://www.w3.org/2009/xmlenc11#rsa-oaep";
     public static final String TRIPLE_DES = 
         "http://www.w3.org/2001/04/xmlenc#tripledes-cbc";
     public static final String AES_128 = 
---------------
-------------
@@ -1,6 +1,6 @@
 //
 //  ========================================================================
-//  Copyright (c) 1995-2014 Mort Bay Consulting Pty. Ltd.
+//  Copyright (c) 1995-2015 Mort Bay Consulting Pty. Ltd.
 //  ------------------------------------------------------------------------
 //  All rights reserved. This program and the accompanying materials
 //  are made available under the terms of the Eclipse Public License v1.0
---------------
-------------
@@ -152,7 +152,7 @@
                     HttpField field = fields.getField(i);
                     String name = field.getName();
                     String value = field.getValue();
-                    headers.put(name, value);
+                    headers.add(name, value);
                     LOG.debug("HTTP < {}: {}", name, value);
                 }
             }
---------------
-------------
@@ -258,6 +258,8 @@
         if (value == null || "-".equals(value))
         {
             executor = (Executor)getServletContext().getAttribute("org.eclipse.jetty.server.Executor");
+            if (executor==null)
+                throw new IllegalStateException("No server executor for proxy");
         }
         else
         {
---------------
-------------
@@ -22,8 +22,6 @@
 {
     public static void main(String[] args) throws Exception
     {
-        String jetty_home = System.getProperty("jetty.home","../jetty-distribution/target/distribution");
-
         Server server = new Server();
 
         Connector connector = new SelectChannelConnector();
---------------
-------------
@@ -149,7 +149,7 @@
                     bbuf.position(buffer.putIndex());
                     len=_channel.read(bbuf);
                     if (len<0)
-                        close();
+                        _channel.close();  // Don't call this.close() as that may recurse in SSL land and call fill again
                 }
                 finally
                 {
---------------
-------------
@@ -107,7 +107,7 @@
     @Override
     public Resource addPath(String apath) throws IOException, MalformedURLException
     {
-        return new PathResource(this.path.resolve(apath));
+        return new PathResource(this.path.getFileSystem().getPath(path.toString(), apath));
     }
 
     @Override
---------------
-------------
@@ -301,6 +301,9 @@
         if (decoder != null)
         {
             buffer = decoder.decode(buffer);
+            
+            // TODO If the decoder consumes all the content, should we return here?
+            
             if (LOG.isDebugEnabled())
                 LOG.debug("Response content decoded ({}) {}{}{}", decoder, response, System.lineSeparator(), BufferUtil.toDetailString(buffer));
         }
---------------
-------------
@@ -437,7 +437,9 @@
 
     /* ------------------------------------------------------------ */
     public void setStoreDirectory (File dir) throws IOException
-    {
+    { 
+        // CanonicalFile is used to capture the base store directory in a way that will
+        // work on Windows.  Case differences may through off later checks using this directory.
         _storeDir=dir.getCanonicalFile();
     }
 
---------------
-------------
@@ -1,15 +1,20 @@
-//========================================================================
-//Copyright 2012 Mort Bay Consulting Pty. Ltd.
-//------------------------------------------------------------------------
-//All rights reserved. This program and the accompanying materials
-//are made available under the terms of the Eclipse Public License v1.0
-//and Apache License v2.0 which accompanies this distribution.
-//The Eclipse Public License is available at
-//http://www.eclipse.org/legal/epl-v10.html
-//The Apache License v2.0 is available at
-//http://www.opensource.org/licenses/apache2.0.php
-//You may elect to redistribute this code under either of these licenses.
-//========================================================================
+//
+//  ========================================================================
+//  Copyright (c) 1995-2012 Mort Bay Consulting Pty. Ltd.
+//  ------------------------------------------------------------------------
+//  All rights reserved. This program and the accompanying materials
+//  are made available under the terms of the Eclipse Public License v1.0
+//  and Apache License v2.0 which accompanies this distribution.
+//
+//      The Eclipse Public License is available at
+//      http://www.eclipse.org/legal/epl-v10.html
+//
+//      The Apache License v2.0 is available at
+//      http://www.opensource.org/licenses/apache2.0.php
+//
+//  You may elect to redistribute this code under either of these licenses.
+// ========================================================================
+//
 package org.eclipse.jetty.plugins.util;
 
 import java.io.File;
---------------
-------------
@@ -1,18 +1,15 @@
-/*
- * Copyright (c) 2012 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+// ========================================================================
+// Copyright 2012-2012 Mort Bay Consulting Pty. Ltd.
+// ------------------------------------------------------------------------
+// All rights reserved. This program and the accompanying materials
+// are made available under the terms of the Eclipse Public License v1.0
+// and Apache License v2.0 which accompanies this distribution.
+// The Eclipse Public License is available at
+// http://www.eclipse.org/legal/epl-v10.html
+// The Apache License v2.0 is available at
+// http://www.opensource.org/licenses/apache2.0.php
+// You may elect to redistribute this code under either of these licenses.
+// ========================================================================
 
 package org.eclipse.jetty.spdy;
 
---------------
-------------
@@ -78,7 +78,7 @@
                     }
 
                     // Generate output
-                    if (_generator.isCommitted() && !_generator.isComplete())
+                    while (_generator.isCommitted() && !_generator.isComplete())
                     {
                         if (_generator.flushBuffer()>0)
                         {
---------------
-------------
@@ -53,7 +53,6 @@
 import org.eclipse.jetty.server.AbstractHttpConnection;
 import org.eclipse.jetty.server.Dispatcher;
 import org.eclipse.jetty.server.AbstractHttpConnection;
-import org.eclipse.jetty.server.DispatcherType;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServletRequestHttpWrapper;
---------------
-------------
@@ -35,7 +35,7 @@
     /**
      * Sends a request with an associated response listener.
      * <p />
-     * {@link Request#send(Response.Listener)} will eventually call this method to send the request.
+     * {@link Request#send(Response.CompleteListener)} will eventually call this method to send the request.
      * It is exposed to allow applications to send requests via unpooled connections.
      *
      * @param request the request to send
---------------
-------------
@@ -826,7 +826,7 @@
         if (value != null && value.length() > 0)
             QuotedStringTokenizer.quoteIfNeeded(buf, value, delim);
 
-        if (version!=0)
+        if (version>0)
             buf.append(";Version=").append(version);
 
         if (path != null && path.length() > 0)
---------------
-------------
@@ -626,6 +626,7 @@
             throw new IllegalArgumentException("Could not locate permission for deletion");
 
         upload.getPermissions().remove(toDelete);
+        DAOFactory.getPermissionDAO().delete(toDelete);
         return dao.update(upload) != null;
     }
 }
---------------
-------------
@@ -49,8 +49,8 @@
 	 */
 	private byte[] downloadedFile;
 
-	/** Make seperator os dependant **/
-	private final String separator = File.separator;
+//	/** Make separator os dependant **/
+	private final String separator = "/";
 
 	/** URL to the repository. */
 	private String davUrl;
---------------
-------------
@@ -224,6 +224,7 @@
 		Local local = report.findOrCreateLocal(localIp);
 		Remote remote = local.findOrCreateRemote(remoteIp);
 
+		report.addIp(localIp);
 		remote.setRole(role);
 		remote.setApp(info.getApp());
 
---------------
-------------
@@ -21,7 +21,7 @@
 
 public abstract class BaseCompositeModelService<T> extends ModelServiceWithCalSupport implements ModelService<T>,
       Initializable {
-	private static ExecutorService s_threadPool = Threads.forPool().getFixedThreadPool("Cat-ModelService", 50);
+	private static ExecutorService s_threadPool = Threads.forPool().getFixedThreadPool("Cat-ModelService", 100);
 
 	// introduce another list is due to a bug inside Plexus ComponentList
 	private List<ModelService<T>> m_allServices = new ArrayList<ModelService<T>>();
---------------
-------------
@@ -50,6 +50,7 @@
 			ModelResponse<MetricReport> response = m_service.invoke(request);
 			MetricReport report = response.getModel();
 
+			System.out.println(report);
 			return report;
 		} else {
 			throw new RuntimeException("Internal error: no eligable metric service registered for " + request + "!");
---------------
-------------
@@ -297,7 +297,7 @@
 				else {
 					waiter = new JavaModelEventWaiter(TESTING_PLUGIN_PROJECT_NAME, IJavaElementDelta.REMOVED, 0, IJavaElement.JAVA_PROJECT);
 				}
-				pro.delete(true, true, monitor);
+				deleteResource(pro);
 				Object obj = waiter.waitForEvent();
 				assertNotNull("the project delete event did not arrive", obj);
 			}
---------------
-------------
@@ -60,7 +60,7 @@
     fileCoverageRegistry = Maps.newHashMap();
 
     try {
-      cursor = cursor.childElementCursor().advance().childElementCursor();
+      cursor = cursor.childElementCursor("Modules").advance().childElementCursor();
       while (cursor.getNext() != null) {
         SMInputCursor moduleChildrenCursor = cursor.childElementCursor();
         while (moduleChildrenCursor.getNext() != null) {
---------------
-------------
@@ -29,7 +29,7 @@
   public static final String LANGUAGE_NAME = "C#";
 
   public static final String FILE_SUFFIXES_KEY = "sonar.csharp.file.suffixes";
-  public static final String FILE_SUFFIXES_DEFVALUE = "cs";
+  public static final String FILE_SUFFIXES_DEFVALUE = ".cs";
 
   public static final String CSHARP_WAY_PROFILE = "Sonar way";
 
---------------
-------------
@@ -291,7 +291,7 @@
         .is(g.unaryExpression,
             or(EQUAL, ADD_ASSIGN, SUB_ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, AND_ASSIGN, OR_ASSIGN, XOR_ASSIGN, LEFT_ASSIGN,
                 RIGHT_ASSIGN), g.expression);
-    g.expression.isOr(g.conditionalExpression, g.assignment);
+    g.expression.isOr(g.assignment, g.conditionalExpression);
     g.constantExpression.is(g.expression);
     g.booleanExpression.is(g.expression);
   }
---------------
-------------
@@ -147,7 +147,7 @@
     }
     
     private void setSessionIdCookie( Response response, Request request, final String sessionId ) {
-        _logger.fine( "Response is committed: " + response.isCommitted() + ", closed: " + response.isClosed() );
+        //_logger.fine( "Response is committed: " + response.isCommitted() + ", closed: " + response.isClosed() );
         final Cookie newCookie = new Cookie( JSESSIONID, sessionId );
          newCookie.setMaxAge( -1 );
          newCookie.setPath( request.getContextPath() );
---------------
-------------
@@ -192,7 +192,7 @@
         @Override
         public void run() {
             try {
-                long index = readIndex(socket);
+                long index = readIndex(socket) + 1; //Catch-up up to the first index that the remote sink doesn't have (last known remote index + 1)
                 ExcerptTailer excerpt = chronicle.createTailer();
                 ByteBuffer bb = TcpUtil.createBuffer(1, ByteOrder.nativeOrder()); // minimum size
                 long sendInSync = 0;
---------------
-------------
@@ -118,6 +118,8 @@
       StreamTokenizer tokenizer = new StreamTokenizer(reader);
       // Treat a dash as an ordinary character so it gets included in the token
       tokenizer.ordinaryChar('-');
+      tokenizer.ordinaryChar('.');
+      tokenizer.ordinaryChars('0', '9');
       // Treat all characters as word characters so nothing is parsed out
       tokenizer.wordChars('\u0000','\uFFFF');
 
---------------
-------------
@@ -61,7 +61,7 @@
   // public HadoopShim HadoopConfiguration#getHadoopShim()
   private Method getHadoopShim;
 
-  protected ClassLoader findBigDataPluginClassLoader() throws Exception {
+  ClassLoader findBigDataPluginClassLoader() throws Exception {
     Method findPluginById = null;
     Object pluginRegistry = null;
     Method getClassLoader = null;
---------------
-------------
@@ -246,7 +246,7 @@
       getInstance().getProvider();
     } catch ( ConfigurationException e ) {
       throw new LifecycleException( BaseMessages.getString( PKG,
-          "HadoopConfigurationBootstrap.HadoopConfiguration.StartupError" ), e, true );
+          "HadoopConfigurationBootstrap.HadoopConfiguration.StartupError" ), e, false );
     }
   }
 
---------------
-------------
@@ -61,7 +61,7 @@
   // public HadoopShim HadoopConfiguration#getHadoopShim()
   private Method getHadoopShim;
 
-  protected ClassLoader findBigDataPluginClassLoader() throws Exception {
+  ClassLoader findBigDataPluginClassLoader() throws Exception {
     Method findPluginById = null;
     Object pluginRegistry = null;
     Method getClassLoader = null;
---------------
-------------
@@ -67,7 +67,7 @@
    * @return {@code true} if the class should be ignored by this class loader
    */
   protected boolean ignoreClass(String name) {
-    if (loadClassesFromParent.contains(name)) {
+    if (name == null || loadClassesFromParent.contains(name)) {
       return true;
     }
     for (String prefix : loadClassesFromParent) {
---------------
-------------
@@ -38,6 +38,6 @@
 
   @Override
   public byte[] convert(ValueMetaInterface meta, BytesWritable obj) throws TypeConversionException {
-    return obj.getBytes();
+    return obj.getBytes().clone();
   }
 }
---------------
-------------
@@ -341,7 +341,7 @@
 
     @Override
     public boolean isEnabled() {
-      return true;
+      return repositoryManager != null;
     }
 
     @Override
---------------
-------------
@@ -3181,7 +3181,7 @@
        */
       @Deprecated
       public void setInitialRetryWaitTime(Long initialRetryWaitTime) {
-         testImmutability("initialWaitTime");
+         testImmutability("initialRetryWaitTime");
          this.initialRetryWaitTime = initialRetryWaitTime;
       }
 
---------------
-------------
@@ -560,7 +560,7 @@
    @Override
    protected void purgeInternal() throws CacheLoaderException {
       try {
-         Map<Long, Object> expired = expiryMap.tailMap(System.currentTimeMillis(), true);
+         Map<Long, Object> expired = expiryMap.headMap(System.currentTimeMillis(), true);
          for (Map.Entry<Long, Object> entry : expired.entrySet()) {
             expiryMap.remove(entry.getKey());
             cacheMap.remove(entry.getValue());
---------------
-------------
@@ -75,7 +75,7 @@
                   .groupers(config.clustering().hash().groups().groupers());
       }
 
-      if (config.clustering().l1().activated) {
+      if (config.clustering().l1().activated && config.clustering().l1().enabled()) {
          legacy.clustering()
             .l1()
                .invalidationThreshold(config.clustering().l1().invalidationThreshold())
---------------
-------------
@@ -146,7 +146,7 @@
       cfg.setL1CacheEnabled(false);
       cfg.setWriteSkewCheck(false);
       cfg.setInvocationBatchingEnabled(true);
-      return TestCacheManagerFactory.createCacheManager(globalConfiguration, cfg, true);
+      return TestCacheManagerFactory.createCacheManager(globalConfiguration, cfg);
    }
    
    public static void initializeDirectory(Directory directory) throws IOException {
---------------
-------------
@@ -36,7 +36,7 @@
 
     @Override
     public int hashCode() {
-        return value.length;
+        return Arrays.hashCode(value);
     }
 
     @Override
---------------
-------------
@@ -75,6 +75,8 @@
                 messages.remove(0);
             }
 
+            sendMessage(msg);
+
             Message message = messageEnvelope.getMessage();
             message.setReply();
             msg.setMessageObject(message);
---------------
-------------
@@ -85,7 +85,7 @@
                                              + name + " does not exist.");
         }
 
-        return Double.parseDouble(name);
+        return Double.parseDouble(option);
     }
 
     public double getDoubleOption(String name, double defaultValue)
---------------
-------------
@@ -167,6 +167,7 @@
                 allocate(length - _allocated);
             } else if (_allocated > length) {
                 _monitor.freeSpace(_allocated - length);
+                _allocated = length;
             }
             _entry.setSize(length);
         } catch (InterruptedException e) {
---------------
-------------
@@ -161,7 +161,6 @@
         } finally {
             this.storage.unlock();
         }
-        
     }
 
     /**
---------------
-------------
@@ -89,7 +89,7 @@
         try {
             number = Integer.toString(
                 1 + this.storage.xml().xpath(
-                    String.format("%s/gist/id", this.xpath())
+                    String.format("%s/gist/id/text()", this.xpath())
                 ).size()
             );
             final Directives dirs = new Directives().xpath(this.xpath())
---------------
-------------
@@ -174,7 +174,7 @@
         }
         /**
          * Get its decoded content.
-         * @return decoded content
+         * @return Decoded content
          * @throws IOException If there is any I/O problem
          */
         @NotNull(message = "decoded is never NULL")
---------------
-------------
@@ -258,7 +258,7 @@
          * Get comments count.
          * @return Count of comments
          * @throws IOException If there is any I/O problem
-         * @since 1.0.1
+         * @since 0.8
          */
         public int comments() throws IOException {
             return new SmartJson(this).number("comments");
---------------
-------------
@@ -89,7 +89,7 @@
         try {
             number = Integer.toString(
                 1 + this.storage.xml().xpath(
-                    String.format("%s/gist/id", this.xpath())
+                    String.format("%s/gist/id/text()", this.xpath())
                 ).size()
             );
             final Directives dirs = new Directives().xpath(this.xpath())
---------------
-------------
@@ -42,7 +42,7 @@
  * files.
  * Transformation file should be in conf/validator folder and have a naming schema like
  * /conf/validator/TYPE-upgrade-FROMVERSION.xslt
- * /conf/validator/things-upgrade-5.4.0.xslt"
+ * /conf/validator/things-upgrade-5.5.0.xslt"
  *
  * @author matteo
  */
---------------
-------------
@@ -722,7 +722,7 @@
       List<String> tableListByCluster = tableListByCluster(_cluster);
       List<String> writableTables = new ArrayList<String>();
       for (String table :tableListByCluster) {
-        if (_clusterStatus.isReadOnly(true, _cluster, table)) {
+        if (!_clusterStatus.isReadOnly(true, _cluster, table)) {
           writableTables.add(table);
         }
       }
---------------
-------------
@@ -675,7 +675,6 @@
         {
             if (!hasIndexes && !new Bounds<>(sstable.first.token, sstable.last.token).intersects(ranges))
             {
-                cfs.getDataTracker().replaceReaders(Arrays.asList(sstable), Collections.<SSTableReader>emptyList());
                 cfs.getDataTracker().markCompactedSSTablesReplaced(Arrays.asList(sstable), Collections.<SSTableReader>emptyList(), OperationType.CLEANUP);
                 continue;
             }
---------------
-------------
@@ -367,7 +367,7 @@
 
     public ColumnStats getColumnStats()
     {
-        long maxTimestampSeen = Long.MIN_VALUE;
+        long maxTimestampSeen = getMarkedForDeleteAt();
         StreamingHistogram tombstones = new StreamingHistogram(SSTable.TOMBSTONE_HISTOGRAM_BIN_SIZE);
 
         for (IColumn column : columns)
---------------
-------------
@@ -35,7 +35,7 @@
 
     public static final ISerializer<DeletionTime> serializer = new Serializer();
 
-    DeletionTime(long markedForDeleteAt, int localDeletionTime)
+    public DeletionTime(long markedForDeleteAt, int localDeletionTime)
     {
         this.markedForDeleteAt = markedForDeleteAt;
         this.localDeletionTime = localDeletionTime;
---------------
-------------
@@ -95,7 +95,7 @@
         return udpAddr_;
     }
 
-    public static IPartitioner getPartitioner() {
+    public static IPartitioner<?> getPartitioner() {
         return partitioner_;
     }
 
---------------
-------------
@@ -1308,7 +1308,7 @@
         return executor.submit(runnable);
     }
 
-    static int getDefaultGcBefore(ColumnFamilyStore cfs)
+    public static int getDefaultGcBefore(ColumnFamilyStore cfs)
     {
         // 2ndary indexes have ExpiringColumns too, so we need to purge tombstones deleted before now. We do not need to
         // add any GcGrace however since 2ndary indexes are local to a node.
---------------
-------------
@@ -302,7 +302,7 @@
      *
      * @param cfs
      * @param ranges Ranges that the repair was carried out on
-     * @param validatedForRepair SSTables containing the repaired ranges
+     * @param validatedForRepair SSTables containing the repaired ranges. Should be referenced before passing them.
      * @throws InterruptedException, ExecutionException, IOException
      */
     public void performAnticompaction(ColumnFamilyStore cfs,
---------------
-------------
@@ -272,7 +272,7 @@
 
     public long maxTimestamp()
     {
-        long maxTimestamp = Long.MIN_VALUE;
+        long maxTimestamp = getMarkedForDeleteAt();
         for (IColumn column : columns)
             maxTimestamp = Math.max(maxTimestamp, column.maxTimestamp());
         return maxTimestamp;
---------------
-------------
@@ -378,7 +378,7 @@
         submitUserDefined(cfs, descriptors, getDefaultGcBefore(cfs));
     }
 
-    private Future<Object> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
+    Future<Object> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
     {
         Callable<Object> callable = new Callable<Object>()
         {
---------------
-------------
@@ -587,7 +587,7 @@
     {
         return metadata.cfType == ColumnFamilyType.Standard
                ? Column.serializer()
-               : SuperColumn.serializer(getColumnComparator());
+               : SuperColumn.serializer(metadata.subcolumnComparator);
     }
 
     /**
---------------
-------------
@@ -468,7 +468,7 @@
             return;
 
         IndexClause clause = new IndexClause();
-        String columnFamily = statement.getChild(0).getText();
+        String columnFamily = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
         // ^(CONDITIONS ^(CONDITION $column $value) ...)
         Tree conditions = statement.getChild(1);
         
---------------
-------------
@@ -376,7 +376,7 @@
         ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));
         int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);
         CfDef cfDef = getCfDef(columnFamily);
-        boolean isSuper = cfDef.comparator_type.equals("Super");
+        boolean isSuper = cfDef.column_type.equals("Super");
         
         byte[] superColumnName = null;
         ByteBuffer columnName;
---------------
-------------
@@ -58,7 +58,6 @@
 
         public Builder(ColumnFamily cf,
                        ByteBuffer key,
-                       DataOutput output)
                        DataOutput output,
                        boolean fromStream)
         {
---------------
-------------
@@ -199,6 +199,7 @@
         {
             int startIndex = (int) (section.left / parameters.chunkLength());
             int endIndex = (int) (section.right / parameters.chunkLength());
+            endIndex = section.right % parameters.chunkLength() == 0 ? endIndex - 1 : endIndex;
             for (int i = startIndex; i <= endIndex; i++)
             {
                 long offset = i * 8;
---------------
-------------
@@ -70,7 +70,6 @@
             } catch (IOException e) {
             }
         }
-
     }
 
     private void readData(ArrayNode data) {
---------------
-------------
@@ -35,7 +35,7 @@
 
     @Mappings({
         @Mapping(source = "FOO", target = "SPECIAL"),
-        @Mapping(source = "EXTRA", target = "BAR"),
+        @Mapping(source = "EXTRA", target = "BAR")
     })
     ExternalOrderType orderTypeToExternalOrderType(OrderType orderType);
 }
---------------
-------------
@@ -129,6 +129,8 @@
 
             mvnScript = findMaven2Script(Util.isWindows());
             LOG.debug("Using mvnHome: " + mvnHome + ", mvnScript found and set to: " + mvnScript);
+            LOG.debug("Clearing mvnHome after finding mvnScript for builder instance reuse");
+            mvnHome = null;
         }
         ValidationHelper.assertTrue(mvnScript != null, "'mvnhome' or 'mvnscript' must be set.");
 
---------------
-------------
@@ -110,7 +110,7 @@
         commandLine.createArgument().setValue("update");
         commandLine.createArgument().setValue("-force");
         commandLine.createArgument().setValue("-log");
-        commandLine.createArgument().setValue(isWindows() ? "NUL" : "/dev/nul");
+        commandLine.createArgument().setValue(isWindows() ? "NUL" : "/dev/null");
         commandLine.createArgument().setValue(getFullPathFileName());
 
         return commandLine;
---------------
-------------
@@ -348,6 +348,7 @@
     public void getStateFromOldProject(ProjectInterface oldProject) throws CruiseControlException {
         ProjectConfig oldProjectConfig = (ProjectConfig) oldProject;
         project = oldProjectConfig.project;
+        project.setProjectConfig(this);
         project.init();
     }
 
---------------
-------------
@@ -129,6 +129,8 @@
 
             mvnScript = findMaven2Script(Util.isWindows());
             LOG.debug("Using mvnHome: " + mvnHome + ", mvnScript found and set to: " + mvnScript);
+            LOG.debug("Clearing mvnHome after finding mvnScript for builder instance reuse");
+            mvnHome = null;
         }
         ValidationHelper.assertTrue(mvnScript != null, "'mvnhome' or 'mvnscript' must be set.");
 
---------------
-------------
@@ -348,6 +348,7 @@
     public void getStateFromOldProject(ProjectInterface oldProject) throws CruiseControlException {
         ProjectConfig oldProjectConfig = (ProjectConfig) oldProject;
         project = oldProjectConfig.project;
+        project.setProjectConfig(this);
         project.init();
     }
 
---------------
-------------
@@ -110,7 +110,7 @@
         commandLine.createArgument().setValue("update");
         commandLine.createArgument().setValue("-force");
         commandLine.createArgument().setValue("-log");
-        commandLine.createArgument().setValue(isWindows() ? "NUL" : "/dev/nul");
+        commandLine.createArgument().setValue(isWindows() ? "NUL" : "/dev/null");
         commandLine.createArgument().setValue(getFullPathFileName());
 
         return commandLine;
---------------
-------------
@@ -287,7 +287,7 @@
                 arguments.add("cmd.exe");
                 arguments.add("/C");
             }
-            arguments.add("\"" + antScript + "\"");
+            arguments.add(antScript);
         } else {
             arguments.add("java");
             Iterator argsIterator = args.iterator();
---------------
-------------
@@ -287,7 +287,7 @@
                 arguments.add("cmd.exe");
                 arguments.add("/C");
             }
-            arguments.add("\"" + antScript + "\"");
+            arguments.add(antScript);
         } else {
             arguments.add("java");
             Iterator argsIterator = args.iterator();
---------------
-------------
@@ -166,6 +166,8 @@
                 buildLogElement.setAttribute(ERROR, "BUILD FAILURE detected");
             } else if (infoLine.startsWith("BUILD ERROR")) {
                 buildLogElement.setAttribute(ERROR, "BUILD ERROR detected");
+            } else if (infoLine.startsWith("FATAL ERROR")) {
+                buildLogElement.setAttribute(ERROR, "FATAL ERROR detected");
             /*} else if (line.startsWith("org.apache.maven.MavenException")) {
              buildLogElement.setAttribute("error", "You have encountered an unknown error running Maven: " + line);
              } else if (line.startsWith("The build cannot continue")) {
---------------
-------------
@@ -166,6 +166,8 @@
                 buildLogElement.setAttribute(ERROR, "BUILD FAILURE detected");
             } else if (infoLine.startsWith("BUILD ERROR")) {
                 buildLogElement.setAttribute(ERROR, "BUILD ERROR detected");
+            } else if (infoLine.startsWith("FATAL ERROR")) {
+                buildLogElement.setAttribute(ERROR, "FATAL ERROR detected");
             /*} else if (line.startsWith("org.apache.maven.MavenException")) {
              buildLogElement.setAttribute("error", "You have encountered an unknown error running Maven: " + line);
              } else if (line.startsWith("The build cannot continue")) {
---------------
-------------
@@ -126,6 +126,5 @@
    * multiple calls to this method.
    */
   protected void onDestroy() {
-    if (view != null) dropView(view);
   }
 }
---------------
-------------
@@ -150,7 +150,7 @@
      * </p> 
      * 
      * @parameter
-     * @since 2.5
+     * @since 2.6
      */
     private Map<String, String> issueTypes;
     
---------------
-------------
@@ -32,7 +32,7 @@
     public ArtifactStub( String groupId, String artifactId, String version, String packaging, String scope )
     {
         super( groupId, artifactId, VersionRange.createFromVersion( version ), scope, packaging,
-               null, new DefaultArtifactHandler(), false );
+               null, new DefaultArtifactHandler( packaging ), false );
     }
 
     public File getFile()
---------------
-------------
@@ -531,7 +531,7 @@
             for (String aSplit : split) {
                 String s = aSplit.trim();
                 if (JavadocUtil.equalsIgnoreCase(s, FIX_TAGS_ALL, AUTHOR_TAG, VERSION_TAG, SINCE_TAG, PARAM_TAG,
-                        THROWS_TAG, LINK_TAG)) {
+                        THROWS_TAG, LINK_TAG, RETURN_TAG)) {
                     filtered.add(s);
                 } else {
                     if (getLog().isWarnEnabled()) {
---------------
-------------
@@ -40,7 +40,6 @@
 import org.apache.maven.wagon.Wagon;
 import org.codehaus.plexus.i18n.I18N;
 import org.codehaus.plexus.util.StringUtils;
-import org.codehaus.plexus.util.xml.Xpp3Dom;
 
 import java.io.File;
 import java.io.IOException;
---------------
-------------
@@ -29,7 +29,6 @@
 	FileServiceTest.class,
 	FileDownloadTest.class,
 	FileUpdateTest.class,
-
 })
 public class FileServiceTestSuite {
 
---------------
-------------
@@ -1,5 +1,5 @@
 /*
- * � Copyright IBM Corp. 2013
+ * © Copyright IBM Corp. 2013
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); 
  * you may not use this file except in compliance with the License. 
---------------
-------------
@@ -29,7 +29,6 @@
 	FileServiceTest.class,
 	FileDownloadTest.class,
 	FileUpdateTest.class,
-
 })
 public class FileServiceTestSuite {
 
---------------
-------------
@@ -1,5 +1,5 @@
 /*
- * � Copyright IBM Corp. 2013
+ * © Copyright IBM Corp. 2013
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); 
  * you may not use this file except in compliance with the License. 
---------------
-------------
@@ -2193,7 +2193,7 @@
      */
     public FileList getPublicFiles(Map<String, String> params) throws FileServiceException {
         String accessType = AccessType.PUBLIC.getText();
-        String requestUri = FileUrls.MYFAVORITES_COLLECTIONS_FEED.format(this, FileUrlParts.accessType.get(accessType));
+        String requestUri = FileUrls.GET_PUBLIC_FILES.format(this, FileUrlParts.accessType.get(accessType));
 		params = (null == params)?new HashMap<String, String>():params;
         params.put(FileRequestParams.VISIBILITY.getFileRequestParams(), "public");
 
---------------
-------------
@@ -2193,7 +2193,7 @@
      */
     public FileList getPublicFiles(Map<String, String> params) throws FileServiceException {
         String accessType = AccessType.PUBLIC.getText();
-        String requestUri = FileUrls.MYFAVORITES_COLLECTIONS_FEED.format(this, FileUrlParts.accessType.get(accessType));
+        String requestUri = FileUrls.GET_PUBLIC_FILES.format(this, FileUrlParts.accessType.get(accessType));
 		params = (null == params)?new HashMap<String, String>():params;
         params.put(FileRequestParams.VISIBILITY.getFileRequestParams(), "public");
 
---------------
-------------
@@ -14,7 +14,7 @@
 		if (!directory.exists())
 			directory.mkdirs();
 		this.fileWriter = new BufferedWriter(new FileWriter(
-				subdirectoryName + File.pathSeparator + fileName, true));
+				subdirectoryName + "/" + fileName, true));
 	}	
 	
 	
---------------
-------------
@@ -35,7 +35,7 @@
 	}
 
 	public CsvFile getTestDataWithoutHeader() throws InputIterationException, InputGenerationException {
-		return new CsvFile(getExpectedRelationName(), new StringReader(getCsvInputString()), this.separator, this.quoteChar, 0, false);
+		return new CsvFile(getExpectedRelationName(), new StringReader(getCsvInputString()), this.separator, this.quoteChar, 1, false);
 	}
 	
 	protected String getCsvInputString() {
---------------
-------------
@@ -715,6 +715,8 @@
             client.updateVariable(id, "selected", tabKeys.get(tabIndex)
                     .toString(), true);
             waitingForResponse = true;
+
+            tb.getTab(tabIndex).focus(); // move keyboard focus to active tab
         }
     }
 
---------------
-------------
@@ -715,6 +715,8 @@
             client.updateVariable(id, "selected", tabKeys.get(tabIndex)
                     .toString(), true);
             waitingForResponse = true;
+
+            tb.getTab(tabIndex).focus(); // move keyboard focus to active tab
         }
     }
 
---------------
-------------
@@ -114,6 +114,7 @@
         params.addParam(HighlightParams.SIMPLE_PRE, "<em>");
         params.addParam(HighlightParams.SIMPLE_POST, "</em>");
         params.addParam(HighlightParams.MERGE_CONTIGUOUS_FRAGMENTS, "true");
+        params.addParam(HighlightParams.FIELD_MATCH, "true");
         
         HighlightingFieldParams contentFieldParams = new HighlightingFieldParams(JudgmentIndexField.CONTENT.getFieldName());
         contentFieldParams.addParam(HighlightParams.FRAGSIZE, "200");
---------------
-------------
@@ -29,7 +29,7 @@
 	    	return css;
 	    }
 		StringBuilder sb = new StringBuilder(css);
-		patternRewrite((ReplayParseContext)context, sb,cssUrlPattern, "cs_");
+		patternRewrite((ReplayParseContext)context, sb,cssUrlPattern, "im_");
 		patternRewrite((ReplayParseContext)context, sb,cssImportNoUrlPattern, 
 				"cs_");
 //		return "__BCSS__" + sb.toString() + "__BCSS__";
---------------
-------------
@@ -118,7 +118,7 @@
             if (!ps.isInstanciated())
                 continue;
 
-            if (ConfigurationManagerUtils.isDerivedClass(ps.getClass(), type))
+            if (ConfigurationManagerUtils.isDerivedClass(ps.getConfigurableClass(), type))
                 instanceNames.add(ps.getInstanceName());
         }
 
---------------
-------------
@@ -99,7 +99,7 @@
 
     @Override
     public void allocate() {
-        logger.info("# of scoring threads: " + numThreads);
+        logger.fine("# of scoring threads: " + numThreads);
 
         // if we only have one thread, then we'll score the
         // states in the calling thread and we won't need any
---------------
-------------
@@ -61,7 +61,7 @@
 
 
     public void setBatchFile(File batchFile) {
-        assert batchFile.isFile();
+        assert batchFile.isFile() : "given batch file is not a file";
 
         setBatchUrls(readDriver(batchFile.getAbsolutePath()));
     }
---------------
-------------
@@ -110,7 +110,7 @@
     List<LimitOrder> limitOrders = new ArrayList<LimitOrder>();
 
     for (MtGoxOrder mtGoxOrder : mtGoxOrders) {
-      limitOrders.add(adaptOrder(mtGoxOrder.getAmount(), mtGoxOrder.getPrice(), currency, orderType, id, new Date(mtGoxOrder.getStamp())));
+      limitOrders.add(adaptOrder(mtGoxOrder.getAmount(), mtGoxOrder.getPrice(), currency, orderType, id, new Date(mtGoxOrder.getStamp() / 1000)));
     }
 
     return limitOrders;
---------------
-------------
@@ -89,7 +89,7 @@
         return histogramRollup;
     }
 
-    public int getNumberOfBins() {
+    public int getMaxBins() {
         return histogram.getMaxBins();
     }
 
---------------
-------------
@@ -52,6 +52,8 @@
         DEFAULT_TIMER.add(BasicRollupsOutputSerializer.MetricStat.NUM_POINTS);
         DEFAULT_TIMER.add(BasicRollupsOutputSerializer.MetricStat.AVERAGE);
         
+        DEFAULT_STATS.add(BasicRollupsOutputSerializer.MetricStat.AVERAGE);
+        DEFAULT_STATS.add(BasicRollupsOutputSerializer.MetricStat.NUM_POINTS);
     } 
 
     public static RollupsQueryParams parseParams(Map<String, List<String>> params) throws InvalidRequestException {
---------------
-------------
@@ -103,7 +103,7 @@
             md.withAnnotation(info);
             bulk.add(createSingleRequest(md));
         }
-        bulk.execute();
+        bulk.execute().actionGet();
     }
 
     private IndexRequestBuilder createSingleRequest(Discovery md) throws IOException {
---------------
-------------
@@ -22,7 +22,7 @@
  */
 public class ServiceInfo extends Entity {
     ServiceInfo(Service service) {
-        super(service, "server/info");
+        super(service, "/services/server/info");
     }
 
     /**
---------------
-------------
@@ -22,7 +22,11 @@
  */
 public class ServiceInfo extends Entity {
     ServiceInfo(Service service) {
-        super(service, "server/info");
+        // We have to use an absolute path here, since
+        // server/info returns HTTP code 403 if it is
+        // used with any namespace specifier besides
+        // /services (i.e., don't use of servicesNS).
+        super(service, "/services/server/info");
     }
 
     /**
---------------
-------------
@@ -129,7 +129,6 @@
     }
 
     request.save();
-    fireOnUpdated(request);
     return request;
   }
 
---------------
-------------
@@ -18,7 +18,7 @@
 	}
 	public void add() {
 		Class[] parameters = new Class[]{URL.class};
-		URL functions = getClass().getResource("corefunctions-1.0.1-SNAPSHOT.jar");		
+		URL functions = getClass().getResource("corefunctions-1.0.2-SNAPSHOT.jar");		
 		URLClassLoader sysloader = (URLClassLoader) ClassLoader.getSystemClassLoader();
 	      Class sysclass = URLClassLoader.class;
 
---------------
-------------
@@ -24,7 +24,8 @@
 
 	/**
 	 * Add a cell to the alignment
-	 * @param cell the cell to add
+	 * @param cell the cell to add. It should be already configured,
+	 *   especially with the cell target
 	 * @return <code>true</code> if the cell replaced an existing cell,
 	 *   otherwise <code>false</code> 
 	 */
---------------
-------------
@@ -44,7 +44,7 @@
 		try {
 			Schema schema = asp.loadSchema(new URI(schemaFilename));
 			if (schema != null) {
-				for (TypeDefinition td : schema.getTypes()) {
+				for (TypeDefinition td : schema.getTypes().values()) {
 					if (td.getFeatureType() != null) {
 						if (localname.equals(td.getName().getLocalPart())) {
 							type = td.getFeatureType();
---------------
-------------
@@ -354,7 +354,7 @@
                     ? "startKey"
                     : "afterKey";
             query = query
-                    .concat(keyName)
+                    .concat('&' + keyName + '=')
                     .concat(urlEncoder.encodeURL(kvListOp.getStartKey()));
         }
 
---------------
-------------
@@ -138,7 +138,7 @@
         {
             // Cached! Re-use existing data structures
             int parentNode = parents[to];
-            if (parentNode != EMPTY_PARENT && weights[to] < weights[currNode])
+            if (parentNode != EMPTY_PARENT && weights[to] <= weights[currNode])
                 return to;
 
             if (heap.isEmpty() || visitedNodes >= limitVisitedNodes)
---------------
-------------
@@ -48,7 +48,7 @@
     EdgeExplorer carOutExplorer;
     EdgeExplorer carInExplorer;
     EdgeExplorer carAllExplorer;
-    private GraphStorage graph;
+    protected GraphStorage graph;
 
     protected GraphStorage createGraph()
     {
---------------
-------------
@@ -228,7 +228,7 @@
 
     public String createGPX( String trackName, long startTimeMillis, String timeZoneId )
     {
-        boolean includeElevation = instructions.size() > 0 ? instructions.get(0).getPoints().is3D() : false;
+        boolean includeElevation = getSize() > 0 ? get(0).getPoints().is3D() : false;
         return createGPX(trackName, startTimeMillis, timeZoneId, includeElevation);
     }
 
---------------
-------------
@@ -56,7 +56,7 @@
     {
         if (names.loadExisting())
         {
-            bytePointer = BitUtil.LITTLE.combineIntsToLong(names.getHeader(0), names.getHeader(1));
+            bytePointer = BitUtil.LITTLE.combineIntsToLong(names.getHeader(0), names.getHeader(4));
             return true;
         }
 
---------------
-------------
@@ -360,7 +360,7 @@
 
         int edgeId = origEdgeId - mainEdges;
         EdgeIteratorState eis = virtualEdges.get(edgeId);
-        if (eis.getAdjNode() == adjNode)
+        if (eis.getAdjNode() == adjNode || adjNode == Integer.MIN_VALUE)
             return eis;
 
         // find reverse edge via convention. see virtualEdges comment above
---------------
-------------
@@ -138,7 +138,7 @@
         }
         byte[] sizeBytes = new byte[1];
         names.getBytes(pointer, sizeBytes, 1);
-        int size = sizeBytes[0];
+        int size = sizeBytes[0] & 0xFF;
         byte[] bytes = new byte[size];
         names.getBytes(pointer + sizeBytes.length, bytes, size);
         try
---------------
-------------
@@ -141,7 +141,7 @@
         {
             // Cached! Re-use existing data structures
             int parentNode = parents[to];
-            if (parentNode >= 0 || heap.isEmpty())
+            if (parentNode >= 0 && weights[to] < weights[currNode] || heap.isEmpty())
                 return to;
 
             currNode = heap.poll_element();
---------------
-------------
@@ -307,7 +307,7 @@
             {
                 sbEx.append("<").append(exEntry.getKey()).append(">");
                 sbEx.append(exEntry.getValue());
-                sbEx.append("<").append(exEntry.getKey()).append("/>");
+                sbEx.append("</").append(exEntry.getKey()).append(">");
             }
 
             sbEx.append("</extensions>");
---------------
-------------
@@ -519,7 +519,7 @@
                                 newMap.put( key, evalue );
                             }
 
-
+                            objValue = newMap;
 
                         } else {
                             objValue = fromValueMap( fieldsAccessor, ( Map<String, Value> ) objValue );
---------------
-------------
@@ -50,7 +50,7 @@
   }
 
   String getPrefixPattern() {
-    return "%syslogStart{" + getFacility() + "}%nopex";
+    return "%syslogStart{" + getFacility() + "}%nopex{}";
   }
 
   /*
---------------
-------------
@@ -47,7 +47,7 @@
       return onMismatch;
     } 
     
-    if(markerToMatch.contains(marker)) {
+    if(marker.contains(markerToMatch)) {
       return onMatch;
     } else {
       return onMismatch;
---------------
-------------
@@ -155,6 +155,9 @@
     try {
       blockingQueue.put(eventObject);
     } catch (InterruptedException e) {
+      // Interruption of current thread when in doAppend method should not be consumed
+      // by AsyncAppender
+      Thread.currentThread().interrupt();  	
     }
   }
 
---------------
-------------
@@ -50,7 +50,7 @@
   }
 
   String getPrefixPattern() {
-    return "%syslogStart{" + getFacility() + "}%nopex";
+    return "%syslogStart{" + getFacility() + "}%nopex{}";
   }
 
   /*
---------------
-------------
@@ -46,7 +46,7 @@
 
     AppenderAttachable appenderAttachable = (AppenderAttachable) o;
 
-    String appenderName = attributes.getValue(ActionConst.REF_ATTRIBUTE);
+    String appenderName = ec.subst(attributes.getValue(ActionConst.REF_ATTRIBUTE));
 
     if (OptionHelper.isEmpty(appenderName)) {
       // print a meaningful error message and return
---------------
-------------
@@ -103,7 +103,7 @@
 
         // we have to make sure a buffers capacity is exhausted before reading into the
         // next buffer so we use the method that returns a long
-        long read = this.memoryContents.read(dsts[offset + 1], this.position, Long.MAX_VALUE - totalRead);
+        long read = this.memoryContents.read(dsts[offset + i], this.position, Long.MAX_VALUE - totalRead);
         if (read != -1) {
           // we could read data, update position and total counter
           this.position += read;
---------------
-------------
@@ -66,7 +66,7 @@
 
   void initializeAttributes(MemoryEntry other) throws IOException {
     try (AutoRelease lock = this.writeLock()) {
-      other.getBasicFileAttributeView().initializeFrom(this.getBasicFileAttributeView());
+      this.getBasicFileAttributeView().initializeFrom(other.getBasicFileAttributeView());
       for (InitializingFileAttributeView view : this.additionalAttributes.values()) {
         view.initializeFrom(other.additionalAttributes);
       }
---------------
-------------
@@ -307,7 +307,7 @@
         // Query.MAX_VALUE is a value which should be larger than anything, so cannot be an inclusive upper bound
         // The importance of this is because for Query.MAX_VALUE, we do a prefix scan so the operator should be
         // CompareOp.LESS_OR_EQUAL
-        boolean upperBoundInclusive = rangeCond != null && rangeCond.isUpperBoundInclusive() && rangeCond.getToValue() != Query.MAX_VALUE;
+        boolean upperBoundInclusive = rangeCond != null && (rangeCond.isUpperBoundInclusive() || rangeCond.getToValue() == Query.MAX_VALUE);
         CompareOp op = rangeCondSet && !upperBoundInclusive ? CompareOp.LESS : CompareOp.LESS_OR_EQUAL;
         Filter toFilter = new RowFilter(op, new BinaryPrefixComparator(toKey));
 
---------------
-------------
@@ -713,7 +713,7 @@
     protected ValueReader mapReader(Class<?> contextType, Type mapType)
     {
         ResolvedType t = _typeResolver.resolve(bindings(contextType), mapType);
-        List<ResolvedType> params = t.typeParametersFor(Collection.class);
+        List<ResolvedType> params = t.typeParametersFor(Map.class);
         return mapReader(t.erasedType(), params.get(1));
     }
     
---------------
-------------
@@ -101,7 +101,7 @@
             for (int i = 0; i < len; i++) {
                 Object item = Array.get(obj, i);
                 if (item == null) {
-                    descriptor.setProperty(i++, null);
+                    descriptor.setProperty(i, null);
                 } else {
                     JavaBeanDescriptor itemDescriptor = createDescriptorIfAbsent(item, accessor, cache);
                     descriptor.setProperty(i, itemDescriptor);
---------------
-------------
@@ -37,7 +37,7 @@
  */
 public class TestColumnWidth extends AbstractWebDriverTest {
 
-    @FindByJQuery(".rf-edt-c:first")
+    @FindByJQuery(".rf-edt[id$=richDataTable] .rf-edt-c:first")
     private WebElement firstColumn;
 
     private final Attributes<ColumnAttributes> attributes = getAttributes();
---------------
-------------
@@ -67,7 +67,8 @@
     }
 
     protected String getEAPZipName() {
-        return getVersion().getMicro() > 0 ? getVersion().getFullFormat() + "-full-build" : getVersion().getFullFormat();
+        // version 6.x.y, if x > 1 && y > 0  => *-full-build.zip
+        return getVersion().getMinor() > 1 && getVersion().getMicro() > 0 ? getVersion().getFullFormat() + "-full-build" : getVersion().getFullFormat();
     }
 
     public String getEapExtractedDirectoryName() {
---------------
-------------
@@ -65,7 +65,7 @@
      * request (begin).
      */
     @Test
-    @Use(field = "requestDelay", ints = { 4000, 900, 80 })
+    @Use(field = "requestDelay", ints = { 4000, 900, 150 })
     public void testRequestDelay() {
         attributes.set(QueueAttributes.requestDelay, requestDelay);
 
---------------
-------------
@@ -44,7 +44,7 @@
     public void doStart() throws Exception {
         if (lockFile == null) {
             File lockFileName = new File(directory, "lock");
-            lockFile = new LockFile(lockFileName, true);
+            lockFile = new LockFile(lockFileName, false);
             if (failIfLocked) {
                 lockFile.lock();
             } else {
---------------
-------------
@@ -468,7 +468,7 @@
      * @return
      */
     public boolean isFull() {
-        return isSlave() || dispatched.size() - prefetchExtension >= info.getPrefetchSize();
+        return dispatched.size() - prefetchExtension >= info.getPrefetchSize();
     }
 
     /**
---------------
-------------
@@ -1121,6 +1121,7 @@
                 pageInMessages(!memoryUsage.isFull(110));
             };
 
+            doBrowseList(browseList, max, redeliveredWaitingDispatch, pagedInPendingDispatchLock, connectionContext, "redeliveredWaitingDispatch");
             doBrowseList(browseList, max, pagedInPendingDispatch, pagedInPendingDispatchLock, connectionContext, "pagedInPendingDispatch");
             doBrowseList(browseList, max, pagedInMessages, pagedInMessagesLock, connectionContext, "pagedInMessages");
 
---------------
-------------
@@ -106,7 +106,9 @@
     public void dispatch(VMTransport transport, BlockingQueue<Object> pending, Object command) {
         TransportListener transportListener = transport.getTransportListener();
         if (transportListener != null) {
-            synchronized (started) {
+            // Lock here on the target transport's started since we want to wait for its start()
+            // method to finish dispatching out of the queue before we do our own.
+            synchronized (transport.started) {
 
                 // Ensure that no additional commands entered the queue in the small time window
                 // before the start method locks the dispatch lock and the oneway method was in
---------------
-------------
@@ -396,7 +396,7 @@
                    listener.processExpired();
                } while (!listener.done());
             } else {
-                destinationStatistics.getMessages().setCount(messageCount);
+                destinationStatistics.getMessages().add(messageCount);
             }
         }
     }
---------------
-------------
@@ -131,5 +131,7 @@
         // Give both a chance to clear out their contexts
         this.sslBroker.removeDestination(context, destination, timeout);
         this.nonSslBroker.removeDestination(context, destination, timeout);
+
+        super.removeDestination(context, destination, timeout);
     }
 }
---------------
-------------
@@ -305,7 +305,7 @@
 
     @Override
     protected boolean canDispatch(MessageReference node) {
-        return isActive();
+        return true;  // let them go, our dispatchPending gates the active / inactive state.
     }
 
     @Override
---------------
-------------
@@ -316,7 +316,6 @@
                         inAckRange = true;
                     }
                     if (inAckRange) {
-                        node.incrementRedeliveryCounter();
                         if (ack.getLastMessageId().equals(messageId)) {
                             destination = node.getRegionDestination();
                             callDispatchMatched = true;
---------------
-------------
@@ -48,6 +48,8 @@
         }
 
         started = true;
+
+        accessorPool = new DataFileAccessorPool(this);
                 
         ArrayList<File> files = new ArrayList<File>();
         for (File directory : dirs) {
---------------
-------------
@@ -142,7 +142,7 @@
 
     public void setProperties(Map properties) throws IOException {
         lazyCreateProperties();
-        properties.putAll(properties);
+        this.properties.putAll(properties);
     }
     
     public void setProperty(String name, Object value) throws IOException {
---------------
-------------
@@ -282,7 +282,7 @@
     public Enumeration getPropertyNames() throws JMSException {
         try {
             Vector<String> result = new Vector<String>(this.getProperties().keySet());
-            result.addAll(new Vector<String>(JMS_PROPERTY_SETERS.keySet()));
+            // omit stand jms props are per spec
             return result.elements();
         } catch (IOException e) {
             throw JMSExceptionSupport.create(e);
---------------
-------------
@@ -922,6 +922,7 @@
         message.setBrokerPath(appendToBrokerPath(message.getBrokerPath(), localBrokerPath));
         message.setProducerId(producerInfo.getProducerId());
         message.setDestination(md.getDestination());
+        message.setMemoryUsage(null);
         if (message.getOriginalTransactionId() == null) {
             message.setOriginalTransactionId(message.getTransactionId());
         }
---------------
-------------
@@ -427,6 +427,8 @@
                             dispatched.remove(node);
                             node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
                         }
+                        node.getRegionDestination().wakeup();
+                        dispatchPending();
                     }
 
                     @Override
---------------
-------------
@@ -131,7 +131,7 @@
     public void serviceFailed(DiscoveryEvent devent) throws IOException {
 
         final SimpleDiscoveryEvent sevent = (SimpleDiscoveryEvent)devent;
-        if (sevent.failed.compareAndSet(false, true)) {
+        if (running.get() && sevent.failed.compareAndSet(false, true)) {
 
             listener.onServiceRemove(sevent);
             taskRunner.execute(new Runnable() {
---------------
-------------
@@ -1,3 +1,19 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.activemq.util;
 
 import java.net.InetAddress;
---------------
-------------
@@ -55,7 +55,6 @@
                     try {
                         lockFile.lock();
                         locked = keepAlive();
-                        LOG.info("locked " + locked);
                         break;
                     } catch (IOException e) {
                         if (!warned)
---------------
-------------
@@ -195,7 +195,7 @@
             destinationsLock.readLock().unlock();
         }
 
-        if (subscriptions.get(sub.getConsumerInfo()) != null) {
+        if (subscriptions.get(sub.getConsumerInfo().getConsumerId()) != null) {
             super.removeConsumer(context, sub.getConsumerInfo());
         } else {
             // try destroying inactive subscriptions
---------------
-------------
@@ -59,7 +59,7 @@
 
     }
 
-    static final private ArrayList<Command> pendingCommands = new ArrayList<Command>();
+    final private ArrayList<Command> pendingCommands = new ArrayList<Command>();
 
     public AMQPProtocolDiscriminator(AmqpTransport transport) {
         this.transport = transport;
---------------
-------------
@@ -77,7 +77,7 @@
         super(broker, context, info);
         this.usageManager = usageManager;
         String matchedName = "TopicSubscription:" + CURSOR_NAME_COUNTER.getAndIncrement() + "[" + info.getConsumerId().toString() + "]";
-        if (info.getDestination().isTemporary() || broker == null || broker.getTempDataStore()==null ) {
+        if (info.getDestination().isTemporary() || broker.getTempDataStore()==null ) {
             this.matched = new VMPendingMessageCursor(false);
         } else {
             this.matched = new FilePendingMessageCursor(broker,matchedName,false);
---------------
-------------
@@ -86,7 +86,7 @@
         // just in case let only one thread send at once
         synchronized (messageProducer) {
 
-            if (anonymous && !this.destination.equals(destination)) {
+            if (anonymous && this.destination != null && !this.destination.equals(destination)) {
                 throw new UnsupportedOperationException("This producer can only send messages to: " + this.destination);
             }
 
---------------
-------------
@@ -55,6 +55,7 @@
                                     message = message.copy();
                                 }
                                 message.setDestination(destination.getActiveMQDestination());
+                                message.setMemoryUsage(null); // set this to null so that it will use the queue memoryUsage instance instead of the topic.
                                 super.send(context, message);
                             }
                         };
---------------
-------------
@@ -216,6 +216,7 @@
             for (int i = MAX_PRIORITY - 1; i >= 0; i--) {
                 List<MessageDispatch> list = lists[i];
                 result.addAll(list);
+                size -= list.size();
                 list.clear();
             }
             return result;
---------------
-------------
@@ -80,8 +80,6 @@
                     .setBrokerURL(brokerURL);
         }
 
-        // set the connection factory with the provided broker url
-        answer.setConnectionFactory(new ActiveMQConnectionFactory(brokerURL));
         return answer;
     }
 
---------------
-------------
@@ -75,7 +75,7 @@
         URI uri = broker.getVmConnectorURI();
         HashMap<String, String> map = new HashMap<String, String>(URISupport.parseParameters(uri));
         map.put("network", "true");
-        map.put("async", "false");
+        map.put("async", "true");
         uri = URISupport.createURIWithQuery(uri, URISupport.createQueryString(map));
         return TransportFactory.connect(uri);
     }
---------------
-------------
@@ -779,7 +779,8 @@
             return;
         }
         if (messageExpired) {
-            ackLater(md, MessageAck.DELIVERED_ACK_TYPE);
+        	// do nothing since STANDARD_ACK will be sent
+            return;
         } else {
             stats.onMessage();
             if (session.getTransacted()) {
---------------
-------------
@@ -127,7 +127,7 @@
 
     @Override
     public void sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference, Subscription subscription) {
-        if (next.get().isExpired(messageReference)) {
+        if (messageReference.isExpired()) {
             // there are two uses of  sendToDeadLetterQueue, we are only interested in valid messages
             super.sendToDeadLetterQueue(context, messageReference, subscription);
         } else {
---------------
-------------
@@ -225,6 +225,7 @@
                         toRemoveNode = currentNode;
                         previousNode.setNext(toRemoveNode.getNext());
                         previousNode.store(tx);
+                        currentNode = previousNode;
                     }
                 }
                 targetList.onRemove();
---------------
-------------
@@ -96,6 +96,7 @@
 
         ActiveMQTempDestination tempDest = (ActiveMQTempDestination)dest;
         if (dinfo.getOperationType() == DestinationInfo.ADD_OPERATION_TYPE) {
+            tempDest.setConnection(null);
             connection.activeTempDestinations.put(tempDest, tempDest);
         } else if (dinfo.getOperationType() == DestinationInfo.REMOVE_OPERATION_TYPE) {
             connection.activeTempDestinations.remove(tempDest);
---------------
-------------
@@ -30,6 +30,7 @@
 import org.apache.camel.Exchange;
 import org.apache.camel.Processor;
 import org.apache.camel.component.jms.JmsBinding;
+import org.apache.camel.component.jms.JmsEndpoint;
 
 /**
  * @version $Revision$
---------------
-------------
@@ -244,6 +244,7 @@
         // is done.  We should refactor the browsers to better handle message dispatch so
         // we can remove this and perform a more efficient dispatch.
         sub.setMaxProducersToAudit(Integer.MAX_VALUE);
+        sub.setMaxAuditDepth(Short.MAX_VALUE);
     }
 
     public void configure(Broker broker, SystemUsage memoryManager, QueueSubscription sub) {
---------------
-------------
@@ -860,7 +860,7 @@
         registerSync();
         MessageAck ack = new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1);
         ack.setTransactionId(session.getTransactionContext().getTransactionId());
-        session.sendAck(ack);
+        session.syncSendPacket(ack);
     }
 
     private void afterMessageIsConsumed(MessageDispatch md, boolean messageExpired) throws JMSException {
---------------
-------------
@@ -105,7 +105,6 @@
      * @throws Exception
      */
     public void stop() throws Exception {
-        super.stop();
         stopProcessing();
     }
 
---------------
-------------
@@ -1206,7 +1206,6 @@
                     // Acknowledge the last message.
 
                     MessageAck ack = new MessageAck(lastMd, MessageAck.POSION_ACK_TYPE, deliveredMessages.size());
-                    ack.setPoisonCause(lastMd.getRollbackCause());
                     ack.setFirstMessageId(firstMsgId);
                     ack.setPoisonCause(new Throwable("Exceeded redelivery policy limit:" + redeliveryPolicy));
                     session.sendAck(ack,true);
---------------
-------------
@@ -2125,7 +2125,7 @@
             AnnotatedMBean.registerMBean(getManagementContext(), view, objectName);
             return connector;
         } catch (Throwable e) {
-            throw IOExceptionSupport.create("Transport Connector could not be registered in JMX: " + e.getMessage(), e);
+            throw IOExceptionSupport.create("Transport Connector could not be registered in JMX: " + e, e);
         }
     }
 
---------------
-------------
@@ -136,7 +136,6 @@
 
         try {
             context = createContext();
-
             if (refreshInterval == -1 && !refreshDisabled) {
                 eventContext = ((EventDirContext)context.lookup(""));
                 
---------------
-------------
@@ -82,7 +82,7 @@
     protected int getPriority(MessageReference message) {
         int priority = javax.jms.Message.DEFAULT_PRIORITY;
         if (message.getMessageId() != null) {
-            Math.max(message.getMessage().getPriority(), 0);
+            priority = Math.max(message.getMessage().getPriority(), 0);
             priority = Math.min(priority, 9);
         }
         return priority;
---------------
-------------
@@ -105,7 +105,7 @@
             throw new RuntimeException(getLeaseHolderId() + " failing lease acquire due to stop");
         }
 
-        LOG.info(getLeaseHolderId() + ", becoming master with lease expiry " + new Date(now) + " on dataSource: " + dataSource);
+        LOG.info(getLeaseHolderId() + ", becoming master with lease expiry " + new Date(now + lockAcquireSleepInterval) + " on dataSource: " + dataSource);
     }
 
     private void reportLeasOwnerShipAndDuration(Connection connection) throws SQLException {
---------------
-------------
@@ -151,7 +151,7 @@
     public String toString() {
         try {
             String text = getText();
-        	if (text.length() > 63) {
+        	if (text != null && text.length() > 63) {
         		text = text.substring(0, 45) + "..." + text.substring(text.length() - 12);
         		HashMap<String, Object> overrideFields = new HashMap<String, Object>();
         		overrideFields.put("text", text);
---------------
-------------
@@ -1536,6 +1536,7 @@
 			if(connection.isCopyMessageOnSend()){
 				msg=(ActiveMQMessage)msg.copy();
 			}
+			msg.setConnection(connection);
 			msg.onSend();
 			msg.setProducerId(msg.getMessageId().getProducerId());
 			if(log.isDebugEnabled()){
---------------
-------------
@@ -296,7 +296,7 @@
     }
 
     protected static boolean isAll(String token) {
-        return token != null && token.length() == 1 && token.charAt(0) == '*';
+        return token != null && token.length() == 1 && (token.charAt(0) == '*' || token.charAt(0) == '?');
     }
 
     protected static int getDenominator(final String token) {
---------------
-------------
@@ -34,6 +34,7 @@
     protected PerfRate rate=new PerfRate();
     public PerfConsumer(ConnectionFactory fac,Destination dest,String consumerName) throws JMSException{
         connection=fac.createConnection();
+        connection.setClientID(consumerName);
         Session s=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
         if(dest instanceof Topic&&consumerName!=null&&consumerName.length()>0){
             consumer=s.createDurableSubscriber((Topic) dest,consumerName);
---------------
-------------
@@ -205,7 +205,7 @@
      * @throws IOException if problem during reading/writing action.
      */
     @Test
-//    @Ignore
+    @Ignore
     public void default1BandTest() throws IOException {
         File fileTest = File.createTempFile("default1BandTest", "tiff", tempDir);
         
---------------
-------------
@@ -348,7 +348,7 @@
             }else{
                 axistrs = SequenceValueTransform1D.create(array);
             }
-            final MathTransform mask = PassThroughTransform.create(baseDim, axistrs, values.length-i-1);
+            final MathTransform mask = PassThroughTransform.create(baseDim+i, axistrs, values.length-i-1);
             result = ConcatenatedTransform.create(result, mask);
         }
 
---------------
-------------
@@ -214,7 +214,7 @@
     }
 
 
-    private boolean skipStandardObjectProperties = true;
+    private boolean skipStandardObjectProperties = false;
     private final Map<String, Schema> knownSchemas = new HashMap<>();
     private final Map<String,String> locationMap = new HashMap<>();
 
---------------
-------------
@@ -185,7 +185,7 @@
             
             if(params.context.wraps != null){
                 
-                com.vividsolutions.jts.geom.Geometry objBounds = objBase.getBoundary();
+                com.vividsolutions.jts.geom.Geometry objBounds = JTS.toGeometry(objBase.getEnvelopeInternal());
                 final com.vividsolutions.jts.geom.Envelope objEnv = objBounds.getEnvelopeInternal();
                 final double dx = params.context.wraps.wrapPoints[1].getOrdinate(0) - params.context.wraps.wrapPoints[0].getOrdinate(0);
                 final double dy = params.context.wraps.wrapPoints[1].getOrdinate(1) - params.context.wraps.wrapPoints[0].getOrdinate(1);
---------------
-------------
@@ -710,7 +710,7 @@
             final double[] res = renderingContext.getResolution(layerCRS);
 
             //adjust with the generalization factor
-            final Number n = (Number) hints.get(GO2Hints.KEY_GENERALIZE_FACTOR);
+            final Number n =  (hints==null) ? null : (Number)hints.get(GO2Hints.KEY_GENERALIZE_FACTOR);
             final double factor;
             if(n != null){
                 factor = n.doubleValue();
---------------
-------------
@@ -1,12 +1,17 @@
 /*
- * Copyright (C) 2011-2014 Rinde van Lon, iMinds DistriNet, KU Leuven Licensed
- * under the Apache License, Version 2.0 (the "License"); you may not use this
- * file except in compliance with the License. You may obtain a copy of the
- * License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by
- * applicable law or agreed to in writing, software distributed under the
- * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS
- * OF ANY KIND, either express or implied. See the License for the specific
- * language governing permissions and limitations under the License.
+ * Copyright (C) 2011-2014 Rinde van Lon, iMinds DistriNet, KU Leuven
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *         http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 package com.github.rinde.rinsim.experiment.base;
 
---------------
-------------
@@ -76,7 +76,7 @@
             ).toArray(new String[query.getIntervals().size()])
         )
         .setDimension("hasFilters", String.valueOf(query.hasFilters()))
-        .setDimension("duration", query.getDuration().toPeriod().toStandardMinutes().toString());
+        .setDimension("duration", query.getDuration().toString());
   }
 
   public static <T> ServiceMetricEvent.Builder makeQueryTimeMetric(
---------------
-------------
@@ -173,7 +173,7 @@
                          public String apply(Row input)
                          {
                            // Multi-value dimensions have all been flattened at this point;
-                           final List<String> dimList = input.getDimension(dimension);
+                           final List<String> dimList = input.getDimension(dimension.toLowerCase());
                            return dimList.isEmpty() ? null : dimList.get(0);
                          }
                        }
---------------
-------------
@@ -56,7 +56,7 @@
   @Override
   public boolean appliesTo(DataSegment segment, DateTime referenceTimestamp)
   {
-    final Interval currInterval = new Interval(referenceTimestamp.minus(period), period);
+    final Interval currInterval = new Interval(period, referenceTimestamp);
     return currInterval.contains(segment.getInterval());
   }
 }
---------------
-------------
@@ -136,7 +136,7 @@
     testProperties.putAll(propertyValues);
     injector = Initialization.makeInjectorWithModules(
         GuiceInjectors.makeStartupInjector(),
-        ImmutableList.<Object>of(simpleJsonConfigModule)
+        ImmutableList.<Module>of(simpleJsonConfigModule)
     );
     configurator = injector.getBinding(JsonConfigurator.class).getProvider().get();
     configProvider = JsonConfigProvider.of(configPrefix, clazz);
---------------
-------------
@@ -39,7 +39,7 @@
     S3DataSegmentPusherConfig restoreConfig
   )
   {
-    super(s3Client);
+    super(s3Client, restoreConfig);
     this.archiveConfig = archiveConfig;
     this.restoreConfig = restoreConfig;
   }
---------------
-------------
@@ -210,7 +210,7 @@
                     final Map<String, Object> values = Maps.newHashMap();
                     // put non finalized aggregators for calculating dependent post Aggregators
                     for (AggregatorFactory agg : query.getAggregatorSpecs()) {
-                      values.put(agg.getName(), fn.manipulate(agg, input.getMetric(agg.getName())));
+                      values.put(agg.getName(), input.getMetric(agg.getName()));
                     }
 
                     for (PostAggregator postAgg : query.getPostAggregatorSpecs()) {
---------------
-------------
@@ -110,7 +110,7 @@
     return Arrays.asList(
         new Object[][]{
             {
-                makeQueryRunner(factory, new IncrementalIndexSegment(rtIndex))
+                makeQueryRunner(factory, new IncrementalIndexSegment(rtIndex, null))
             },
             {
                 makeQueryRunner(factory, new QueryableIndexSegment(null, mMappedTestIndex))
---------------
-------------
@@ -215,7 +215,7 @@
                           while (baseIter.hasNext()) {
                             currEntry.set(baseIter.next());
                             if (filterMatcher.matches()) {
-                              break;
+                              return;
                             }
 
                             numAdvanced++;
---------------
-------------
@@ -501,6 +501,7 @@
     )
     {
       this.targetPartitionSize = targetPartitionSize == 0 ? DEFAULT_TARGET_PARTITION_SIZE : targetPartitionSize;
+      Preconditions.checkArgument(rowFlushBoundary >= 0, "rowFlushBoundary should be positive or zero");
       this.rowFlushBoundary = rowFlushBoundary == 0 ? DEFAULT_ROW_FLUSH_BOUNDARY : rowFlushBoundary;
       this.numShards = numShards == null ? -1 : numShards;
       this.indexSpec = indexSpec == null ? DEFAULT_INDEX_SPEC : indexSpec;
---------------
-------------
@@ -76,7 +76,7 @@
             ).toArray(new String[query.getIntervals().size()])
         )
         .setDimension("hasFilters", String.valueOf(query.hasFilters()))
-        .setDimension("duration", query.getDuration().toPeriod().toStandardMinutes().toString());
+        .setDimension("duration", query.getDuration().toString());
   }
 
   public static <T> ServiceMetricEvent.Builder makeQueryTimeMetric(
---------------
-------------
@@ -127,7 +127,7 @@
     if (dataSource instanceof QueryDataSource) {
       GroupByQuery subquery;
       try {
-        subquery = (GroupByQuery) ((QueryDataSource) dataSource).getQuery();
+        subquery = (GroupByQuery) ((QueryDataSource) dataSource).getQuery().withOverriddenContext(query.getContext());
       }
       catch (ClassCastException e) {
         throw new UnsupportedOperationException("Subqueries must be of type 'group by'");
---------------
-------------
@@ -10,7 +10,7 @@
 
   public LoadQueuePeonTester()
   {
-    super(null, null, null, null, null, null);
+    super(null, null, null, null, null);
   }
 
   @Override
---------------
-------------
@@ -127,7 +127,7 @@
     if (dataSource instanceof QueryDataSource) {
       GroupByQuery subquery;
       try {
-        subquery = (GroupByQuery) ((QueryDataSource) dataSource).getQuery();
+        subquery = (GroupByQuery) ((QueryDataSource) dataSource).getQuery().withOverriddenContext(query.getContext());
       }
       catch (ClassCastException e) {
         throw new UnsupportedOperationException("Subqueries must be of type 'group by'");
---------------
-------------
@@ -253,7 +253,7 @@
         log.warn(e, "Unable to close leaderLatch, ignoring");
       }
 
-      exec.shutdownNow();
+      exec.shutdown();
 
       started = false;
     }
---------------
-------------
@@ -39,7 +39,7 @@
     S3DataSegmentPusherConfig restoreConfig
   )
   {
-    super(s3Client);
+    super(s3Client, restoreConfig);
     this.archiveConfig = archiveConfig;
     this.restoreConfig = restoreConfig;
   }
---------------
-------------
@@ -10,7 +10,7 @@
 
   public LoadQueuePeonTester()
   {
-    super(null, null, null, null, null, null);
+    super(null, null, null, null, null);
   }
 
   @Override
---------------
-------------
@@ -67,7 +67,7 @@
 
 	private Map<String, Object> buildStringKeyMap(ByteBuffer input)
 	{
-		int payloadSize = input.limit();
+		int payloadSize = input.remaining();
 
 		if (chars == null || chars.remaining() < payloadSize)
 		{
---------------
-------------
@@ -94,6 +94,6 @@
   public boolean appliesTo(Interval interval, DateTime referenceTimestamp)
   {
     final Interval currInterval = new Interval(period, referenceTimestamp);
-    return currInterval.contains(interval);
+    return currInterval.overlaps(interval) && interval.getStartMillis() >= currInterval.getStartMillis();
   }
 }
---------------
-------------
@@ -24,6 +24,7 @@
 import com.fasterxml.jackson.databind.ObjectWriter;
 import com.google.common.base.Charsets;
 import com.google.common.base.Joiner;
+import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.io.ByteStreams;
 import com.google.inject.Inject;
---------------
-------------
@@ -58,6 +58,7 @@
   @Override
   public String apply(String dimValue)
   {
+    dimValue = (dimValue == null) ? "" : dimValue;
     Matcher matcher = pattern.matcher(dimValue);
     return matcher.find() ? dimValue : null;
   }
---------------
-------------
@@ -173,7 +173,7 @@
                          public String apply(Row input)
                          {
                            // Multi-value dimensions have all been flattened at this point;
-                           final List<String> dimList = input.getDimension(dimension);
+                           final List<String> dimList = input.getDimension(dimension.toLowerCase());
                            return dimList.isEmpty() ? null : dimList.get(0);
                          }
                        }
---------------
-------------
@@ -105,7 +105,7 @@
 
     @Override
     public Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {
-        if (isPrivilegeDefinition(before)) {
+        if (isPrivilegeDefinition(before) && !before.equals(after)) {
             throw new CommitFailedException(CONSTRAINT, 41, "Attempt to modify existing privilege definition " + name);
         } else {
             // not handled by this validator
---------------
-------------
@@ -269,7 +269,7 @@
 
     @Override
     public boolean remove() {
-        if (exists()) {
+        if (!isRoot() && exists()) {
             head().getMutableNodeState();  // Make sure the removed node is connected
             parent.head().getMutableNodeState().removeChildNode(name);
             return true;
---------------
-------------
@@ -56,7 +56,7 @@
 import org.apache.jackrabbit.oak.spi.state.NodeStore;
 
 public class Jcr {
-    private static final int DEFAULT_OBSERVATION_QUEUE_LENGTH = 1000;
+    public static final int DEFAULT_OBSERVATION_QUEUE_LENGTH = 1000;
 
     private final Oak oak;
 
---------------
-------------
@@ -557,7 +557,7 @@
                     try {
                         estimate = SolrQueryIndex.this.solrServer.query(countQuery).getResults().getNumFound();
                     } catch (SolrServerException e) {
-                        log.warn("could not perform count countQuery {}", countQuery);
+                        log.warn("could not perform count query {}", countQuery);
                     }
                     break;
                 case APPROXIMATION:
---------------
-------------
@@ -39,6 +39,7 @@
     public static final DocumentStoreFixture RDB_PG = new RDBFixture("RDB-Postgres", "jdbc:postgresql:oak", "postgres", "geheim");
     public static final DocumentStoreFixture RDB_DB2 = new RDBFixture("RDB-DB2", "jdbc:db2://localhost:50000/OAK", "oak", "geheim");
     public static final DocumentStoreFixture RDB_MYSQL = new RDBFixture("RDB-MySQL", "jdbc:mysql://localhost:3306/oak", "root", "geheim");
+    public static final DocumentStoreFixture RDB_ORACLE = new RDBFixture("RDB-Oracle", "jdbc:oracle:thin:@//localhost:1521/XE", "oak", "geheim");
     public static final DocumentStoreFixture MONGO = new MongoFixture("mongodb://localhost:27017/oak");
 
     public abstract String getName();
---------------
-------------
@@ -83,7 +83,7 @@
                 a = KNOWN_PATH;
             }
             if (a != null) {
-                f.restrictPath(a, Filter.PathRestriction.DIRECT_CHILDREN);
+                f.restrictPath(a, Filter.PathRestriction.ALL_CHILDREN);
             }
         }
     }
---------------
-------------
@@ -86,6 +86,7 @@
             new LoginTest(),
             new LoginLogoutTest(),
             new NamespaceTest(),
+            new NamespaceRegistryTest(),
             new ReadPropertyTest(),
             GetNodeTest.withAdmin(),
             GetNodeTest.withAnonymous(),
---------------
-------------
@@ -65,7 +65,7 @@
         if (recursive) {
             command += "-r ";
         }
-        command += remoteFile;
+        command += "'" + remoteFile + "'";
         return command;
     }
 
---------------
-------------
@@ -65,7 +65,7 @@
         if (recursive) {
             command += "-r ";
         }
-        command += "'" + remoteFile + "'";
+        command += remoteFile.replace(" ", "\\ ");
         return command;
     }
 
---------------
-------------
@@ -112,7 +112,7 @@
 		try {
 			fLogger.info("Loading test suite from file " + suite);
 
-			String path = FilenameUtils.getFullPath(suite.toString());
+			String path = suite.getCanonicalFile().getParent() + File.separator;
 			fLogger.info("Using base path: " + path);
 
 			XMLTestSuiteDocument doc = XMLTestSuiteDocument.Factory.parse(suite);
---------------
-------------
@@ -62,7 +62,7 @@
  */
 public class End2EndTester {
 
-	private static final String BASEPATH= "resources/end2end/";
+	private static final String BASEPATH= "src/test/resources/end2end/";
 
 	public static TestTestRunner getSendOnlyReceiveOnlyRunner() throws ConfigurationException, SpecificationException {
 		return new TestTestRunner(BASEPATH + "01_SendReceiveOnly/", "WastePaperBasketTestSuite.bpts");
---------------
-------------
@@ -440,7 +440,7 @@
         if (!this.options.values().contains(c))
             this.addOption(c);
         this.branchMap.put(c, dest);
-        if (!this.block.branchQ.equals(this)) {
+        if (this.block.branchQ == null || !this.block.branchQ.equals(this)) {
             this.block.branchQ = this;
             switch (this.block.branchParadigm) {
                 case NONE:
---------------
-------------
@@ -4,7 +4,6 @@
 package Dominio;
 
 import java.sql.Timestamp;
-import java.util.Date;
 
 /**
  * @author Ivo Brand�o
---------------
-------------
@@ -57,6 +57,7 @@
 						infoViewExam.getInfoExam()), false);
 
 			sp.getIPersistentExam().delete(examToDelete);
+			result = true;
 		} catch (ExcepcaoPersistencia ex) {
 			throw new FenixServiceException("Errer deleteing exam");
 		}
---------------
-------------
@@ -197,7 +197,7 @@
           new ImageParser(), new JpegParser(), new TiffParser()
       });
       CompositeImageParser() {
-          super(MediaTypeRegistry.getDefaultRegistry(), imageParsers);
+          super(new MediaTypeRegistry(), imageParsers);
       }
   }
 
---------------
-------------
@@ -110,6 +110,7 @@
         if (td.getTitle() != null) {
             char[] titleChars = td.getTitle().toCharArray();
             delegate.characters(titleChars, 0, titleChars.length);
+            delegate.ignorableWhitespace(NL, 0, NL.length);
         }
         
         delegate.endElement(XHTMLContentHandler.XHTML, "title", "title");
---------------
-------------
@@ -83,7 +83,7 @@
         Calendar calendar = GregorianCalendar.getInstance(Locale.US);
         calendar.setTime(date);
         // Have it formatted
-        String formatted = formatDate(date);
+        String formatted = formatDate(calendar);
         // Strip the timezone details before returning
         return formatted.substring(0, formatted.length()-1);
     }
---------------
-------------
@@ -164,6 +164,7 @@
 
                // Get the duration
                double durationSeconds = ((double)mHeader.getDuration()) / mHeader.getTimescale();
+               metadata.set(XMPDM.DURATION, durationSeconds);
                // TODO Use this
 
                // The timescale is normally the sampling rate
---------------
-------------
@@ -162,7 +162,6 @@
             }
             tmp.dispose();
         }
-        handler.endDocument();
     }
 
    
---------------
-------------
@@ -48,8 +48,8 @@
  *    &lt;!ATTLIST mime-type type CDATA #REQUIRED&gt;
  * 
  *    &lt;!-- a comment describing a document with the respective MIME type. Example: &quot;WMV video&quot; --&gt;
- *    &lt;!ELEMENT comment (#PCDATA)&gt;
- *    &lt;!ATTLIST comment xml:lang CDATA #IMPLIED&gt;
+ *    &lt;!ELEMENT _comment (#PCDATA)&gt;
+ *    &lt;!ATTLIST _comment xml:lang CDATA #IMPLIED&gt;
  * 
  *    &lt;!-- a comment describing a the respective unexpanded MIME type acronym. Example: &quot;WMV&quot; --&gt;
  *    &lt;!ELEMENT acronym (#PCDATA)&gt;
---------------
-------------
@@ -1074,7 +1074,7 @@
 
             // List table handling
             if (currentListTable != null) {
-                if (equals("list")) {
+                if (equals("list") || equals("listoverride")) {
                     currentList = new ListDescriptor();
                     listTableLevel = -1;
                 } else if (currentList != null) {
---------------
-------------
@@ -101,7 +101,7 @@
                 || (a == 0xc7 && b == 0x71)) {
             metadata.set(Metadata.CONTENT_TYPE, "application/x-cpio");
             unpack(new CpioArchiveInputStream(stream), xhtml);
-        } else if (a == '=' && (b == '<' || b == '!')) {
+        } else if ((a == '=' || a == '!') && (b == '<')) {
             metadata.set(Metadata.CONTENT_TYPE, "application/x-archive");
             unpack(new ArArchiveInputStream(stream), xhtml);
         } else {
---------------
-------------
@@ -49,6 +49,7 @@
 
   @Override
   public void controlMoved( ControlEvent event ) {
+    parent.getLocation();
     Point location = Display.getCurrent().map( parent, null, toOverlay.getLocation() );
     overlay.setLocation( location );
   }
---------------
-------------
@@ -458,7 +458,7 @@
 		try {
 			while (i > 0) {
 				char ch = document.getChar(i - 1);
-				if (!Character.isLetterOrDigit(ch) && (ch != '%') && (ch != '_') && (ch != '-') && (ch != '{')) {
+				if (!Character.isLetterOrDigit(ch) && (ch != '%') && (ch != '_') && (ch != '-') && (ch != '{') && (ch != '.') && (ch != '+')) {
 					break;
 				}
 				i--;
---------------
-------------
@@ -1,3 +1,10 @@
+/*******************************************************************************
+ * Copyright (c) 2010 Red Hat Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *******************************************************************************/
 package org.eclipse.linuxtools.changelog.core.tests;
 import org.eclipse.linuxtools.changelog.core.formatters.tests.GNUFormatTest;
 import org.eclipse.linuxtools.changelog.parsers.tests.JavaParserTest;
---------------
-------------
@@ -20,7 +20,7 @@
  */
 @RunWith(Suite.class)
 @SuiteClasses({
-//	ChangeLogWriterTest.class,
+	ChangeLogWriterTest.class,
 	GNUFormatTest.class,
 	JavaParserTest.class,
 	CParserTest.class,
---------------
-------------
@@ -252,7 +252,7 @@
 	}
 
 	protected void initializeToolMap() {
-		toolMap = new HashMap<String, IConfigurationElement>();
+		toolMap = new HashMap<>();
 		IExtensionPoint extPoint = Platform.getExtensionRegistry().getExtensionPoint(PLUGIN_ID, ValgrindLaunchPlugin.TOOL_EXT_ID);
 		IConfigurationElement[] configs = extPoint.getConfigurationElements();
 		for (IConfigurationElement config : configs) {
---------------
-------------
@@ -68,7 +68,7 @@
 			while (variableMatcher.find()) {
 				define = specfile.getDefine(variableMatcher.group(1));
 				if (define != null) {
-					stringToResolve = stringToResolve.replaceAll(variableMatcher.group(1), define.getStringValue());
+					stringToResolve = stringToResolve.replaceAll("\\b"+variableMatcher.group(1)+"\\b", define.getStringValue());
 				} else {
 					return originalString;
 				}
---------------
-------------
@@ -31,6 +31,7 @@
 			suite.addTestSuite(SystemTapCommandLineTest.class);
 		suite.addTestSuite(SystemTapTabTest.class);
 		suite.addTestSuite(LaunchShortcutsTest.class);
+		suite.addTestSuite(SystemTapErrorHandlerTest.class);
 		//$JUnit-END$
 		return suite;
 	}
---------------
-------------
@@ -91,6 +91,7 @@
 		BufferedReader br = new BufferedReader(new InputStreamReader(
 				new FileInputStream(createdFile.getLocation().toFile())));
 		String actualContent = br.readLine();
+		br.close();
 		assertEquals(fileContent, actualContent);
 		
 		// this should throw an IllegalStateException
---------------
-------------
@@ -162,7 +162,7 @@
 		if ( "jar".equals( protocol ) ) {
 			return new JarProtocolVisitor( jarUrl, filters, entry );
 		}
-		else if ( StringHelper.isEmpty( protocol ) || "file".equals( protocol ) ) {
+		else if ( StringHelper.isEmpty( protocol ) || "file".equals( protocol ) || "vfszip".equals( protocol ) || "vfsfile".equals( protocol ) ) {
 			File file;
 			try {
 				final String filePart = jarUrl.getFile();
---------------
-------------
@@ -127,7 +127,7 @@
 					return getObjectFromList( results, id, session );
 				}
 			}
-			return ( loaders[batchSizes.length-1] ).load( id, optionalObject, session );
+			return ( loaders[batchSizes.length-1] ).load( id, optionalObject, session, lockOptions );
 		}
 	}
 
---------------
-------------
@@ -343,7 +343,7 @@
    * @return the new TachyonURI
    */
   public TachyonURI join(String suffix) {
-    return new TachyonURI(toString() + TachyonURI.SEPARATOR + suffix);
+    return new TachyonURI(getScheme(), getAuthority(), getPath() + TachyonURI.SEPARATOR + suffix);
   }
 
   /**
---------------
-------------
@@ -389,7 +389,7 @@
    * @param addr
    *          an address or path string, e.g., "hdfs://host:port/dir", "file:///dir", "/dir".
    * @return an address or path string with hostname resolved, or the original path intact if
-   * no hostname is embedded, or null if the given path is null or empty.
+   *          no hostname is embedded, or null if the given path is null or empty.
    * @throws UnknownHostException if the hostname cannot be resolved.
    */
   public static String replaceHostName(String addr) throws UnknownHostException {
---------------
-------------
@@ -253,7 +253,7 @@
    * @throws BlockInfoException
    */
   public synchronized ClientBlockInfo getClientBlockInfo(int blockIndex) throws BlockInfoException {
-    if (blockIndex < 0 || blockIndex > mBlocks.size()) {
+    if (blockIndex < 0 || blockIndex >= mBlocks.size()) {
       throw new BlockInfoException("BlockIndex is out of the boundry: " + blockIndex);
     }
 
---------------
-------------
@@ -23,6 +23,7 @@
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
+
 import tachyon.network.protocol.RPCMessage;
 
 /**
---------------
-------------
@@ -343,7 +343,7 @@
    * @return the new TachyonURI
    */
   public TachyonURI join(String suffix) {
-    return new TachyonURI(toString() + TachyonURI.SEPARATOR + suffix);
+    return new TachyonURI(getScheme(), getAuthority(), getPath() + TachyonURI.SEPARATOR + suffix);
   }
 
   /**
---------------
-------------
@@ -53,7 +53,7 @@
   public static final String PATH_SEPARATOR = "/";
   public static final int MAX_COLUMNS = Integer.parseInt(System.getProperty("tachyon.max.columns",
       "1000"));
-  public static final long MAX_TABLE_METADATA_BYTE = Long.parseLong(System.getProperty(
+  public static final int MAX_TABLE_METADATA_BYTE = Integer.parseInt(System.getProperty(
       "tachyon.max.table.metadata.byte", String.valueOf(MB * 5)));
   public static final int WORKER_BLOCKS_QUEUE_SIZE = 10000;
 
---------------
-------------
@@ -266,7 +266,7 @@
   public void initialize(URI uri, Configuration conf) throws IOException {
     super.initialize(uri, conf);
     LOG.info("initialize(" + uri + ", " + conf + "). Connecting to Tachyon: " + uri.toString());
-    mTachyonHeader = "tachyon://" + uri.getHost() + ":" + uri.getPort();
+    mTachyonHeader = uri.getScheme() +  "://" + uri.getHost() + ":" + uri.getPort();
     mTFS = TachyonFS.get(mTachyonHeader);
     mUri = URI.create(mTachyonHeader);
     UNDERFS_ADDRESS = mTFS.getUnderfsAddress();
---------------
-------------
@@ -15,6 +15,7 @@
     } else {
       METADATA = ByteBuffer.allocate(metadata.limit());
       METADATA.put(metadata);
+      METADATA.flip();
     }
   }
 
---------------
-------------
@@ -253,7 +253,7 @@
    * @throws BlockInfoException
    */
   public synchronized ClientBlockInfo getClientBlockInfo(int blockIndex) throws BlockInfoException {
-    if (blockIndex < 0 || blockIndex > mBlocks.size()) {
+    if (blockIndex < 0 || blockIndex >= mBlocks.size()) {
       throw new BlockInfoException("BlockIndex is out of the boundry: " + blockIndex);
     }
 
---------------
-------------
@@ -102,7 +102,7 @@
     // Add a slash to parent's path so resolution is compatible with URI's
     URI parentUri = parent.mUri;
     String parentPath = parentUri.getPath();
-    if (!parentPath.endsWith(SEPARATOR)) {
+    if (!parentPath.endsWith(SEPARATOR) && parentPath.length() > 0) {
       parentPath += SEPARATOR;
     }
     try {
---------------
-------------
@@ -232,7 +232,7 @@
             Label whileExit = new Label();
             mv.visitLabel(whileStart);
             mv.visitVarInsn(ALOAD, tupleReg);
-            invokeInterface(LeftTuple.class, "getQueueIndex", Integer.TYPE); // tuple.getQueueIndex()
+            invokeInterface(LeftTuple.class, "getIndex", Integer.TYPE); // tuple.getIndex()
             mv.visitVarInsn(ILOAD, declarOffsetReg); // declarations[i].getPattern().getOffset()
             mv.visitJumpInsn(IF_ICMPLE, whileExit); // if tuple.getQueueIndex() <= declarations[i].getPattern().getOffset() jump to whileExit
             mv.visitVarInsn(ALOAD, tupleReg);
---------------
-------------
@@ -192,7 +192,7 @@
                                                                                        null,
                                                                                        handle );
                     ObjectTypeNode.doRetractObject(handle, expiresPctx, workingMemory);
-                    pctx.evaluateActionQueue( workingMemory );
+                    expiresPctx.evaluateActionQueue( workingMemory );
                 }
                 queue.expiringHandle = null;
                 handle = queue.queue.peek();
---------------
-------------
@@ -544,7 +544,7 @@
             lmem.linkNode(this);
             List<PathMemory> pmems =  lmem.getSegmentMemory().getPathMemories();
             PathMemory pmm = pmems!=null && !pmems.isEmpty() ? pmems.get(0) : null;
-            if( pmm != null ) {
+            if( pmm != null && pmm.getRuleAgendaItem() != null ) {
                 RuleAgendaItem item = pmm.getRuleAgendaItem();
                 item.getRuleExecutor().reEvaluateNetwork( this, new org.drools.core.util.LinkedList<StackEntry>(), false);
             }
---------------
-------------
@@ -65,6 +65,7 @@
         this.attributes = new LinkedHashMap<String, AttributeDescr>();
         this.namedConsequence = new HashMap<String, Object>();
         this.lhs = new AndDescr();
+        this.consequence = "";
     }
 
     @SuppressWarnings("unchecked")
---------------
-------------
@@ -117,7 +117,7 @@
                 sbuilder.append( "," );
             }
             if (ALLOW_MODIFY_EXPRESSIONS) {
-                sbuilder.append( setter.getAccessor() + " = " + setter.getValue() + "\n" );
+                sbuilder.append( setter.getAccessor() + " = '" + setter.getValue() + "'\n" );
             } else {
                 sbuilder.append( setter.getAccessor() + " = '" + setter.getValue().replace("\"", "") + "'\n" );
             }
---------------
-------------
@@ -40,7 +40,7 @@
     ObjectType,
     Externalizable {
     
-    public static final ClassObjectType InitialFact_ObjectType = new ClassObjectType( InitialFactImpl.class );
+    public static final ClassObjectType InitialFact_ObjectType = new ClassObjectType( InitialFact.class );
     
     public static final ClassObjectType DroolsQuery_ObjectType = new ClassObjectType( DroolsQuery.class );
     
---------------
-------------
@@ -136,7 +136,7 @@
                 }
                 
                 // calculating and fixing variable offset 
-                String before = escapedKey.substring( lastMatch, m.start() );
+                String before = escapedKey.substring( lastMatch, Math.max( m.start(), lastMatch) );
                 lastMatch = m.end()+1;
                 Matcher m2 = PAREN_FINDER.matcher( before );
                 while( m2.find() ) {
---------------
-------------
@@ -1520,7 +1520,7 @@
         InternalKnowledgePackage current = getPackage();
         this.pkgRegistryMap.remove(packageDescr.getName());
         this.pkgRegistryMap.put(packageDescr.getName(), pkgRegistry);
-        if (!current.getName().equals(packageDescr.getName())) {
+        if (current.getName().equals(packageDescr.getName())) {
             currentRulePackage = pkgRegistryMap.size() - 1;
         }
     }
---------------
-------------
@@ -1133,7 +1133,7 @@
             String typesafe = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;
             if (typesafe != null) {
                 type.setTypesafe(Boolean.parseBoolean(typesafe));
-            } else if (parent != null) {
+            } else if (parent != null && isSet(parent.getSetMask(), TypeDeclaration.TYPESAFE_BIT)) {
                 type.setTypesafe(parent.isTypesafe());
             }
 
---------------
-------------
@@ -256,7 +256,6 @@
                                                                                         null ),
                                                                        null,
                                                                        null,
-                                                                       null,
                                                                        ksession,
                                                                        null );
 
---------------
-------------
@@ -398,7 +398,7 @@
 		for (Map activeMetadata : declMetadaList) {
 			Entry activeEntry = (Entry) activeMetadata.entrySet().iterator()
 					.next();
-			String chunkData = ((DroolsTree) activeEntry.getValue()).getText();
+            String chunkData = ((DroolsTree) activeEntry.getValue() != null ) ?((DroolsTree) activeEntry.getValue()).getText() : "()";
 			field.addMetaAttribute(((DroolsTree) activeEntry.getKey())
 					.getText(), chunkData.substring(1, chunkData.length() - 1));
 		}
---------------
-------------
@@ -301,7 +301,7 @@
         int varLength = inputIdentifiers.length;
 
         int i = 0;
-        if ( rightObject != null ) {
+        if ( "this".equals( inputIdentifiers[0] ) ) {
             factory.getIndexedVariableResolver( i++ ).setValue( rightObject );
         }
         factory.getIndexedVariableResolver( i++ ).setValue( knowledgeHelper );
---------------
-------------
@@ -122,7 +122,7 @@
         int lastAdded = 0;
 
         for (JavaBlockDescr block : blocks) {
-            if (block.getEnd() == 0) {
+            if (block.getEnd() == 0 || block.getEnd() > originalCode.length() ) {
                 // do nothing, it was incorrectly parsed, but this error should be picked up else where
                 continue;
             }
---------------
-------------
@@ -43,7 +43,7 @@
     public PatternDescrBuilder<P> constraint( String constraint, boolean positional );
     public PatternDescrBuilder<P> bind( String var, String target, boolean isUnification );
     
-    public SourceDescrBuilder<?> from();
+    public SourceDescrBuilder<PatternDescrBuilder<P>> from();
     
     public BehaviorDescrBuilder<PatternDescrBuilder<P>> behavior();
 
---------------
-------------
@@ -342,7 +342,7 @@
         // NOTE: it would probably be a good idea to create a specific attribute for that
             for ( WorkingMemoryEntryPoint ep : workingMemory.getEntryPoints().values() ) {
                 handle = (FactHandle) ep.getFactHandle( object );
-                if ( handle != null ) {
+                if ( handle != null && identityMap != null ) {
                     identityMap.put( object,
                                      handle );
                     break;
---------------
-------------
@@ -989,7 +989,8 @@
                 stopAt = CronTrigger.YEAR_TO_GIVEUP_SCHEDULING_AT;
             }
             if (startAt == -1 || startAt == ALL_SPEC_INT) {
-                startAt = 1970;
+                // needs to start at 1969 because timezones can make dates before 1970
+                startAt = 1969;
             }
         }
 
---------------
-------------
@@ -1505,7 +1505,7 @@
         //look among local declarations
         if (pkgRegistry != null) {
             for (String declaredName : pkgRegistry.getPackage().getTypeDeclarations().keySet()) {
-                if (declaredName.endsWith( sup ))
+                if (declaredName.equals( sup ))
                     sup = pkgRegistry.getPackage().getTypeDeclaration( declaredName ).getTypeClass().getName();
             }
         }
---------------
-------------
@@ -574,7 +574,7 @@
                         if ( c.start > -1 ) {
                             // rebuilding previous pattern structure
                             expanded[lastPattern] = expanded[lastPattern].substring( 0,
-                                                                                     c.start ) + c.constraints + ((c.constraints.length() == 0) ? "" : ", ") + expanded[lastExpanded].trim() + expanded[lastPattern].substring( c.end );
+                                                                                     c.start ) + c.constraints + ((c.constraints.trim().length() == 0) ? "" : ", ") + expanded[lastExpanded].trim() + expanded[lastPattern].substring( c.end );
                         } else {
                             // error, pattern not found to add constraint to
                             this.addError( new ExpanderException( "No pattern was found to add the constraint to: " + lines[i].trim(),
---------------
-------------
@@ -489,7 +489,7 @@
     private void switchOnDoBetaNode(NetworkNode node, LeftTupleSets trgTuples, InternalWorkingMemory wm, LeftTupleSets srcTuples, LeftTupleSets stagedLeftTuples, LeftTupleSinkNode sink, BetaMemory bm, AccumulateMemory am) {
         if (log.isTraceEnabled()) {
             int offset = getOffset(node);
-            log.trace("{} {} rightTuples {}", indent(offset), ++cycle, bm.getStagedRightTuples().toStringSizes());
+            log.trace("{} rightTuples {}", indent(offset), bm.getStagedRightTuples().toStringSizes());
         }
 
         switch (node.getType()) {
---------------
-------------
@@ -71,7 +71,7 @@
     }
     
     public String getValueString() {
-        if( type == Type.STRING || type == Type.DATE ) {
+        if( type == Type.STRING || type == Type.DATE || name.equals("dialect") ) {
             // needs escaping
             return "\""+this.value+"\"";
         }
---------------
-------------
@@ -228,7 +228,7 @@
         if (ignoredResourceTypes == null) {
             ignoredResourceTypes = Collections.emptySet();
         }
-        ValidationResourceVisitor visitor = new ValidationResourceVisitor(this, resource.getPath(), true, ignoredResourceTypes);
+        ValidationResourceVisitor visitor = new ValidationResourceVisitor(this, resource.getPath(), enforceValidation, ignoredResourceTypes);
         visitor.accept(resource);
         return visitor.getResult();
     }
---------------
-------------
@@ -602,8 +602,8 @@
      * @param name   The name of the child resource
      * @return a unique non-existing name for child resource for a given <code>parent</code>
      *
-     * @throws {@link PersistenceException} if it can not find unique name for child resource.
-     * @throws {@link NullPointerException} if <code>parent</code> is null
+     * @throws PersistenceException if it can not find unique name for child resource.
+     * @throws NullPointerException if <code>parent</code> is null
      * @since 2.5.0
      */
     public static String createUniqueChildName(final Resource parent, final String name)
---------------
-------------
@@ -132,7 +132,7 @@
 
     @Override
     public @Nonnull ValidationResult validate(@Nonnull Resource resource, @Nonnull ValidationModel model) {
-        return new ValidationResultImpl(); //validate(resource, model, "");
+        return validate(resource, model, "");
     }
     
     protected @Nonnull ValidationResult validate(@Nonnull Resource resource, @Nonnull ValidationModel model, @Nonnull String relativePath) {
---------------
-------------
@@ -417,7 +417,7 @@
             
             Object[] typedValue = (Object[])valueMap.get(property, type);
             // see https://issues.apache.org/jira/browse/SLING-4178 for why the second check is necessary
-            if (typedValue == null || typedValue[0] == null) {
+            if (typedValue == null || (typedValue.length > 0 && typedValue[0] == null)) {
                 // here the missing required property case was already treated in validateValueMap
                 result.addFailureMessage(property, "Property was expected to be of type '" + validator.getType() + "' but cannot be converted to that type." );
                 return;
---------------
-------------
@@ -265,7 +265,7 @@
             throw new PersistenceException("Path already exists: " + path);
         }
         synchronized ( this.resources ) {
-            if ( this.resources.containsKey(path) ) {
+            if ( this.resources.containsKey(path) && !this.deletedResources.contains(path) ) {
                 throw new PersistenceException("Path already exists: " + path);
             }
         }
---------------
-------------
@@ -23,7 +23,7 @@
 @SuppressWarnings("serial")
 public class ServicePropertiesMap extends HashMap<String, Object> {
     
-    public ServicePropertiesMap(long serviceId, long serviceRanking) {
+    public ServicePropertiesMap(long serviceId, int serviceRanking) {
         super();
         put(Constants.SERVICE_ID, serviceId);
         put(Constants.SERVICE_RANKING, serviceRanking);
---------------
-------------
@@ -30,7 +30,7 @@
         AbstractNetconfSessionNegotiator<NetconfServerSessionPreferences, NetconfServerSession, NetconfServerSessionListener> {
 
     private static final Logger LOG = LoggerFactory.getLogger(NetconfServerSessionNegotiator.class);
-    
+
     private static final String UNKNOWN = "unknown";
 
     protected NetconfServerSessionNegotiator(
---------------
-------------
@@ -62,7 +62,7 @@
         RESOURCE_DENIED("resource-denied", 409 /* Conflict */),
         ROLLBACK_FAILED("rollback-failed", 500 /* INTERNAL_SERVER_ERROR */),
         DATA_EXISTS("data-exists", 409 /* Conflict */),
-        DATA_MISSING("data-missing", 409 /* Conflict */),
+        DATA_MISSING("data-missing", 404 /* Resource Not Found */),
         OPERATION_NOT_SUPPORTED("operation-not-supported", 501 /* Not Implemented */),
         OPERATION_FAILED("operation-failed", 500 /* INTERNAL_SERVER_ERROR */),
         PARTIAL_OPERATION("partial-operation", 500 /* INTERNAL_SERVER_ERROR */),
---------------
-------------
@@ -156,8 +156,6 @@
 
     public static Option flowCapableModelBundles() {
         return new DefaultCompositeOption( //
-                mavenBundle(CONTROLLER_MODELS, "model-flow-base").versionAsInProject(), // //
-                mavenBundle(CONTROLLER_MODELS, "model-flow-service").versionAsInProject(), // //
                 mavenBundle(CONTROLLER_MODELS, "model-inventory").versionAsInProject() //
         );
 
---------------
-------------
@@ -397,7 +397,7 @@
      * dependencies are satisfied
      *
      */
-    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @SuppressWarnings("unchecked")
     public void init() {
         log.debug("Routing init() is called");
         this.topologyBWAware = new ConcurrentHashMap<Short, Graph<Node, Edge>>();
---------------
-------------
@@ -918,6 +918,7 @@
 		result.setPathname(namesClonable);
 		result.setTerms(terms);
 		result.setAccess(PAccessSpecifierAssistant.getPublic());
+		result.setType(newAOperationType(location));
 		
 		return result;
 	}
---------------
-------------
@@ -65,7 +65,7 @@
 							pos++;
 							while (expression.length() > pos) {
 								next = expression.charAt(pos);
-								if (Character.isDigit(next)) {
+								if (Character.isDigit(next) || next == '.') {
 									complex.append(next);
 									pos++;
 								} else {
---------------
-------------
@@ -202,9 +202,8 @@
 					throw new UnparsableExpressionException(c, i);
 				}
 			}else if (c == ',') {
-			    // keep pushing numbertokens as function arguments onto
-			    // the stack until a right paranthesis is encountered.
-			    continue;
+			    // a function separator, hopefully
+			    lastToken=new FunctionSeparatorToken();
 			} else if (OperatorToken.isOperator(c)) {
 				lastToken = new OperatorToken(String.valueOf(c), OperatorToken.getOperation(c));
 			} else if (c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}') {
---------------
-------------
@@ -43,7 +43,7 @@
 					stack.push(t);
 				} else {
 					/* a right para */
-					while (stack.peek().getType() != Type.PARANTHESES && ((ParanthesesToken) stack.peek()).isOpen()) {
+					while (stack.peek().getType() != Type.PARANTHESES || !((ParanthesesToken) stack.peek()).isOpen()) {
 						output.push(stack.pop());
 					}
 					stack.pop(); // pop the left parantheses
---------------
-------------
@@ -75,7 +75,7 @@
 				return values[0] % values[1];
 			}
 		};
-		CustomOperator umin = new CustomOperator("\'", false, 7, 1) {
+		CustomOperator umin = new CustomOperator("\'", false, 5, 1) {
 			@Override
 			protected double applyOperation(double[] values) {
 				return -values[0];
---------------
-------------
@@ -28,7 +28,7 @@
     public static TestSuite suite() throws Exception {
         TestSuite suite = new TestSuite("Gridgain GGFS Test Suite For Platform Independent Tests");
 
-        suite.addTest(new TestSuite(GridGgfsSizeSelfTest.class));
+//        suite.addTest(new TestSuite(GridGgfsSizeSelfTest.class)); TODO Enable after GG-9035
         suite.addTest(new TestSuite(GridGgfsAttributesSelfTest.class));
         suite.addTest(new TestSuite(GridGgfsFileInfoSelfTest.class));
         suite.addTest(new TestSuite(GridGgfsMetaManagerSelfTest.class));
---------------
-------------
@@ -665,6 +665,8 @@
 
         /** {@inheritDoc} */
         @Override public void onConnectionLost(GridHadoopProcessDescriptor desc) {
+            assert desc != null;
+
             if (!busyLock.tryReadLock())
                 return;
 
---------------
-------------
@@ -753,7 +753,7 @@
             if (!ctx.isEnterprise())
                 warnNotSupportedFeaturesForOs(cfg);
 
-            // Notify discovery manager the first to make sure that topology is discovered.
+            // Notify dis0covery manager the first to make sure that topology is discovered.
             ctx.discovery().onKernalStart();
 
             // Notify IO manager the second so further components can send and receive messages.
---------------
-------------
@@ -451,7 +451,7 @@
     private void checkSame(String name, String propName, UUID rmtNodeId, Object rmtVal, Object locVal, String ggfsName)
         throws GridException {
         if (!F.eq(rmtVal, locVal))
-            throw new GridException(name + " should be the same on all node in grid for GGFS configuration " +
+            throw new GridException(name + " should be the same on all nodes in grid for GGFS configuration " +
                 "(fix configuration or set " +
                 "-D" + GridSystemProperties.GG_SKIP_CONFIGURATION_CONSISTENCY_CHECK + "=true system " +
                 "property ) [rmtNodeId=" + rmtNodeId +
---------------
-------------
@@ -38,7 +38,7 @@
     PriorityTest.class,
     ParallelTest.class,
     LoadBalancedTests.class,
-//    DefaultToFIFOPriorityTest.class,
+    DefaultToFIFOPriorityTest.class,
     ConcurrencyLockTest.class,
     AddingProxyAgainFreesResources.class,
     DefaultCapabilityMatcherTest.class,
---------------
-------------
@@ -36,7 +36,7 @@
 
 @RunWith(ParallelSuite.class)
 @Suite.SuiteClasses({
-    AlertsTest.class,
+    //AlertsTest.class, //ignore temporary, TODO: fix regresion MHA-863
     AtomsInjectionTest.class,
     AuthenticatedPageLoadingTest.class,
     AvailableLogsTest.class,
---------------
-------------
@@ -63,7 +63,7 @@
         final JsonNode idNode = node.path("id");
 
         if (idNode.isTextual()) {
-            final String s = idNode.textValue().replaceFirst("^#", "");
+            final String s = idNode.textValue();
             if (asString.equals(s))
                 return nodeAndPath;
         }
---------------
-------------
@@ -31,7 +31,7 @@
  *
  * <pre>
  *     final Processor&lt;X, Y&gt; chain = ProcessorChain.startWith(p1)
- *         .chainWith(p2).chainWith(...);
+ *         .chainWith(p2).chainWith(...).end();
  *
  *     // input is of type X
  *     final Y ret = chain.process(report, X);
---------------
-------------
@@ -184,6 +184,6 @@
 
         if (!s.equals(k))
             throw new IllegalArgumentException("registered syntax/keyword "
-                + "validators do not covert the same set of keywords");
+                + "validators do not cover the same set of keywords");
     }
 }
---------------
-------------
@@ -33,7 +33,7 @@
     this.delimiter = delimiter;
     this.listDelimiter = listDelimiter;
 
-    this.columns = columns == null ? Lists.<String>newArrayList() : columns;
+    this.columns = columns == null ? dimensionsSpec.getDimensions() : columns;
     for (String column : this.columns) {
       Preconditions.checkArgument(!column.contains(","), "Column[%s] has a comma, it cannot", column);
     }
---------------
-------------
@@ -33,7 +33,7 @@
     this.delimiter = delimiter;
     this.listDelimiter = listDelimiter;
 
-    this.columns = columns == null ? Lists.<String>newArrayList() : columns;
+    this.columns = columns == null ? dimensionsSpec.getDimensions() : columns;
     for (String column : this.columns) {
       Preconditions.checkArgument(!column.contains(","), "Column[%s] has a comma, it cannot", column);
     }
---------------
-------------
@@ -25,7 +25,7 @@
   )
   {
     this.timestampColumn = (timestampColumn == null) ? null : timestampColumn.toLowerCase();
-    this.timestampFormat = format == null ? defaultFormat : format.toLowerCase();
+    this.timestampFormat = format == null ? defaultFormat : format;
     this.timestampConverter = ParserUtils.createTimestampParser(timestampFormat);
   }
 
---------------
-------------
@@ -265,7 +265,7 @@
   private void prepareLastAddedPartitions() {
     for (AbstractService service : services) {
       try {
-        service.prepareLastAddedPartitionMap();
+        ((AbstractService) service).prepareLastAddedPartitionMap();
       } catch (InterruptedException e) {
         e.printStackTrace();
       }
---------------
-------------
@@ -1008,6 +1008,8 @@
     for (String stream : streamsToProcess) {
       String tableName = getTableName(stream);
       pathsToBeregisteredPerTable.get(tableName).clear();
+      lastAddedPartitionMap.clear();
+      //streamHcatEnableMap.clear();
     }
   }
 }
---------------
-------------
@@ -148,7 +148,6 @@
         for (int i = 1; time <= temptime; i++) {
           if (i != 61) {
             time = startTime + ((i-1) * increment);
-            LOG.info("Time "+(new Date(time)).toString());
             String path = Cluster.getDateAsYYYYMMDDHHMNPath(time);
             int filesCount = 2;
             Path minDir = new Path(listPath, path);
---------------
-------------
@@ -53,8 +53,9 @@
     // (partly because the 'System.local' doesn't have it for some weird reason for instance).
     volatile InetAddress listenAddress;
 
-    // ClusterMetadata keeps one Host object per inet address, so don't use
-    // that constructor unless you know what you do (use ClusterMetadata.getHost typically).
+    // ClusterMetadata keeps one Host object per inet address and we rely on this (more precisely,
+    // we rely on the fact that we can use Object equality as a valid equality), so don't use
+    // that constructor but ClusterMetadata.getHost instead.
     Host(InetSocketAddress address, ConvictionPolicy.Factory policy) {
         if (address == null || policy == null)
             throw new NullPointerException();
---------------
-------------
@@ -968,6 +968,8 @@
                 while (true) {
                     try {
                         controlConnection.connect();
+                        if (connectionFactory.protocolVersion < 0)
+                            connectionFactory.protocolVersion = 2;
                         return;
                     } catch (UnsupportedProtocolVersionException e) {
                         assert connectionFactory.protocolVersion < 1;
---------------
-------------
@@ -145,7 +145,7 @@
             if (value instanceof BigDecimal)
                 return DataType.decimal();
             if (value instanceof BigInteger)
-                return DataType.decimal();
+                return DataType.varint();
             return null;
         }
 
---------------
-------------
@@ -53,8 +53,9 @@
     // (partly because the 'System.local' doesn't have it for some weird reason for instance).
     volatile InetAddress listenAddress;
 
-    // ClusterMetadata keeps one Host object per inet address, so don't use
-    // that constructor unless you know what you do (use ClusterMetadata.getHost typically).
+    // ClusterMetadata keeps one Host object per inet address and we rely on this (more precisely,
+    // we rely on the fact that we can use Object equality as a valid equality), so don't use
+    // that constructor but ClusterMetadata.getHost instead.
     Host(InetSocketAddress address, ConvictionPolicy.Factory policy) {
         if (address == null || policy == null)
             throw new NullPointerException();
---------------
-------------
@@ -83,7 +83,7 @@
             //    ... IN ? ...
             // which binds the variable to the full list the IN is on.
             if (values.size() == 1 && values.get(0) instanceof BindMarker) {
-                Utils.appendName(name, sb).append("IN ").append(values.get(0));
+                Utils.appendName(name, sb).append(" IN ").append(values.get(0));
                 return;
             }
 
---------------
-------------
@@ -92,7 +92,7 @@
             sb.append(value);
             return true;
         } else if (value instanceof InetAddress) {
-            sb.append(((InetAddress)value).getHostAddress());
+            sb.append("'").append(((InetAddress)value).getHostAddress()).append("'");
             return true;
         } else if (value instanceof Date) {
             sb.append(((Date)value).getTime());
---------------
-------------
@@ -12,7 +12,6 @@
 
 import org.springframework.test.context.ContextConfiguration;
 
-
 /**
  * @author Kaitlin Duck Sherwood
  */
---------------
-------------
@@ -111,7 +111,7 @@
 			} else if (p1 instanceof ValueProposal && p2 instanceof ValueProposal) {
 				int order1 = ((ValueProposal)p1).sortingOrder;
 				int order2 = ((ValueProposal)p2).sortingOrder;
-				return Integer.compare(order1, order2);
+				return Integer.valueOf(order1).compareTo(Integer.valueOf(order2));
 			}
 			return 0;
 		}
---------------
-------------
@@ -41,7 +41,7 @@
     }
 
     public void setOperationContext(OperationContext oc) throws AxisFault {
-        msgcts = oc.getMessageContext(WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
+        msgcts = oc.getMessageContext(WSDLConstants.MESSAGE_LABEL_IN_VALUE);
     }
 
     public OMElement echoAttachment(OMElement omEle) {
---------------
-------------
@@ -259,7 +259,7 @@
 
     /**
      * This method assume that both the before and after cant be a same hander
-     * that dose not check inside this , it should check befor calling this method
+     * that does not check inside this , it should check befor calling this method
      *
      * @param handler
      * @throws PhaseException
---------------
-------------
@@ -1136,7 +1136,7 @@
 
             //process the particle of this node
             if (extension.getParticle() != null) {
-                processParticle(null,extension.getParticle(), metaInfHolder, parentSchema);
+                processParticle(extension.getBaseTypeName(),extension.getParticle(), metaInfHolder, parentSchema);
             }
 
             // process attributes
---------------
-------------
@@ -256,6 +256,9 @@
             } else {
                 mc.getReplyTo().setAddress(replyToFromTransport.getAddress());
             }
+            //if dont do this , this guy will wait till its gets HTTP 202 in the case
+            //HTTP
+            mc.setProperty(MessageContext.TRANSPORT_NON_BLOCKING, Boolean.TRUE);
             AxisEngine engine = new AxisEngine(cc);
             engine.send(mc);
         } else {
---------------
-------------
@@ -108,7 +108,7 @@
      */
     public OMElementImpl(String localName, OMNamespace ns) {
         super(null);
-        if(localName == null || "".equals(localName)){
+        if(localName == null || localName.trim().length() == 0){
             throw new OMException("localname can not be null or empty");
         }
         this.localName = localName;
---------------
-------------
@@ -115,7 +115,7 @@
 
     public SuiteTagMatcher(String suiteTags, boolean matchIfNoTags, boolean andStrategy) {
       tagString = suiteTags;
-      if (suiteTags != null) {
+      if (StringUtils.isNotBlank(suiteTags)) {
         tags = Arrays.asList(suiteTags.split(LIST_SEPARATOR));
       }
       else {
---------------
-------------
@@ -4,6 +4,6 @@
 
 public class FitNesseVersion {
 	public String toString() {
-		return "v20090918";
+		return "v20090930";
 	}
 }
---------------
-------------
@@ -26,6 +26,7 @@
     addTableType("query:", QueryTable.class);
     addTableType("table:", TableTable.class);
     addTableType("script", ScriptTable.class);
+    addTableType("script:", ScriptTable.class);
     addTableType("scenario", ScenarioTable.class);
     addTableType("import", ImportTable.class);
     addTableType("library", LibraryTable.class);
---------------
-------------
@@ -9,7 +9,7 @@
 import static fitnesse.slim.SlimServer.*;
 
 public class SlimExceptionResult implements ExceptionResult {
-  public static final Pattern EXCEPTION_MESSAGE_PATTERN = Pattern.compile("^message:<<(.*)>>$", Pattern.DOTALL);
+  public static final Pattern EXCEPTION_MESSAGE_PATTERN = Pattern.compile("message:<<(.*)>>", Pattern.DOTALL);
 
   private final String resultKey;
   private final String exceptionValue;
---------------
-------------
@@ -26,6 +26,7 @@
     addTableType("query:", QueryTable.class);
     addTableType("table:", TableTable.class);
     addTableType("script", ScriptTable.class);
+    addTableType("script:", ScriptTable.class);
     addTableType("scenario", ScenarioTable.class);
     addTableType("import", ImportTable.class);
     addTableType("library", LibraryTable.class);
---------------
-------------
@@ -46,7 +46,7 @@
 	public void doSending(Response response) throws Exception
 	{
 		response.readyToSend(this);
-		waitForClose(50000);
+		waitForClose(5000);
 	}
 
 	// Utility method that returns when this.closed is true. Throws an exception
---------------
-------------
@@ -7,7 +7,7 @@
     
     public Comment() {
         super("Comment");
-        wikiMatcher(new Matcher().startLine().string("#"));
+        wikiMatcher(new Matcher().startLineOrCell().string("#"));
         wikiRule(this);
         htmlTranslation(this);
     }
---------------
-------------
@@ -33,7 +33,7 @@
   public String testResultsDirectoryName = "testResults";
   public boolean shouldCollectHistory = false;
   public boolean doNotChunk;
-  public String pageTheme = "straight";
+  public String pageTheme = "fitnesse_straight";
 
   public FitNesseContext() {
     this(null);
---------------
-------------
@@ -120,7 +120,7 @@
     logger.debug("");
 
     if (mode == Mode.TEST) {
-      configuration.put("tslLocation", "http://10.0.25.57/tsl/trusted-test-mp.xml");
+      configuration.put("tslLocation", "file:conf/trusted-test-tsl.xml");
       configuration.put("tspSource", "http://tsa01.quovadisglobal.com/TSS/HttpTspServer");
       configuration.put("validationPolicy", "conf/constraint.xml");
       configuration.put("pkcs11Module", "/usr/lib/x86_64-linux-gnu/opensc-pkcs11.so");
---------------
-------------
@@ -77,7 +77,7 @@
   }
 
   public String setOperaPath() {
-    String binaryPath = OperaPaths.operaPathNoEnv();
+    String binaryPath = OperaPaths.findOperaInstallationPath();
     assertNotNull("Could not find an Opera installation on this machine.", binaryPath);
     setEnvVariable("OPERA_PATH", binaryPath);
     return binaryPath;
---------------
-------------
@@ -77,7 +77,7 @@
   }
 
   public String setOperaPath() {
-    String binaryPath = OperaPaths.operaPathNoEnv();
+    String binaryPath = OperaPaths.findOperaInstallationPath();
     assertNotNull("Could not find an Opera installation on this machine.", binaryPath);
     setEnvVariable("OPERA_PATH", binaryPath);
     return binaryPath;
---------------
-------------
@@ -27,7 +27,7 @@
 
   @AfterClass
   public static void tearDownAfterClass() throws Exception {
-    driver.quit();
+      driver.quit();
   }
 
   // Easy access to fixtures
---------------
-------------
@@ -71,6 +71,7 @@
 	
 	@Override
 	protected Automaton createAutomaton() {
+		seq.addConditions(conditions);
 		return seq.toAutomaton().copy();
 	}
 	
---------------
-------------
@@ -213,7 +213,7 @@
         }
 
         // The prefix must be a valid XML Namespace prefix (i.e., a valid NCName) ...
-        if (!XmlCharacters.isValidName(prefix)) {
+        if (!XmlCharacters.isValidNcName(prefix)) {
             throw new NamespaceException(JcrI18n.unableToRegisterNamespaceWithInvalidPrefix.text(prefix, uri));
         }
 
---------------
-------------
@@ -312,7 +312,7 @@
         // Build up the map of aliases for the properties used in the criteria ...
         Map<String, String> propertyNameByAlias = new HashMap<String, String>();
         for (Column column : columns) {
-            if (!column.getColumnName().equals(column.getPropertyName())) {
+            if (column.getColumnName() != null && !column.getColumnName().equals(column.getPropertyName())) {
                 propertyNameByAlias.put(column.getColumnName(), column.getPropertyName());
             }
         }
---------------
-------------
@@ -458,7 +458,7 @@
                 }
 
                 NodeKey cloneKey = null;
-                if (!parentNode.isRoot()) {
+                if (!destPath.isRoot()) {
                     // Use the JCR add child here to perform the parent validations
                     cloneKey = parentNode.key().withId(sourceNode.key().getIdentifier());
                     parentNode.addChildNode(newNodeName, sourceNode.getPrimaryTypeName(), cloneKey, false, false);
---------------
-------------
@@ -213,7 +213,7 @@
         }
 
         // The prefix must be a valid XML Namespace prefix (i.e., a valid NCName) ...
-        if (!XmlCharacters.isValidName(prefix)) {
+        if (!XmlCharacters.isValidNcName(prefix)) {
             throw new NamespaceException(JcrI18n.unableToRegisterNamespaceWithInvalidPrefix.text(prefix, uri));
         }
 
---------------
-------------
@@ -228,6 +228,7 @@
 
         @Override
         public boolean hasNext() {
+            if (last != null) return true; // 'hasNext()' has been called multiple times before 'next()'
             while (super.hasNext()) {
                 last = super.next();
                 if (last.getName().equals(name)) return true;
---------------
-------------
@@ -912,7 +912,7 @@
         throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException,
         RepositoryException {
         checkSession();
-        return addNode(relPath, "nt:unstructured", null);
+        return addNode(relPath, null, null);
     }
 
     @Override
---------------
-------------
@@ -246,7 +246,7 @@
     }
 
     /**
-     * And interface that can be passed to this driver's contructor to create the JNDI naming context given the set of connection
+     * And interface that can be passed to this driver's constructor to create the JNDI naming context given the set of connection
      * properties.
      */
     public interface JcrContextFactory {
---------------
-------------
@@ -34,7 +34,7 @@
  * Instruction to remove the property with the supplied name from the node at the given location. This request has no net effect
  * if the node does not contain a property with the supplied name.
  */
-public class RemovePropertyRequest extends ChangeRequest {
+public class RemovePropertyRequest extends ChangeRequest implements PropertyChangeRequest {
 
     private static final long serialVersionUID = 1L;
 
---------------
-------------
@@ -562,7 +562,7 @@
             // this.repositoryTypeManager = new RepositoryNodeTypeManager(this, includeInheritedProperties);
             this.repositoryTypeManager = new RepositoryNodeTypeManager(this, includeInheritedProperties);
             this.repositoryTypeManager.registerNodeTypes(new CndNodeTypeSource(new String[] {
-                "/org/modeshape/jcr/jsr_283_builtins.cnd", "/org/modeshape/jcr/dna_builtins.cnd"}));
+                "/org/modeshape/jcr/jsr_283_builtins.cnd", "/org/modeshape/jcr/modeshape_builtins.cnd"}));
         } catch (RepositoryException re) {
             re.printStackTrace();
             throw new IllegalStateException("Could not load node type definition files", re);
---------------
-------------
@@ -692,8 +692,13 @@
         aliases.put("modelsequencer", modelSequencer);
         aliases.put("vdb", vdbSequencer);
         aliases.put("vdbsequencer", vdbSequencer);
-        aliases.put("msoffice", msofficeSequencer);
-        aliases.put("msofficesequencer", msofficeSequencer);
+        /**
+         * //TODO author=Horia Chiorean date=5/16/13 description=MODE-1934
+         *
+         * aliases.put("msoffice", msofficeSequencer);
+         * aliases.put("msofficesequencer", msofficeSequencer);
+         *
+         **/
         aliases.put("wsdl", wsdlSequencer);
         aliases.put("wsdlsequencer", wsdlSequencer);
         aliases.put("xsd", xsdSequencer);
---------------
-------------
@@ -1952,5 +1952,5 @@
         private void signalSaveOfSystemChanges() {
             cache().checkForTransaction();
         }
-    };
+    }
 }
---------------
-------------
@@ -29,7 +29,7 @@
 	    	return css;
 	    }
 		StringBuilder sb = new StringBuilder(css);
-		patternRewrite((ReplayParseContext)context, sb,cssUrlPattern, "cs_");
+		patternRewrite((ReplayParseContext)context, sb,cssUrlPattern, "im_");
 		patternRewrite((ReplayParseContext)context, sb,cssImportNoUrlPattern, 
 				"cs_");
 //		return "__BCSS__" + sb.toString() + "__BCSS__";
---------------
-------------
@@ -45,7 +45,7 @@
 			return JAR;
 		}
 		try {
-			return valueOf(typeCode);
+			return valueOf(typeCode.toUpperCase());
 		} catch (final IllegalArgumentException invalidCode) {
 			return OTHER;
 		}
---------------
-------------
@@ -24,7 +24,7 @@
 			return "_f";
 		} else if (type.equals(JavaType.DOUBLE_OBJECT) || type.equals(JavaType.DOUBLE_PRIMITIVE)) {
 			return "_d";
-		} else if (type.equals(new JavaType("java.util.Date")) || type.equals("java.util.Calendar")) {
+		} else if (type.equals(new JavaType("java.util.Date")) || type.equals(new JavaType("java.util.Calendar"))) {
 			return "_dt";
 		} else {
 			return "_t";
---------------
-------------
@@ -859,7 +859,7 @@
 	}
 	
 	public boolean isModuleFocusAllowed() {
-		return !getModuleNames().isEmpty();
+		return getModuleNames().size() > 1;
 	}
 	
 	public boolean isModuleCreationAllowed() {
---------------
-------------
@@ -107,7 +107,7 @@
 		// To get this far we need to create the method...
 		List<JavaType> parameters = new ArrayList<JavaType>();
 		parameters.add(destination);
-		JavaType typedQueryType = new JavaType(TYPED_QUERY.getSimpleTypeName(), 0, DataType.TYPE, null, parameters);
+		JavaType typedQueryType = new JavaType(TYPED_QUERY.getFullyQualifiedTypeName(), 0, DataType.TYPE, null, parameters);
 
 		QueryHolder queryHolder = queryHolders.get(finderName);
 		String jpaQuery = queryHolder.getJpaQuery();
---------------
-------------
@@ -590,7 +590,7 @@
 									}
 									if (paramType != null && candidate.supports(paramType, include.optionContext())) {
 										// Try to invoke this usable converter
-										candidate.convertFromText("*", null, include.optionContext());
+										candidate.convertFromText("*", paramType, include.optionContext());
 										// If we got this far, the converter is happy with "*" so we need not bother the user with entering the data in themselves
 										break;
 									}
---------------
-------------
@@ -88,7 +88,7 @@
             addError(errors, member, "must be static.");
         }
         if (!fStaticMembers && member.isStatic()) {
-            addError(errors, member, "must not be static.");
+            addError(errors, member, "must not be static or it has to be annotated with @ClassRule.");
         }
     }
 
---------------
-------------
@@ -69,7 +69,7 @@
         String value = properties.getProperty(key);
         if (value == null)
             return null;
-        return convert(method.getReturnType(), substitutor.replace(format(value, args)));
+        return convert(method.getReturnType(), format(substitutor.replace(value), args));
     }
 
     private Object delegate(Object target, Method method, Object... args) throws InvocationTargetException,
---------------
-------------
@@ -209,6 +209,7 @@
         propertyChangeListeners.add(listener);
     }
 
+    @Delegate
     public void removePropertyChangeListener(PropertyChangeListener listener) {
         propertyChangeListeners.remove(listener);
     }
---------------
-------------
@@ -30,7 +30,7 @@
   private ImmutableOrdinalSet() {
   }
 
-  private static final ImmutableOrdinalSet<?> EMPTY_SET = new EmptyImmutableOrdinalSet<>();
+  private static final ImmutableOrdinalSet<? extends OrdinalValue<?>> EMPTY_SET = new EmptyImmutableOrdinalSet<>();
 
   @SuppressWarnings("unchecked")
   public static <E extends OrdinalValue<E>> ImmutableOrdinalSet<E> of() {
---------------
-------------
@@ -19,7 +19,7 @@
 import org.immutables.annotation.GenerateImmutable;
 import org.immutables.common.collect.OrdinalValue;
 
-@GenerateImmutable(builder = false)
+@GenerateImmutable
 public abstract class SillyOrdinal implements OrdinalValue<SillyOrdinal> {
 
   @GenerateConstructorParameter
---------------
-------------
@@ -24,7 +24,7 @@
   }
 
   public LexerOutput(List<Token> tokens) {
-    this.tokens = tokens;
+    addAllTokens(tokens);
     this.preprocessors = null;
   }
 
---------------
-------------
@@ -41,6 +41,9 @@
             case REJECTED_SEMAPHORE_FALLBACK:
                 return true;
             case COMMAND_EXCEPTION:
+                //TODO: Remove this and set to false by default
+                //SocketTimeoutExceptions should be fixed by the application if they are being thrown within the context
+                //of a TenacityCommand
                 return exception.getCause() instanceof SocketTimeoutException;
             default:
                 return false;
---------------
-------------
@@ -41,6 +41,9 @@
             case REJECTED_SEMAPHORE_FALLBACK:
                 return true;
             case COMMAND_EXCEPTION:
+                //TODO: Remove this and set to false by default
+                //SocketTimeoutExceptions should be fixed by the application if they are being thrown within the context
+                //of a TenacityCommand
                 return exception.getCause() instanceof SocketTimeoutException;
             default:
                 return false;
---------------
-------------
@@ -268,7 +268,6 @@
      */
     public void killHard() {
         induceDeath = true;
-        interrupt();
     }
 
     /**
---------------
-------------
@@ -377,7 +377,7 @@
             if (dom.value!=null)
                 w.setValue(dom.value);
             else {
-                for (XStreamDOM c : dom.children) {
+                for (XStreamDOM c : Util.fixNull(dom.children)) {
                     marshal(c, w, context);
                 }
             }
---------------
-------------
@@ -855,9 +855,8 @@
      * Schedules a build of this project.
      *
      * @return
-     *      true if the project is actually added to the queue.
-     *      false if the queue contained it and therefore the add()
-     *      was noop
+     *      true if the project is added to the queue.
+     *      false if the task was rejected from the queue (such as when the system is being shut down.)
      */
     public boolean scheduleBuild(Cause c) {
         return scheduleBuild(getQuietPeriod(), c);
---------------
-------------
@@ -478,7 +478,7 @@
 
         @Override
         protected Lease decideWorkspace(Node n, WorkspaceList wsl) throws InterruptedException, IOException {
-            return wsl.allocate(getParentBuild().getModuleRoot().child(getProject().getRelativePath()));
+            return wsl.allocate(getModuleSetBuild().getModuleRoot().child(getProject().getRelativePath()));
         }
 
         protected Result doRun(BuildListener listener) throws Exception {
---------------
-------------
@@ -75,7 +75,7 @@
             dst = dst.substring(i + 1);
         }
 
-        ig.copy(src,dst);
+        ig.copy(src,dst).save();
         return 0;
     }
 }
---------------
-------------
@@ -166,7 +166,7 @@
         while(tokens.hasMoreTokens()) {
             String relativeName = tokens.nextToken().trim();
             String canonicalName = getCanonicalName(context, relativeName);
-            if (canonicalName.startsWith(oldFullName)) {
+            if (canonicalName.equals(oldFullName) || canonicalName.startsWith(oldFullName+'/')) {
                 String newCanonicalName = newFullName + canonicalName.substring(oldFullName.length());
                 // relative name points to the renamed item, let's compute the new relative name
                 newValue.add( computeRelativeNameAfterRenaming(canonicalName, newCanonicalName, relativeName) );
---------------
-------------
@@ -3520,7 +3520,7 @@
 
             for (Action a : getActions()) {
                 if (a instanceof UnprotectedRootAction) {
-                    if (rest.startsWith("/"+a.getUrlName()+"/"))
+                    if (rest.startsWith("/"+a.getUrlName()+"/") || rest.equals("/"+a.getUrlName()))
                         return this;
                 }
             }
---------------
-------------
@@ -85,6 +85,8 @@
     private static class WildCardItem implements Item {
 
         public int compareTo(Item item) {
+            if (item==null) // 1.* ( > 1.99) > 1
+                return 1;
             switch (item.getType()) {
                 case INTEGER_ITEM:
                 case LIST_ITEM:
---------------
-------------
@@ -113,7 +113,7 @@
         Mapper m = new CompatibilityMapper(new MapperWrapper(next) {
             @Override
             public String serializedClass(Class type) {
-                if (ImmutableMap.class.isAssignableFrom(type))
+                if (type != null && ImmutableMap.class.isAssignableFrom(type))
                     return super.serializedClass(ImmutableMap.class);
                 else
                     return super.serializedClass(type);
---------------
-------------
@@ -50,7 +50,7 @@
         return PollingResult.NO_CHANGES;
     }
 
-    public boolean checkout(AbstractBuild build, Launcher launcher, FilePath remoteDir, BuildListener listener, File changeLogFile) throws IOException, InterruptedException {
+    public boolean checkout(AbstractBuild<?,?> build, Launcher launcher, FilePath remoteDir, BuildListener listener, File changeLogFile) throws IOException, InterruptedException {
         return createEmptyChangeLog(changeLogFile, listener, "log");
     }
 
---------------
-------------
@@ -98,7 +98,7 @@
         @Override
         public SubText subText(int start, int end) {
             return MarkupText.this.subText(this.start+start,
-                    end<0 ? this.end+1+end : this.end+end);
+                    end<0 ? this.end+1+end : this.start+end);
         }
 
         @Override
---------------
-------------
@@ -1724,7 +1724,7 @@
      * to wrap line before any sequence of punctuation characters or anywhere
      * in the middle of prolonged sequences of word characters.
      *
-     * @since 1.516
+     * @since 1.517
      */
     public static String breakableString(final String plain) {
 
---------------
-------------
@@ -763,7 +763,7 @@
     /**
      * Reflect the submission of the pseudo 'upstream build trigger'.
      */
-    private void convertUpstreamBuildTrigger(Set<AbstractProject> upstream) throws IOException {
+    protected void convertUpstreamBuildTrigger(Set<AbstractProject> upstream) throws IOException {
 
         SecurityContext saveCtx = ACL.impersonate(ACL.SYSTEM);
         try {
---------------
-------------
@@ -305,7 +305,7 @@
       stream.skip(OUUIDSerializer.UUID_SIZE);
     }
 
-    stream.skip(delegate.deserialize(stream.bytes, stream.offset));
+    stream.skip(delegate.deserialize(stream.bytes, stream.offset) - stream.offset);
   }
 
   @Override
---------------
-------------
@@ -28,7 +28,7 @@
 
   private void resize() {
     int newLength = bytes.length;
-    while (newLength > offset)
+    while (newLength < offset)
       newLength *= 2;
     byte[] newBytes = new byte[newLength];
     System.arraycopy(bytes, 0, newBytes, 0, bytes.length);
---------------
-------------
@@ -117,7 +117,7 @@
 
     applyChanges(value, offset, end, result);
 
-    return OLongSerializer.INSTANCE.deserializeNative(value, offset);
+    return OLongSerializer.INSTANCE.deserializeNative(value, 0);
   }
 
   public void add(byte[] value, int start) {
---------------
-------------
@@ -305,7 +305,7 @@
       stream.skip(OUUIDSerializer.UUID_SIZE);
     }
 
-    stream.skip(delegate.deserialize(stream.bytes, stream.offset));
+    stream.skip(delegate.deserialize(stream.bytes, stream.offset) - stream.offset);
   }
 
   @Override
---------------
-------------
@@ -99,6 +99,7 @@
 
     public Response<String> discard() {
         client.discard();
+        currentMulti = null;
         return getResponse(BuilderFactory.STRING);
     }
 
---------------
-------------
@@ -59,7 +59,7 @@
     }
 
     public static int getCRC16(String key) {
-	return getCRC16(key.getBytes());
+	return getCRC16(SafeEncoder.encode(key));
     }
 
 }
\ No newline at end of file
---------------
-------------
@@ -65,6 +65,7 @@
             durationLogProcessorBean.setParentName(XMLConstants.DURATION_LOG_PROCESSOR);
 
             setBeanProperty(XMLConstants.GLOBAL_PERCENTILES_KEYS, percentilesElement, parserContext, durationLogProcessorBean.getBeanDefinition());
+            setBeanProperty(XMLConstants.TIME_WINDOW_PERCENTILES_KEYS, percentilesElement, parserContext, durationLogProcessorBean.getBeanDefinition());
 
             initStandardListeners(tlList, slList);
 
---------------
-------------
@@ -65,6 +65,7 @@
             durationLogProcessorBean.setParentName(XMLConstants.DURATION_LOG_PROCESSOR);
 
             setBeanProperty(XMLConstants.GLOBAL_PERCENTILES_KEYS, percentilesElement, parserContext, durationLogProcessorBean.getBeanDefinition());
+            setBeanProperty(XMLConstants.TIME_WINDOW_PERCENTILES_KEYS, percentilesElement, parserContext, durationLogProcessorBean.getBeanDefinition());
 
             initStandardListeners(tlList, slList);
 
---------------
-------------
@@ -86,6 +86,7 @@
 		amount = Math.min(amount, realCount);
 
         Target target = new TargetControlledPermanent(amount, amount, filter, false);
+        target.setRequired(true);
 
 		//A spell or ability could have removed the only legal target this player
 		//had, if thats the case this ability should fizzle.
---------------
-------------
@@ -94,7 +94,7 @@
 		Card card;
 		Player player = game.getPlayer(source.getControllerId());
 		ExileZone exile = game.getExile().createZone(source.getSourceId(), player.getName() + " Cascade");
-		int sourceCost = game.getObject(source.getSourceId()).getManaCost().convertedManaCost();
+		int sourceCost = game.getCard(source.getSourceId()).getManaCost().convertedManaCost();
 		do {
 			card = player.getLibrary().removeFromTop(game);
 			if (card == null)
---------------
-------------
@@ -221,6 +221,7 @@
         if (controller != null && controller.removeFromBattlefield(this, game)) {
             ZoneChangeEvent event = new ZoneChangeEvent(this, sourceId, ownerId, fromZone, Zone.EXILED);
             if (!game.replaceEvent(event)) {
+                game.rememberLKI(objectId, Zone.BATTLEFIELD, this);
                 if (exileId == null) {
                     game.getExile().getPermanentExile().add(card);
                 } else {
---------------
-------------
@@ -125,7 +125,7 @@
 	}
 
 	@Override
-	public void putDataPoint(String metricName, ImmutableSortedMap<String, String> tags, org.kairosdb.core.DataPoint dataPoint) throws DatastoreException
+	public synchronized void putDataPoint(String metricName, ImmutableSortedMap<String, String> tags, org.kairosdb.core.DataPoint dataPoint) throws DatastoreException
 	{
 		GenOrmDataSource.attachAndBegin();
 		try
---------------
-------------
@@ -125,7 +125,7 @@
 	}
 
 	@Override
-	public void putDataPoint(String metricName, ImmutableSortedMap<String, String> tags, org.kairosdb.core.DataPoint dataPoint) throws DatastoreException
+	public synchronized void putDataPoint(String metricName, ImmutableSortedMap<String, String> tags, org.kairosdb.core.DataPoint dataPoint) throws DatastoreException
 	{
 		GenOrmDataSource.attachAndBegin();
 		try
---------------
-------------
@@ -172,7 +172,7 @@
             if (line.equals("~~~~~~")) {
                 break;
             } else {
-                String[] parts = line.split("=");
+                String[] parts = line.split("=",2);
                 if (parts.length == 2) {
                     if (parts[0].equalsIgnoreCase("date")) {
                         DateFormat df = new SimpleDateFormat(config.getString(Keys.DATE_FORMAT));
---------------
-------------
@@ -75,7 +75,7 @@
 
         String storage = System.getProperty("storage.location");
         if (storage == null) {
-            System.err.println("System property 'storage.file' is not set. \n" +
+            System.err.println("System property 'storage.location' is not set. \n" +
         		"This property needs to be set to the full path of the instance.properties file.");
             exit(-1);
         }
---------------
-------------
@@ -1,12 +1,19 @@
 /*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless
- * required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
  * under the License.
  */
 package org.apache.felix.dm.test.annotation;
---------------
-------------
@@ -46,7 +46,7 @@
  *
  * @author japod
  */
-@XmlRootElement(name = "item")
+@XmlRootElement(name = "item2")
 public class TwoListsWrapperBean {
     public List<String> property1, property2;
     
---------------
-------------
@@ -426,7 +426,7 @@
                     this.password);
 
             // Get exact requested URI
-            String uri = request.getURI().getPath();
+            String uri = request.getURI().getRawPath();
 
 
             // Repeat URI in header
---------------
-------------
@@ -91,7 +91,7 @@
         
         try {    
             // Wait for the server to start
-            Thread.sleep(500); 
+            Thread.sleep(1000); 
         } catch (InterruptedException ex) {
             ex.printStackTrace();
         } 
---------------
-------------
@@ -5,6 +5,12 @@
 
 // parse message using default protocol
 public final class MessageIO {
+	/*
+	 * 
+	 * 
+	 * 
+	 */
+	
 	// server send: server -> client, write "from"
 	// server receive: server <- client, read "to"
 
---------------
-------------
@@ -3229,7 +3229,7 @@
         int beg = ts.tokenBeg;
         String s = ts.getString();
         int lineno = ts.lineno;
-        if (currentToken != Token.NAME) {
+        if (!"".equals(prevNameTokenString)) {
             beg = prevNameTokenStart;
             s = prevNameTokenString;
             lineno = prevNameTokenLineno;
---------------
-------------
@@ -333,7 +333,6 @@
                 lineno++;
                 sawEOL = true;
             } else {
-                sawEOL = false;
                 if (compilerEnv.isRecordingComments()) {
                     recordComment(lineno);
                 }
---------------
-------------
@@ -476,7 +476,7 @@
     @EndpointImplementation(Endpoints.STYLESHEET)
     public String getStylesheet(String subreddit) throws NetworkException {
         if (subreddit == null) throw new NullPointerException("subreddit cannot be null");
-        String path = subreddit + "/stylesheet";
+        String path = "/r/" + subreddit + "/stylesheet";
 
         HttpRequest r = request()
                 .path(path)
---------------
-------------
@@ -17,7 +17,7 @@
         String newUuid = json.optString("new_user_id"); //$NON-NLS-1$
         if (RemoteModel.isValidUuid(newUuid)) {
             Preferences.setString(ActFmPreferenceService.PREF_USER_ID, newUuid);
-            new ConvertSelfUserIdsToZero();
+            new ConvertSelfUserIdsToZero().execute();
         }
     }
 
---------------
-------------
@@ -56,7 +56,7 @@
 
 		int firstQuote = word.indexOf('"');
 
-		if (firstQuote > -1)
+		if (firstQuote > -1 && firstQuote < word.length() - 2)
 		{
 			if (isLegalPrefix(word.substring(0, firstQuote)))
 			{
---------------
-------------
@@ -256,7 +256,7 @@
                     }
 
                     appendCurrentChar = true;
-                } else if (!Character.isSpaceChar(c) && isRecognizedException(wordBuffer, length, c)) {
+                } else if (c != suffixForExactMatch && !Character.isSpaceChar(c) && isRecognizedException(wordBuffer, length, c)) {
                     startedDoingCustomToken = length;
                     tokenType |= TokenType.Custom;
                     appendCurrentChar = true;
---------------
-------------
@@ -93,7 +93,7 @@
 	// xpath for specific tests
 	protected static final String dateValidationXpath = "//input[contains(@id,':dateOfBirth')]/../child::node()";
 
-	static final String url = baseUrl + webContext + "/jsf2-spring";
+	static final String url = baseUrl + webContext + "/jsf2-html5";
 
 	@FindBy(xpath = formTagXpath)
 	private WebElement formTag;
---------------
-------------
@@ -27,7 +27,7 @@
     public CharacterSetGenerator(Range<Integer> range, CharacterFilter filter) {
         List<Character> chars = new LinkedList<Character>();
 
-        for (int i = range.lowerBound(); i < range.upperBound(); i++) {
+        for (int i = range.lowerBound(); i <= range.upperBound(); i++) {
             if (filter.includeCharacter(i)) {
                 chars.add((char) i);
             }
---------------
-------------
@@ -723,7 +723,7 @@
 
             if ( startOfFileName > -1 )
             {
-                file = file.substring( startOfFileName + 2 );
+                file = file.substring( startOfFileName + 1 + EOL.length() );
             }
 
             int line = Integer.parseInt( lineIndicator );
---------------
-------------
@@ -190,7 +190,7 @@
                 console.println(Messages.CopyArtifact_MissingProject(expandedProject));
                 return false;
             }
-            Run src = selector.getBuild(job, env, parameters != null ? new ParametersBuildFilter(parameters) : new BuildFilter(), build);
+            Run src = selector.getBuild(job, env, parameters != null ? new ParametersBuildFilter(env.expand(parameters)) : new BuildFilter(), build);
             if (src == null) {
                 console.println(Messages.CopyArtifact_MissingBuild(expandedProject));
                 return isOptional();  // Fail build unless copy is optional
---------------
-------------
@@ -15,7 +15,7 @@
     edu.mit.civic.mediacloud.test.where.HandCodedDisambiguationTest.class,
     edu.mit.civic.mediacloud.test.where.substitutions.WikipediaDemonymMapTest.class,
     edu.mit.civic.mediacloud.test.MuckUtilsTest.class,
-    edu.mit.mediacloud.test.who.disambiguation.KindaDumbDisambiguationTest.class
+    edu.mit.civic.mediacloud.test.who.disambiguation.KindaDumbDisambiguationTest.class
 })
 public class AllTestsSuite {
 }
---------------
-------------
@@ -34,7 +34,8 @@
 import static org.junit.Assert.*;
 import static org.junit.Assume.*;
 
-/**
+/** Unit test for the issue #84: Problem with calling killMe in Initialize behavior of an agent.
+ *
  * @author $Author: sgalland$
  * @version $FullVersion$
  * @mavengroupid $GroupId$
---------------
-------------
@@ -90,7 +90,7 @@
         @Override
         public void check(@Nullable final String argument)
         {
-            BUNDLE.checkNotNull("loadingCfg.nullScheme", argument);
+            BUNDLE.checkNotNull(argument, "loadingCfg.nullScheme");
             final String errmsg = BUNDLE.printf("loadingCfg.illegalScheme",
                 argument);
             if (argument.isEmpty())
---------------
-------------
@@ -425,7 +425,8 @@
             timeZone = TimeZone.getTimeZone("UTC");
         }
         Calendar cal = Calendar.getInstance(timeZone);
-        cal.set(year, month, day, hour, minute, wholeSeconds);
+        //In Java Calendar, month is zero-based, so subtract one
+        cal.set(year, month - 1, day, hour, minute, wholeSeconds);
         cal.set(Calendar.MILLISECOND, Math.round(fractionalSeconds * 1000f));
         return cal;
     }
---------------
-------------
@@ -7,7 +7,6 @@
 import org.apache.http.StatusLine;
 import org.apache.http.client.fluent.Content;
 import org.apache.http.client.fluent.Request;
-import org.apache.http.client.fluent.Response;
 
 import java.io.IOException;
 import java.io.InputStream;
---------------
-------------
@@ -1283,6 +1283,7 @@
 		try {
 			datalen = Integer.parseInt(sdatalen);
 		} catch (NumberFormatException nfe) {
+			//FIXME: Send error message
 			datalen = 0;
 		}
 		
---------------
-------------
@@ -1,4 +1,4 @@
-//generated using Reflections JavaCodeSerializer [Sun Feb 10 19:42:00 EST 2013]
+//generated using Reflections JavaCodeSerializer [Sun Feb 24 11:57:47 EST 2013]
 package org.jboss.errai.reflections;
 
 import static org.jboss.errai.reflections.serializers.JavaCodeSerializer.*;
---------------
-------------
@@ -209,7 +209,7 @@
       return null;
     }
 
-    return MetaClassFactory.get(type.getEnclosingType());
+    return MetaClassFactory.get(type.getSuperclass());
   }
 
   @Override
---------------
-------------
@@ -58,7 +58,7 @@
   public static <V> Set<V> findNodesWithNoOutgoingEdges(Digraph<V> g) {
     Set<V> s = new HashSet<V>();
     for (V node : g.getNodes()) {
-      if (g.nodesReferencing(node).isEmpty()) {
+      if (g.nodesReferencedFrom(node).isEmpty()) {
         s.add(node);
       }
     }
---------------
-------------
@@ -588,6 +588,4 @@
       results.addAll(QuickDeps.getQuickTypeDependencyList(new String(sourceBuffer), null));
     }
   }
-
-
 }
---------------
-------------
@@ -91,7 +91,7 @@
     String toReturn = builder.toString().replaceAll("new (String|int|float|double|boolean|byte|short)\\[\\]", "");
 
     if (elements.size() == 1 && "value".endsWith(lastMethodRendered)) {
-      toReturn = toReturn.replaceFirst("(\\s)+value =(\\s)+", "");
+      toReturn = toReturn.replaceFirst("(\\s)*value =(\\s)+", "");
     }
 
     return toReturn;
---------------
-------------
@@ -64,6 +64,7 @@
     return BeforeShutdown.class;
   }
 
+
   public Set<Annotation> getObservedQualifiers() {
     Set<Annotation> qualifiers = new HashSet<Annotation>();
     return qualifiers;
---------------
-------------
@@ -445,7 +445,7 @@
       name = type.getFullyQualifiedName();
     }
 
-    if (isPrimitive()) {
+    if (isPrimitive() || (isArray() && getComponentType().isPrimitive())) {
       if ("int".equals(name)) {
         name = "I";
       }
---------------
-------------
@@ -1,3 +1,19 @@
+/**
+ * Licensed to the Austrian Association for Software Tool Integration (AASTI)
+ * under one or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information regarding copyright
+ * ownership. The AASTI licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.openengsb.ui.common.workflow;
 
 import java.util.List;
---------------
-------------
@@ -126,7 +126,7 @@
             processBag = new ProcessBag();
             parameterMap.put("processBag", processBag);
         } else { 
-            processBag = (ProcessBag)parameterMap.get("processBag");
+            processBag = (ProcessBag) parameterMap.get("processBag");
         }            
         processInstance = session.startProcess(processId, parameterMap);
         processBag.setProcessId(String.valueOf(processInstance.getId()));
---------------
-------------
@@ -144,6 +144,7 @@
                         temp.add(obj);
                     }
                     objects.put(propertyName, new OpenEngSBModelEntry(propertyName, temp, entry.getType()));
+                    break;
                 }
             }
         } else {
---------------
-------------
@@ -374,7 +374,7 @@
             }
         }
         Class<?> modelType = model.getClass();
-        object.putEDBObjectEntry(EDBConstants.MODEL_TYPE, modelType.toString(), String.class);
+        object.putEDBObjectEntry(EDBConstants.MODEL_TYPE, modelType.getName(), String.class);
         object.putEDBObjectEntry("domainId", info.getDomainId(), String.class);
         object.putEDBObjectEntry("connectorId", info.getConnectorId(), String.class);
         object.putEDBObjectEntry("instanceId", info.getInstanceId(), String.class);
---------------
-------------
@@ -1,3 +1,19 @@
+/**
+ * Licensed to the Austrian Association for Software Tool Integration (AASTI)
+ * under one or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information regarding copyright
+ * ownership. The AASTI licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.openengsb.infrastructure.jms.internal;
 
 import java.io.File;
---------------
-------------
@@ -40,7 +40,7 @@
         List<Method> result = new ArrayList<Method>();
         for (Class<?> serviceInterface : service.getClass().getInterfaces()) {
             if (Domain.class.isAssignableFrom(serviceInterface)) {
-                result.addAll(Arrays.asList(serviceInterface.getMethods()));
+                result.addAll(Arrays.asList(serviceInterface.getDeclaredMethods()));
             }
         }
         return result;
---------------
-------------
@@ -59,7 +59,7 @@
         ServiceReference[] allServiceReferences;
         try {
             allServiceReferences = bundleContext.getAllServiceReferences(Domain.class.getName(),
-                    String.format("&(openengsb.service.type=domain)(id=domains.%s)", name));
+                    String.format("(&(openengsb.service.type=domain)(id=domains.%s))", name));
         } catch (InvalidSyntaxException e) {
             throw new IllegalStateException(e);
         }
---------------
-------------
@@ -42,7 +42,7 @@
     private static String artifactId;
     private static String version;
 
-    private static OpenEngSBMavenPluginNSContext nsContext = new OpenEngSBMavenPluginNSContext();
+    protected static OpenEngSBMavenPluginNSContext nsContext = new OpenEngSBMavenPluginNSContext();
 
     protected String invocation;
 
---------------
-------------
@@ -42,7 +42,7 @@
     private static String artifactId;
     private static String version;
 
-    private static OpenEngSBMavenPluginNSContext nsContext = new OpenEngSBMavenPluginNSContext();
+    protected static OpenEngSBMavenPluginNSContext nsContext = new OpenEngSBMavenPluginNSContext();
 
     protected String invocation;
 
---------------
-------------
@@ -16,7 +16,6 @@
     @Nullable E get(String property, @NotNull Object o);
     @Nullable List<E> getList(String property, @NotNull Object o);
 
-    @Nullable
     List<E> getLike(String property, @NotNull String value, MatchMode matchMode);
 
     void remove(@NotNull Serializable id);
---------------
-------------
@@ -65,7 +65,7 @@
         }
 
         if (text.isEmpty()){
-            return new String[]{""};
+            return new String[]{"",""};
         }
 
         String[] resultOfRemoveQuestion = new String[2];
---------------
-------------
@@ -17,7 +17,6 @@
 
         newContext = cleanChapter(value);
         newContext = cleanSection(newContext);
-        //System.out.println(newContext);
         return newContext;
     }
 
---------------
-------------
@@ -119,7 +119,7 @@
             uriJQL = jqlBuilder.toString();
         }
 
-        URI result = UriBuilder.fromPath(QUERY_URI_PATH).resolveTemplate("protocol", "https")
+        URI result = UriBuilder.fromPath(QUERY_URI_PATH).resolveTemplate("protocol", protocol)
                 .resolveTemplate("hostname", hostname).queryParam(QUERY_PARAM, uriJQL).build();
         // TODO setting issue limit, see issue#15 for more details
         // result += "&maxResults=300";
---------------
-------------
@@ -50,6 +50,7 @@
 			newCompleteType += completeType;
 			newCompleteType += ")";
 			completeType = newCompleteType;
+			parameter_id = parameter_id.parameter_id();
 		}
 		
 	}
---------------
-------------
@@ -26,6 +26,8 @@
 			setRight(expression);
 		else
 			throw new RuntimeException("Error: attempting to add third child to binary expression");
+	
+		super.addChild(item);
 	}
 	
 	@Override
---------------
-------------
@@ -58,7 +58,7 @@
 	 * @return the transaction
 	 */
 	public static Transaction get(){
-		if(cacheTransaction.get()==null){
+		if(cacheTransaction.get()==null || cacheTransaction.get().getStatus()==TransactionStatus.COMPLETED){
 			cacheTransaction.set(new CacheTransaction(transactionCounter++));
 		}
 		return cacheTransaction.get();
---------------
-------------
@@ -61,7 +61,7 @@
   // public HadoopShim HadoopConfiguration#getHadoopShim()
   private Method getHadoopShim;
 
-  protected ClassLoader findBigDataPluginClassLoader() throws Exception {
+  ClassLoader findBigDataPluginClassLoader() throws Exception {
     Method findPluginById = null;
     Object pluginRegistry = null;
     Method getClassLoader = null;
---------------
-------------
@@ -38,6 +38,6 @@
 
   @Override
   public byte[] convert(ValueMetaInterface meta, BytesWritable obj) throws TypeConversionException {
-    return obj.getBytes();
+    return obj.getBytes().clone();
   }
 }
---------------
-------------
@@ -61,7 +61,7 @@
   // public HadoopShim HadoopConfiguration#getHadoopShim()
   private Method getHadoopShim;
 
-  protected ClassLoader findBigDataPluginClassLoader() throws Exception {
+  ClassLoader findBigDataPluginClassLoader() throws Exception {
     Method findPluginById = null;
     Object pluginRegistry = null;
     Method getClassLoader = null;
---------------
-------------
@@ -67,7 +67,7 @@
    * @return {@code true} if the class should be ignored by this class loader
    */
   protected boolean ignoreClass(String name) {
-    if (loadClassesFromParent.contains(name)) {
+    if (name == null || loadClassesFromParent.contains(name)) {
       return true;
     }
     for (String prefix : loadClassesFromParent) {
---------------
-------------
@@ -81,7 +81,7 @@
 	@Override
 	public String toString(int p) {
 		return format("%s: %7d/%7d (%1.4f), RAVE %7d/%7d (%1.4f)\n",
-				pointToString(p), getWins(p), getRuns(p), getWinRate(p), 
+				pointToString(p), (int) getWins(p), getRuns(p), getWinRate(p), 
 				(int) getRaveWins(p), (int) raveRuns[p],
 				raveWinRates[p]);
 	}
---------------
-------------
@@ -124,7 +124,7 @@
     }
 
     public Path getChunkPath(Vector3i chunkPos) {
-        return worldsPath.resolve(getChunkFilename(chunkPos));
+        return worldPath.resolve(getChunkFilename(chunkPos));
     }
 
     public Path getChunkTempPath(Vector3i chunkPos) {
---------------
-------------
@@ -52,6 +52,7 @@
         HtmlInput input = getInput(page);
         page = (HtmlPage) input.setValueAttribute(value);
         page = submit(page);
+        System.out.println(page.asXml());
         checkMessage(page, "uiMessage", matcher);
         return page;
     }
---------------
-------------
@@ -63,7 +63,7 @@
      */
     public VisitResult visit(VisitContext context, UIComponent target) {
         String metaComponentId = (String) ctx.getAttributes().get(ExtendedVisitContext.META_COMPONENT_ID);
-        if (metaComponentId != null) {
+        if (metaComponentId != null && target instanceof MetaComponentEncoder) {
             MetaComponentEncoder encoder = (MetaComponentEncoder) target;
             try {
                 encoder.encodeMetaComponent(ctx, metaComponentId);
---------------
-------------
@@ -1562,7 +1562,7 @@
 					c >>= '\004';
 					byte byte3 = (byte) (c & 0xf);
 					c >>= '\004';
-					stringbuffer.append("\\U");
+					stringbuffer.append("\\u");
 					stringbuffer.append(this._hexDigitForNibble(byte3));
 					stringbuffer.append(this._hexDigitForNibble(byte2));
 					stringbuffer.append(this._hexDigitForNibble(byte1));
---------------
-------------
@@ -56,7 +56,7 @@
 
     //set header with base64 string here
     public void setFilterDirectorValues() {
-        if (validToken) {
+        if (validToken && filterDirector.getResponseStatus() != HttpStatusCode.INTERNAL_SERVER_ERROR) {
             filterDirector.setFilterAction(FilterAction.PASS);
             setExtendedAuthorization();
             setUser();
---------------
-------------
@@ -19,7 +19,7 @@
    }
 
    public void writeLimitsResponse(byte[] readableContents, MediaType mediaType, OutputStream outputStream) throws IOException {
-      if (MediaType.APPLICATION_XML.equals(mediaType)) {
+      if (MediaType.APPLICATION_XML.equals(mediaType.toString())) {
          outputStream.write(readableContents);
       } else {
          // default to json for now
---------------
-------------
@@ -56,7 +56,7 @@
 
     //set header with base64 string here
     public void setFilterDirectorValues() {
-        if (validToken) {
+        if (validToken && filterDirector.getResponseStatus() != HttpStatusCode.INTERNAL_SERVER_ERROR) {
             filterDirector.setFilterAction(FilterAction.PASS);
             setExtendedAuthorization();
             setUser();
---------------
-------------
@@ -19,7 +19,7 @@
    }
 
    public void writeLimitsResponse(byte[] readableContents, MediaType mediaType, OutputStream outputStream) throws IOException {
-      if (MediaType.APPLICATION_XML.equals(mediaType)) {
+      if (MediaType.APPLICATION_XML.equals(mediaType.toString())) {
          outputStream.write(readableContents);
       } else {
          // default to json for now
---------------
-------------
@@ -45,7 +45,7 @@
         }
 
         this.nextReadableIndex = 0;
-        this.nextWritableIndex = 0;
+        this.nextWritableIndex = readableLength;
         this.hasElements = byteBuffer.available() > 0;
     }
 
---------------
-------------
@@ -70,7 +70,7 @@
             try {
                 myDirector.requestHeaderManager().putHeader(PowerApiHeader.ROUTE_DESTINATION.headerKey(), HostUtilities.asUrl(nextRoutableHost, request.getRequestURI()));
             } catch (MalformedURLException murle) {
-                // TODO: Malformed URL Expcetions are unexpected and should return as a 502
+                // Malformed URL Expcetions are unexpected and should return as a 502
                 LOG.error(murle.getMessage(), murle);
                 
                 myDirector.setFilterAction(FilterAction.RETURN);
---------------
-------------
@@ -72,7 +72,7 @@
             );
         }
         this.key = server.getUsername().trim();
-        if (!this.key.matches("[A-F0-9]{20}")) {
+        if (!this.key.matches("[A-Z0-9]{20}")) {
             throw new MojoFailureException(
                 String.format(
                     "Key '%s' for server '%s' is not a valid AWS key",
---------------
-------------
@@ -65,7 +65,7 @@
         return this.wrap(
             point,
             method,
-            point.getTarget().getClass().getAnnotation(Loggable.class)
+            method.getDeclaringClass().getAnnotation(Loggable.class)
         );
     }
 
---------------
-------------
@@ -174,6 +174,8 @@
 
 		panel.add(new JLabel("User"));
 		final JTextField user = new JTextField();
+		user.setColumns(20);
+		panel.add(user);
 
 		if (JOptionPane.showConfirmDialog(null, panel, title,
 			JOptionPane.OK_CANCEL_OPTION) == JOptionPane.CANCEL_OPTION) return null;
---------------
-------------
@@ -243,7 +243,7 @@
 
 	public void setLocalVersion(final String checksum, final long timestamp) {
 		if (current != null && checksum.equals(current.checksum)) {
-			status = Status.INSTALLED;
+			if (status != Status.LOCAL_ONLY) status = Status.INSTALLED;
 			setNoAction();
 			return;
 		}
---------------
-------------
@@ -133,6 +133,7 @@
 	}
 
 	private void positionToPlane(int pNum) {
+		if (planeDims.length == 0) return; // already there
 		IntervalIndexer.indexToPosition(pNum - 1, planeDims, planePos);
 		int j = 0;
 		for (int i = 0; i < pos.length; i++) {
---------------
-------------
@@ -320,7 +320,7 @@
 	}
 
 	public void removeDependency(final String other) {
-		dependencies.remove(other);
+		dependencies.remove(getFilename(other, true));
 	}
 
 	public boolean hasDependency(final String filename) {
---------------
-------------
@@ -34,7 +34,7 @@
 		int value = this.shorts[(int)index];
 		
 		if (value < 0)
-			value += 65536 + value;
+			value = 65536 + value;
 		
 		return value;
 	}
---------------
-------------
@@ -21,6 +21,7 @@
 		{
 			value = Math.sqrt(sum1*sum1 + sum2*sum2) + 0.5;
 			value = Math.floor(value);
+			value = TypeManager.boundValueToType(sample, value);
 		}
 		else
 			value = Math.sqrt(sum1*sum1 + sum2*sum2);
---------------
-------------
@@ -205,7 +205,7 @@
       for (String value : valuesOrEmpty(headers, field)) {
         String resolved;
         if (value.indexOf('{') == 0) {
-          resolved = String.valueOf(unencoded.get(field));
+          resolved = expand(value, unencoded);
         } else {
           resolved = value;
         }
---------------
-------------
@@ -68,7 +68,7 @@
 		try {
 			paramType = (ParameterizedType) type;
 		} catch (ClassCastException cause) {
-			paramType = (ParameterizedType) ((Class<T>) type).getGenericSuperclass();
+			return getGenericTypeArgument((Class<T>) type, idx);
 		}
 
 		return (Class<T>) paramType.getActualTypeArguments()[idx];
---------------
-------------
@@ -72,7 +72,7 @@
         //  Remove square brackets around the address, if any.
         if (addr_str.length () >= 2 && addr_str.charAt(0) == '[' &&
               addr_str.charAt(addr_str.length () - 1) == ']')
-            addr_str = addr_str.substring (1, addr_str.length () - 2);
+            addr_str = addr_str.substring (1, addr_str.length () - 1);
 
         int port;
         //  Allow 0 specifically, to detect invalid port error in atoi if not
---------------
-------------
@@ -72,7 +72,7 @@
         //  Remove square brackets around the address, if any.
         if (addr_str.length () >= 2 && addr_str.charAt(0) == '[' &&
               addr_str.charAt(addr_str.length () - 1) == ']')
-            addr_str = addr_str.substring (1, addr_str.length () - 2);
+            addr_str = addr_str.substring (1, addr_str.length () - 1);
 
         int port;
         //  Allow 0 specifically, to detect invalid port error in atoi if not
---------------
-------------
@@ -499,7 +499,7 @@
             cdSet = ConvertableAnnotationRetriever.retrieveAnnotation(ContextDataSet.class, target.type.getAnnotations());
             target.name = cd == null ? "" : cd.name();
             target.scope = cd == null ? "" : cd.scope();
-            target.typeUnMatch = cd == null ? TypeUnMacthPolicy.DEFAULT_VALUE : cd.typeUnMatch();
+            target.typeUnMatch = cd == null ? TypeUnMacthPolicy.EXCEPTION : cd.typeUnMatch();
             if (StringUtils.isEmpty(target.name)) {
                 target.name = parameterNames[i];
             }
---------------
-------------
@@ -568,7 +568,7 @@
 	    {
 	        if( node == parentNode.left )
 	        {
-	            parentNode.left = null;
+	            parentNode.left = node.left;
 	        }
 	        else if( node == parentNode.right )
 	        {
---------------
-------------
@@ -69,7 +69,7 @@
     public synchronized void contextEnd( ReplicationContext ctx ) throws Exception
     {
         // Reset the mark if the context has the unfinished transaction.
-        if ( !ctx.getPeer().equals( replicaInTransaction ) )
+        if ( ctx.getPeer() != null && ctx.getPeer().equals( replicaInTransaction ) )
         {
             replicaInTransaction = null;
         }
---------------
-------------
@@ -156,7 +156,7 @@
             // explicitly managed by this code.  Value serialization is delegated to these
             // marshallers.
 
-            bt = BTree.createInstance( recMan, keyComparator, keySerializer, valueSerializer );
+            bt = BTree.createInstance( recMan, keyComparator, keySerializer, null );
             recId = bt.getRecid();
             recMan.setNamedObject( name, recId );
             recId = recMan.insert( 0 );
---------------
-------------
@@ -42,7 +42,7 @@
         setObsolete( false );
         addName( "bogus" );
         setDescription( "bogus" );
-        setSchemaName( "bogus" );
+        setSchemaName( "other" );
     }
 
 
---------------
-------------
@@ -130,7 +130,7 @@
 
         // Annotate the node with the optimizer and return search enumeration.
         optimizer.annotate( root );
-        return cursorBuilder.build( root );
+        return ( IndexCursor<Long, ServerEntry> ) cursorBuilder.build( root );
     }
 
 
---------------
-------------
@@ -239,7 +239,7 @@
             buf.append( "Source: {#SourceBase}\\lib\\" );
             File artifact = ( ( Artifact ) artifacts.get( ii ) ).getFile();
             buf.append( artifact.getName() );
-            buf.append( "; DestDir: {app}; DestName: " );
+            buf.append( "; DestDir: {app}\\lib; DestName: " );
             buf.append( artifact.getName() );
             buf.append( "\n" );
         }
---------------
-------------
@@ -342,7 +342,7 @@
                 apDn.remove( apDn.size() - 1 );
                 SubtreeSpecification ss = ( SubtreeSpecification ) subtrees.get( subentryDn );
 
-                if ( evaluator.evaluate( ss, apDn, subentryDn, objectClasses ) )
+                if ( evaluator.evaluate( ss, apDn, normName, objectClasses ) )
                 {
                     Attribute administrativeRole = nexus.lookup( apDn ).get( "administrativeRole" );
                     NamingEnumeration roles = administrativeRole.getAll();
---------------
-------------
@@ -62,6 +62,7 @@
         {
             this.blacklists.add( new HashSet<Long>() );
         }
+        this.cursorIndex = 0;
     }
 
 
---------------
-------------
@@ -75,6 +75,7 @@
 	    {
 	      root = new LinkedAvlNode<K>( key );
 	      first = root;
+	      last = root;
 	      return;
 	    }
 	    
---------------
-------------
@@ -42,7 +42,7 @@
     public static final String TEST_SRC_DIR = "src/test/java";
     public static final String TEST_RESOURCES_DIR = "src/test/resources";
 
-    public static final String NODE_VERSION = "0.10.29";
+    public static final String NODE_VERSION = "0.10.30";
     public static final String NODE_VERSION_ARM = "0.10.26";
     public static final String NPM_VERSION = "1.4.12";
 
---------------
-------------
@@ -21,7 +21,7 @@
         final int numEntries = f.getEntries().size();
 
         if (numEntries > 0) {
-            final String nextMarker = f.getEntries().get(numEntries).getId().toString(), previousMarker = f.getEntries().get(0).getId().toString();
+            final String nextMarker = f.getEntries().get(numEntries-1).getId().toString(), previousMarker = f.getEntries().get(0).getId().toString();
 
             final String self = StringUtilities.join(rc.getBaseUri().toString(), rc.getTargetPath());
 
---------------
-------------
@@ -134,7 +134,7 @@
         try {
             final String pageSizeString = getFeedRequest.getPageSize();
 
-            if ((StringUtils.isNotBlank(pageSizeString)) && (Integer.parseInt(pageSizeString) <= 0) && (Integer.parseInt(pageSizeString) <= 1000)) {
+            if ((StringUtils.isNotBlank(pageSizeString)) && ((Integer.parseInt(pageSizeString) <= 0) && (Integer.parseInt(pageSizeString) > 1000))) {
                 return ProviderHelper.badrequest(request, LIMIT_ERROR_MESSAGE);
             }
         } catch (NumberFormatException nfe) {
---------------
-------------
@@ -66,7 +66,7 @@
 
     public Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {
     	OFMessage outMessage;
-    	HubType ht = HubType.USE_FLOW_MOD;
+    	HubType ht = HubType.USE_PACKET_OUT;
     	switch (ht) {
     	case USE_FLOW_MOD:
             outMessage = createHubFlowMod(sw, msg);
---------------
-------------
@@ -812,7 +812,7 @@
 	 *    - use the switch driver to bind the switch and get an IOFSwitch
 	 *      instance, setup the switch instance
 	 *    - setup the IOFSwitch instance
-	 *    - add switch to FloodlightProvider and send the intial role
+	 *    - add switch to FloodlightProvider and send the initial role
 	 *      request to the switch.
 	 *
 	 * Next state: WaitOFAuxCxnsReplyState (if OF1.3), else
---------------
-------------
@@ -366,7 +366,7 @@
         return "Device [dataLayerAddress=" + 
                 dlAddrString +
                 ", attachmentPoints=" + attachmentPoints + ", networkAddresses="
-                + IPv4.fromIPv4AddressCollection(networkAddresses.keySet()) + "]";
+                + "[" + IPv4.fromIPv4AddressCollection(networkAddresses.keySet()) + "]";
     }
 
     public Date getLastSeenInStorage() {
---------------
-------------
@@ -76,7 +76,7 @@
 		}};
 	
 	/** {@link Pattern} which matches a binding configuration part */
-	private static final Pattern BASE_CONFIG_PATTERN = Pattern.compile("(<|>)\\[(.*?)\\]");
+	private static final Pattern BASE_CONFIG_PATTERN = Pattern.compile("(<|>)\\[(.*?)\\](\\s|$)");
 	
 	/** {@link Pattern} which matches an In-Binding */
 	private static final Pattern IN_BINDING_PATTERN = Pattern.compile("(.*?):(?!//)(\\d*):(.*)");
---------------
-------------
@@ -48,7 +48,7 @@
     private static final Logger logger = getLogger(FedoraRepository.class);
     
     @Inject
-    private ObjectService objectService;
+    ObjectService objectService;
 
     @GET
     @Path("modeshape")
---------------
-------------
@@ -90,7 +90,7 @@
                 nsTriples.add(create(nsSubject, HAS_NAMESPACE_PREFIX.asNode(),
                         createLiteral(prefix)));
                 nsTriples.add(create(nsSubject, HAS_NAMESPACE_URI.asNode(),
-                        createLiteral(nsURI)));
+                        createLiteral(rdfNsUri)));
             }
         }
         concat(nsTriples.build()).namespaces(namespaces.build());
---------------
-------------
@@ -25,7 +25,6 @@
 import com.fasterxml.jackson.annotation.JsonManagedReference;
 import com.fasterxml.jackson.annotation.JsonProperty;
 import com.google.common.base.Objects;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
 import com.kylinolap.common.KylinConfig;
 import com.kylinolap.common.persistence.ResourceStore;
---------------
-------------
@@ -61,13 +61,6 @@
      */
     public static final boolean BugOlap4j3126853Fixed = false;
 
-    /**
-     * Whether
-     * <a href="http://sourceforge.net/tracker/?func=detail&aid=3312701&group_id=168953&atid=848534">bug 3312701,
-     * "ConnectionTest.testVirtualCubeCmBug hangs"</a>
-     * is fixed.
-     */
-    public static final boolean BugOlap4j3312701Fixed = false;
 }
 
 // End Bug.java
---------------
-------------
@@ -1868,6 +1868,7 @@
 		align.fSpaceBetweenEmptyParen= preferences.insert_space_between_empty_parens_in_method_invocation;
 		align.fSpaceBeforeComma= preferences.insert_space_before_comma_in_method_invocation_arguments;
 		align.fSpaceAfterComma= preferences.insert_space_after_comma_in_method_invocation_arguments;
+		align.fTieBreakRule = Alignment.R_OUTERMOST;
 		formatList(expressions, align, true, false);
 	}
 
---------------
-------------
@@ -33,7 +33,6 @@
 			addTest(XlcLRCompleteParser2Tests.suite());
 			addTest(XlcLRCompletionBasicTest.suite());	
 			addTest(XlcLRCompletionParseTest.suite());
-			addTest(XlcLRCPPSpecFailingTest.suite());
 			addTest(XlcLRCPPSpecTest.suite());
 			addTest(XlcLRCPPTests.suite()); 
 			addTest(XlcLRCSpecTests.suite()); // a couple of failures
---------------
-------------
@@ -1606,6 +1606,7 @@
 		case Token.tRBRACE:
 		case Token.tLBRACE:
 			formatBrace = true;
+			lastLineComment.contiguous = false;
 		}
 		try {
 			printComment();
---------------
-------------
@@ -197,7 +197,7 @@
         TestResult r = new TestResult();
         super.run(r);
         if (r.failureCount() == 1) {
-        	TestFailure failure= (TestFailure) r.failures().nextElement();
+        	TestFailure failure= r.failures().nextElement();
         	String msg= failure.exceptionMessage();
         	if (msg != null && msg.startsWith("Method \"" + getName() + "\"")) {
         		result.addFailure(this, new AssertionFailedError(msg));
---------------
-------------
@@ -2134,9 +2134,9 @@
                 .getName());
     }
 
-    // test C99: 6.7.5.3-7 A declaration of a parameter as ��array of type��
-    // shall be adjusted to ��qualified pointer to
-    // type��, where the type qualifiers (if any) are those specified within the
+    // test C99: 6.7.5.3-7 A declaration of a parameter as ''array of type''
+    // shall be adjusted to ''qualified pointer to
+    // type'', where the type qualifiers (if any) are those specified within the
     // [ and ] of the
     // array type derivation.
     public void testArrayTypeToQualifiedPointerTypeParm() throws Exception {
---------------
-------------
@@ -110,7 +110,7 @@
   private String getServiceName(SubsetConfiguration conf) {
     String serviceNamePrefix = conf.getString(SERVICE_NAME_PREFIX, "");
     return serviceNamePrefix.isEmpty() ? getFirstConfigPrefix(conf) :
-      serviceNamePrefix + "-" + getFirstConfigPrefix(conf);
+           serviceNamePrefix + "-" + getFirstConfigPrefix(conf);
   }
 
   private String getFirstConfigPrefix(SubsetConfiguration conf) {
---------------
-------------
@@ -750,7 +750,7 @@
     String tag = readWord();
     try {
       int radix = 10;
-      if (tag.startsWith("0x")) {
+      if (tag.startsWith("0x") || tag.startsWith("0X")) {
         tag = tag.substring("0x".length());
         radix = 16;
       }
---------------
-------------
@@ -750,7 +750,7 @@
     String tag = readWord();
     try {
       int radix = 10;
-      if (tag.startsWith("0x")) {
+      if (tag.startsWith("0x") || tag.startsWith("0X")) {
         tag = tag.substring("0x".length());
         radix = 16;
       }
---------------
-------------
@@ -279,6 +279,8 @@
             http.setHost_header(hm.getHostHeader());
             if (hm.getType().equals(HealthMonitorType.HTTPS)) {
                 basic.setUse_ssl(true);
+            } else {
+                basic.setUse_ssl(false);
             }
             properties.setHttp(http);
         }
---------------
-------------
@@ -22,6 +22,7 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.openstack.atlas.adapter.helpers.ZxtmNameBuilder;
+import sun.nio.cs.ext.ISO_8859_11;
 
 import java.rmi.RemoteException;
 import java.util.*;
---------------
-------------
@@ -53,7 +53,7 @@
         }
 
         @Before
-        public void standUp() {
+        public void initializeVars() {
             noTypeorIP = new NetworkItem();
             noTypeOrIpInaccesslist = new AccessList();
             noTypeOrIpInaccesslist.getNetworkItems().add(noTypeorIP);
---------------
-------------
@@ -92,7 +92,7 @@
 
                 int endKeyCompare = compareKeys(key, keyIndex + 1);
 
-                if (endKeyCompare >= 0) {
+                if (endKeyCompare > 0) {
                     blockOffsets.add(blockOffset(keyIndex));
                     break;
                 }
---------------
-------------
@@ -51,7 +51,7 @@
 
     @Override
     public boolean mightContain(Key key) {
-        return true;
+        return get(key) != null;
     }
 
     @Override
---------------
-------------
@@ -21,9 +21,9 @@
 
 /**
  * A parser for the classic non-context free language example { a^n b^n c^n : n >= 1 }
- * S ← &(A c) a+ B !(a|b|c)
- * A ← a A? b
- * B ← b B? c
+ * S <- &(A c) a+ B !(a|b|c)
+ * A <- a A? b
+ * B <- b B? c
  */
 @SuppressWarnings({"InfiniteRecursion"})
 public class AbcParser extends BaseParser<Object> {
---------------
-------------
@@ -222,7 +222,7 @@
     private Character findBestSingleCharInsertion(int fixIndex) {
         GetStarterCharVisitor getStarterCharVisitor = new GetStarterCharVisitor();
         int bestNextErrorIndex = -1;
-        Character bestChar = null;
+        Character bestChar = '\u0000'; // non-null default
         for (MatcherPath failedMatcherPath : currentError.getFailedMatchers()) {
             Character starterChar = failedMatcherPath.element.matcher.accept(getStarterCharVisitor);
             checkState(starterChar != null); // we should only have single character matchers
---------------
-------------
@@ -91,7 +91,8 @@
 
         Reader tmp = new StringReader( sourceContent );
 
-        setIgnorableWhitespace( true );
+        // leave this at default (false) until everything is properly implemented, see DOXIA-226
+        //setIgnorableWhitespace( true );
 
         super.parse( tmp, sink );
     }
---------------
-------------
@@ -49,7 +49,7 @@
  *
  * @author ltheussl
  *
- * @since 1.1.5
+ * @since 1.2
  */
 public abstract class AbstractXmlValidator
         extends PlexusTestCase
---------------
-------------
@@ -554,6 +554,7 @@
                  * Constructs a new MessageFormat for formatting the arguments.
                  */
                 format = new MessageFormat(pattern, getFormatLocale());
+                lastKey = key;
             } else if (key != lastKey) {
                 /*
                  * Method MessageFormat.applyPattern(...) is costly! We will avoid
---------------
-------------
@@ -31,7 +31,7 @@
  * Hard-coded citation constants used for testing purpose only.
  *
  * @author  Martin Desruisseaux (Geomatys)
- * @since   0.3 (derived from Geotk-2.4)
+ * @since   0.3 (derived from geotk-2.4)
  * @version 0.3
  * @module
  */
---------------
-------------
@@ -325,7 +325,7 @@
      *     META-INF/services/org.apache.sis.util.logging.LoggerFactory
      * }
      *
-     * The factory found on the classpath is given to {@link #setLoggerFactory(String)}.
+     * The factory found on the classpath is given to {@link #setLoggerFactory(LoggerFactory)}.
      * If more than one factory is found, then the log messages will be sent to the logging
      * frameworks managed by all those factories.
      * <p>
---------------
-------------
@@ -229,7 +229,8 @@
      * /ks/dist/ks-rhel-i386-as-4-u2
      */
     public String getKickstartMediaPath() {
-        // /kickstart/dist/ks-rhel-i386-as-4-u2
+        // /ks/dist/ks-rhel-i386-as-4-u2
+        // or /ks/dist/org/1/my-ks-tree-label
         StringBuilder file = new StringBuilder();
         file.append(KS_DIST);
         file.append("/");
---------------
-------------
@@ -96,7 +96,7 @@
         throws Exception {
 
         InstalledPackage testInstPack = new InstalledPackage();
-        String epoch = "idontcare";
+        String epoch = "";
         PackageEvr evr = PackageEvrFactory.createPackageEvr(epoch, version, release);
         testInstPack.setEvr(evr);
 
---------------
-------------
@@ -795,6 +795,7 @@
             case RENDER:         retval = doAfterBodyRenderData(); break;
             case AFTER_RENDER:   retval = doAfterBodyRenderAfterData(); break;
             case TBL_FOOTER:     retval = doAfterBodyRenderFooterAddons(); break;
+            default: break;
         }
         return retval;
     }
---------------
-------------
@@ -28,7 +28,6 @@
 import com.redhat.rhn.manager.BasePersistOperation;
 import com.redhat.rhn.manager.kickstart.cobbler.CobblerCommand;
 import com.redhat.rhn.manager.kickstart.cobbler.CobblerXMLRPCHelper;
-import com.redhat.rhn.manager.rhnpackage.PackageManager;
 
 import org.cobbler.Distro;
 import org.cobbler.XmlRpcException;
---------------
-------------
@@ -421,7 +421,7 @@
             Iterator j = tProbe.getServerProbes().iterator();
             while (j.hasNext()) {
                 ServerProbe sProbe = (ServerProbe) j.next();
-                if (sProbe.getServer().equals(serverIn)) {
+                if (sProbe.getServer().getId().equals(serverIn.getId())) {
                     j.remove();
                     tProbe.removeServerProbe(sProbe);
                     if (delete) {
---------------
-------------
@@ -308,7 +308,7 @@
     /**
      * @return the cryptoKeys
      */
-    public Set getCryptoKeys() {
+    public Set<CryptoKey> getCryptoKeys() {
         return cryptoKeys;
     }
 
---------------
-------------
@@ -318,7 +318,7 @@
             type = KickstartScript.TYPE_POST;
         }
         
-        scriptCommand.setScript(interpreter, buf.toString(), type, chroot);
+        scriptCommand.setScript(interpreter, buf.toString(), type, chroot, false);
         scriptCommand.store();
 
     }
---------------
-------------
@@ -44,7 +44,7 @@
         ValidatorError[] errors = new ValidatorError[1];
         List args = new LinkedList();
         args.add("/usr/bin/sudo");
-        args.add("/sbin/rhn-sat-restart-silent");
+        args.add("/usr/sbin/rhn-sat-restart-silent");
         
         int exitcode = e.execute((String[]) args.toArray(new String[0]));
         if (exitcode != 0) {
---------------
-------------
@@ -155,6 +155,7 @@
         // /kickstart/dist/ks-rhel-i386-as-4-u2
         StringBuffer file = new StringBuffer();
         file.append(KS_DIST);
+        file.append("/");
         file.append(ksData.getTree().getLabel());
         StringBuffer url = new StringBuffer();
         url.append(protocol + host + file.toString());
---------------
-------------
@@ -1487,6 +1487,7 @@
             Map row = new HashMap();
             row.put("name_id", rse.getElement());
             row.put("evr_id", rse.getElementTwo());
+            row.put("arch_id", rse.getElementThree());
             // bugzilla: 191000, we forgot to populate the damn LinkedList :(
             packages.add(row);
         }
---------------
-------------
@@ -212,7 +212,7 @@
                 result.append("<p>");
                 result.append("<a ")
                       .append("class=\"btn btn-primary\"")
-                      .append("href=\"")
+                      .append(" href=\"")
                       .append(getActionUrl())
                       .append("/EditAddress.do?type=")
                       .append(type)
---------------
-------------
@@ -48,7 +48,7 @@
 
     /**
      * Return true if the given string is a valid host[:port] representation.
-     * @param hostPort
+     * @param hostPort the string with host[:port]
      * @return true if hostPort represents a valid host and port, else false.
      */
     public boolean isValid(String hostPort) {
---------------
-------------
@@ -61,7 +61,7 @@
 	}
 	
 	public ToolAgent(ItemStack item) {
-		this(item == null ? null : item.getType(), item == null ? null : new ItemData(item), item.getAmount());
+		this(item == null ? null : item.getType(), item == null ? null : new ItemData(item), item == null ? 1 : item.getAmount());
 
 		actualTool = item;
 	}
---------------
-------------
@@ -127,7 +127,7 @@
             {
                 if ( super.isRedirected( request, response, context ) )
                 {
-                    if ( response.getHeaders( "location" ) != null )
+                    if ( response.getFirstHeader( "location" ) != null )
                     {
                         final String sourceUri = getPreviousRequestUri( request );
                         final String targetUri = response.getFirstHeader( "location" ).getValue();
---------------
-------------
@@ -221,7 +221,6 @@
                                                    final boolean systemContext )
     {
         Preconditions.checkNotNull( url, "No ldap URL specified (ldap://<hostname>:<port>)" );
-        Preconditions.checkArgument( url.startsWith( "ldap://" ), "LDAP URL is not valid (must be 'ldap://<hostname>:<port>')" );
 
         if ( username != null && principalSuffix != null )
         {
---------------
-------------
@@ -729,7 +729,7 @@
                 // if this repository is contained in any group, we need to get those targets, and tweak the TargetMatch
                 try
                 {
-                    request.pushRequestPath( route.getOriginalRequestPath() );
+                    request.pushRequestPath( route.getRepositoryPath() );
 
                     matched.addTargetSet( this.itemAuthorizer.getGroupsTargetSet( route.getTargetedRepository(),
                         request ) );
---------------
-------------
@@ -42,7 +42,7 @@
         this.giveUserPrivilege( "test-user", "38" );
 
         // print out the users privs
-        this.printUserPrivs( "test-user" );
+//        this.printUserPrivs( "test-user" );
 
         // now.... it should work...
         TestContainer.getInstance().getTestContext().setUsername( "test-user" );
---------------
-------------
@@ -60,6 +60,7 @@
         defaults.put( "java-source", "jar" );
         defaults.put( "javadoc", "jar" );
         defaults.put( "test-jar", "jar" );
+        defaults.put( "bundle", "jar" );
     }
 
     public void setPropertiesFile( File propertiesFile )
---------------
-------------
@@ -127,7 +127,7 @@
 
     protected String discoverClientVersion()
     {
-        return Version.readVersion( "/META-INF/maven/org.sonatype.nexus.client/nexus-client-core/pom.properties", "unknown" );
+        return Version.readVersion( "META-INF/maven/org.sonatype.nexus.client/nexus-client-core/pom.properties", "unknown" );
     }
 
     // ==
---------------
-------------
@@ -233,7 +233,7 @@
         // consequences, like resetting all the HTTP clients of all remote storages (coz they think there is a change
         // in proxy or remote connection settings, etc).
         final Boolean isNtlmUsedOldValue = (Boolean) ctx.getContextObject( NTLM_IS_IN_USE_KEY );
-        if ( isNtlmUsedOldValue == null || !isNtlmUsedOldValue.booleanValue() != isNtlmUsed )
+        if ( isNtlmUsedOldValue == null || isNtlmUsedOldValue.booleanValue() != isNtlmUsed )
         {
             if ( isNtlmUsed )
             {
---------------
-------------
@@ -114,7 +114,7 @@
         {
             if ( key.startsWith( keyToRemove ) )
             {
-                removed = removed || getEHCache().remove( key );
+                removed = getEHCache().remove( key ) || removed;
             }
         }
         return removed;
---------------
-------------
@@ -33,7 +33,7 @@
 
     public String getDescription()
     {
-        return "file: " + propertiesFile.getAbsolutePath();
+        return "file:" + propertiesFile.getAbsolutePath();
     }
 
     public EntrySourceMarker getEntrySourceMarker()
---------------
-------------
@@ -52,7 +52,7 @@
         {
             String[] terms = null;
 
-            if ( ArtifactInfo.GROUP_ID.equals( field ) )
+            if ( ArtifactInfo.GROUP_ID.equals( field ) || ArtifactInfo.VERSION.equals( field ) )
             {
                 terms = phrase.split( "[ _\\-/\\\\&&[^\\.]]" );
             }
---------------
-------------
@@ -147,7 +147,6 @@
         getCurrentConfiguration( true ).setLocalStatus( localStatus.toString() );
     }
 
-  //TODO: these might need to moved
     public RepositoryWritePolicy getWritePolicy()
     {
         return RepositoryWritePolicy.valueOf( getCurrentConfiguration( false ).getWritePolicy() );
---------------
-------------
@@ -1,3 +1,15 @@
+/*
+ * Sonatype Nexus (TM) Open Source Version
+ * Copyright (c) 2007-2012 Sonatype, Inc.
+ * All rights reserved. Includes the third-party code listed at http://links.sonatype.com/products/nexus/oss/attributions.
+ *
+ * This program and the accompanying materials are made available under the terms of the Eclipse Public License Version 1.0,
+ * which accompanies this distribution and is available at http://www.eclipse.org/legal/epl-v10.html.
+ *
+ * Sonatype Nexus (TM) Professional Version is available from Sonatype, Inc. "Sonatype" and "Sonatype Nexus" are trademarks
+ * of Sonatype, Inc. Apache Maven is a trademark of the Apache Software Foundation. M2eclipse is a trademark of the
+ * Eclipse Foundation. All other trademarks are the property of their respective owners.
+ */
 package org.sonatype.nexus.index;
 
 import java.util.concurrent.Semaphore;
---------------
-------------
@@ -92,7 +92,7 @@
                 InetAddress ipAdd;
                 try
                 {
-                    ipAdd = InetAddress.getByAddress( ip.getBytes() );
+                    ipAdd = InetAddress.getByName( ip );
                 }
                 catch ( UnknownHostException e )
                 {
---------------
-------------
@@ -214,7 +214,7 @@
 
 	public Set<Point> diff(StringMaze to){
 		char[][] maze1 = this.toCharArray();
-		char[][] maze2 = this.toCharArray();
+		char[][] maze2 = to.toCharArray();
 		Set<Point> differentLocations = new HashSet<Point>();
 		for (int row = 0; row < this.rows; row++) {
 			for (int column = 0; column < this.columns; column++) {
---------------
-------------
@@ -203,6 +203,10 @@
         // the performance decrease seems to be minimal.
         conf.setProperty("storage.berkeleydb.cache-percentage", 1);
 
+        // Increase storage write buffer since we basically do a large bulk load during the first phases.
+        // See http://s3.thinkaurelius.com/docs/titan/current/bulk-loading.html
+        conf.setProperty("storage.buffer-size", "4096");
+
         //
         // turn on a db-cache that persists across txn boundaries, but make it relatively small
         conf.setProperty("cache.db-cache", true);
---------------
-------------
@@ -97,7 +97,7 @@
             final String credentialsClassname = securityConfig.getCredentialsClassname();
             if (credentialsClassname != null) {
                 try {
-                    ClassLoaderUtil.newInstance(Credentials.class, config.getClassLoader(), credentialsClassname);
+                    c = ClassLoaderUtil.newInstance(config.getClassLoader(), credentialsClassname);
                 } catch (Exception e) {
                     throw ExceptionUtil.rethrow(e);
                 }
---------------
-------------
@@ -154,7 +154,7 @@
     }
 
     public boolean removeEntryListener(String registrationId) {
-        final RemoveEntryListenerRequest request = new RemoveEntryListenerRequest();
+        final RemoveEntryListenerRequest request = new RemoveEntryListenerRequest(name, registrationId);
         return stopListening(request, registrationId);
     }
 
---------------
-------------
@@ -75,6 +75,16 @@
         throw new IllegalStateException("Queue is full!");
     }
 
+    /**
+     * It is advised to use this method in a try-catch block to take the offer operation
+     * full lifecycle control, in a "lost node" scenario you can not be sure
+     * offer is succeeded or not so you may want to retry.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> if the element was added to this queue.
+     *         <tt>false</tt> if there is not enough capacity to insert the element.
+     * @throws HazelcastException if client loses the connected node.
+     */
     public boolean offer(E e) {
         try {
             return offer(e, 0, TimeUnit.SECONDS);
---------------
-------------
@@ -97,7 +97,7 @@
             final String credentialsClassname = securityConfig.getCredentialsClassname();
             if (credentialsClassname != null) {
                 try {
-                    ClassLoaderUtil.newInstance(Credentials.class, config.getClassLoader(), credentialsClassname);
+                    c = ClassLoaderUtil.newInstance(config.getClassLoader(), credentialsClassname);
                 } catch (Exception e) {
                     throw ExceptionUtil.rethrow(e);
                 }
---------------
-------------
@@ -539,8 +539,6 @@
             if (nearCache != null) {
                 if (nearCache.containsKey(key)) {
                     return true;
-                } else if (nearCache.getMaxSize() == Integer.MAX_VALUE) {
-                    return false;
                 }
             }
             final CMap cMap = maps.get(name);
---------------
-------------
@@ -29,7 +29,7 @@
 public class HazelcastParallelClassRunner extends AbstractHazelcastClassRunner {
 
     private static final int MAX_THREADS = !TestEnvironment.isMockNetwork() ? 1
-                : Math.max(Runtime.getRuntime().availableProcessors(), 8);
+                : Math.max(Runtime.getRuntime().availableProcessors()/2, 1);
 
     private final AtomicInteger numThreads = new AtomicInteger(0);
 
---------------
-------------
@@ -156,7 +156,7 @@
         out.writeInt(len);
         if (len > 0) {
             final int offset = out.position();
-            out.position(offset + len * 4);
+            out.writeZeroBytes(len * 4);
             for (int i = 0; i < portables.length; i++) {
                 out.writeInt(offset + i * 4, out.position());
                 final Portable portable = portables[i];
---------------
-------------
@@ -156,7 +156,7 @@
         out.writeInt(len);
         if (len > 0) {
             final int offset = out.position();
-            out.position(offset + len * 4);
+            out.writeZeroBytes(len * 4);
             for (int i = 0; i < portables.length; i++) {
                 out.writeInt(offset + i * 4, out.position());
                 final Portable portable = portables[i];
---------------
-------------
@@ -450,7 +450,6 @@
 
     public Object evict(Data dataKey) {
         checkIfLoaded();
-        earlyWriteCleanup();
 
         Record record = records.get(dataKey);
         Object oldValue = null;
---------------
-------------
@@ -135,7 +135,8 @@
                     Object val = mapService.getPartitionContainer(partitionId).getRecordStore(name).get(key);
                     if (val != null) {
                         mapService.interceptAfterGet(name, val);
-                        return val;
+                        // this serialization step is needed not to expose the object, see issue 1292
+                        return mapService.toData(val);
                     }
                 }
             }
---------------
-------------
@@ -50,6 +50,7 @@
     }
 
     public void run() {
+        ttl = recordInfo != null ? recordInfo.getTtl() : ttl;
         final Record record = recordStore.putBackup(dataKey, dataValue, ttl);
         if (recordInfo != null) {
             Records.applyRecordInfo(record, recordInfo);
---------------
-------------
@@ -60,7 +60,7 @@
         if (timeout == -1 && ttl != Long.MAX_VALUE) {
             // lock (lease, TimeUnit)
             return new Object[]{ttl, TimeUnit.MILLISECONDS};
-        } else if (timeout > 0) {
+        } else if (timeout >= 0) {
             // tryLock(timeout, TimeUnit)
             return new Object[]{timeout, TimeUnit.MILLISECONDS};
         }
---------------
-------------
@@ -7,7 +7,7 @@
 /**
  * Sample Put parameter
  */
-@edu.umd.cs.findbugs.annotations.SuppressWarnings({"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD" })
+@edu.umd.cs.findbugs.annotations.SuppressWarnings({"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"})
 public class MapPutParameters {
 
     public byte[] key;
---------------
-------------
@@ -669,6 +669,7 @@
 
     @Override
     public LocalMapStats getLocalMapStats() {
+        initNearCache();
         LocalMapStatsImpl localMapStats = new LocalMapStatsImpl();
         if (nearCache != null) {
             localMapStats.setNearCacheStats(nearCache.getNearCacheStats());
---------------
-------------
@@ -27,7 +27,7 @@
  * Built-in MergePolicy implementation.
  * <p/>
  * PassThroughMergePolicy causes the merging entry to be merged from source to destination map
- * if source entry has updated more recently than the destination entry.
+ * unless merging entry is not null.
  *
  * <p/>
  *
---------------
-------------
@@ -457,7 +457,7 @@
                 Object cachedValue = mapService.getFromNearCache(name, key);
                 if (cachedValue != null) {
                     if (!NearCache.NULL_OBJECT.equals(cachedValue)) {
-                        result.put(key, cachedValue);
+                        result.put(mapService.toObject(key), mapService.toObject(cachedValue));
                     }
                     iterator.remove();
                 }
---------------
-------------
@@ -669,6 +669,7 @@
 
     @Override
     public LocalMapStats getLocalMapStats() {
+        initNearCache();
         LocalMapStatsImpl localMapStats = new LocalMapStatsImpl();
         if (nearCache != null) {
             localMapStats.setNearCacheStats(nearCache.getNearCacheStats());
---------------
-------------
@@ -115,6 +115,7 @@
     @Override
     public void destroyDistributedObject(String objectId) {
         statsMap.remove(objectId);
+        nodeEngine.getEventService().deregisterAllListeners(SERVICE_NAME, objectId);
     }
 
     @Override
---------------
-------------
@@ -256,7 +256,6 @@
                 }
                 dataMap.put(entry.getKey(), data);
             }
-            return (Map<Long, Data>) map;
         } else {
             for (Map.Entry<Long, ?> entry : map.entrySet()) {
                 dataMap.put(entry.getKey(), serializationService.toData(entry.getValue()));
---------------
-------------
@@ -95,7 +95,7 @@
 
         // Force return null on ttl expiration (but before cleanup thread run)
         long ttlMillis = replicatedRecord == null ? 0 : replicatedRecord.getTtlMillis();
-        if (ttlMillis > 0 && System.currentTimeMillis() - replicatedRecord.getUpdateTime() > ttlMillis) {
+        if (ttlMillis > 0 && System.currentTimeMillis() - replicatedRecord.getUpdateTime() >= ttlMillis) {
             replicatedRecord = null;
         }
 
---------------
-------------
@@ -45,7 +45,6 @@
     }
 
     @Test
-    @Category(ProblematicTest.class)
     public void concurrent_MapTryLockTimeOutTest() throws InterruptedException {
         concurrent_MapTryLock(true);
     }
---------------
-------------
@@ -67,7 +67,7 @@
 
     public synchronized void addThisAsListener(IMap map, Data key, boolean includeValue) {
         if (!listeningMaps.contains(map) && !(listeningKeyExist(map, key))) {
-            if (key == null) {
+            if (key == null){
                 map.addEntryListener(this, includeValue);
             } else {
                 map.addEntryListener(this, toObject(key), includeValue);
---------------
-------------
@@ -156,7 +156,7 @@
         out.writeInt(len);
         if (len > 0) {
             final int offset = out.position();
-            out.position(offset + len * 4);
+            out.writeZeroBytes(len * 4);
             for (int i = 0; i < portables.length; i++) {
                 out.writeInt(offset + i * 4, out.position());
                 final Portable portable = portables[i];
---------------
-------------
@@ -54,7 +54,7 @@
             op.run();
             //op.afterRun();
         }
-        getOrCreateContainer().unlock(dataKey, getCallerUuid(), threadId);
+        getOrCreateContainer().unlock(dataKey, caller, threadId);
     }
 
     protected void writeInternal(ObjectDataOutput out) throws IOException {
---------------
-------------
@@ -556,8 +556,6 @@
             if (nearCache != null) {
                 if (nearCache.containsKey(key)) {
                     return true;
-                } else if (nearCache.getMaxSize() == Integer.MAX_VALUE) {
-                    return false;
                 }
             }
             final CMap cMap = maps.get(name);
---------------
-------------
@@ -42,7 +42,7 @@
         if (value instanceof Data) {
             v = serializationService.toObject(value);
         }
-        return statisticsEnabled ? new ObjectRecordWithStats(key, value) : new ObjectRecord(key, v);
+        return statisticsEnabled ? new ObjectRecordWithStats(key, v) : new ObjectRecord(key, v);
     }
 
     @Override
---------------
-------------
@@ -1825,7 +1825,6 @@
 
         @Override
         public void doOp() {
-//            CounterService.userCounter.add(System.nanoTime() - request.lastTime);
             target = null;
             super.doOp();
         }
---------------
-------------
@@ -313,7 +313,7 @@
                 }
             } else {
                 // meanwhile remove values which are not in txMap.
-                valueSet.remove(entry.getValue());
+                valueSet.remove(entry.getValue().value);
             }
         }
 
---------------
-------------
@@ -88,7 +88,7 @@
 
     @Override
     public boolean shouldBackup() {
-        return successful;
+        return true;
     }
 
     public WaitNotifyKey getNotifiedKey() {
---------------
-------------
@@ -59,6 +59,7 @@
 
         @Override
         public void distributedObjectDestroyed(DistributedObjectEvent event) {
+            send(event);
         }
 
         private void send(DistributedObjectEvent event) {
---------------
-------------
@@ -385,7 +385,7 @@
                 Data key = iterator.next();
                 Object cachedValue = mapService.getFromNearCache(name, key);
                 if (cachedValue != null && !NearCache.NULL_OBJECT.equals(cachedValue)) {
-                    result.put(key, cachedValue);
+                    result.put(mapService.toObject(key), mapService.toObject(cachedValue));
                     iterator.remove();
                 }
             }
---------------
-------------
@@ -509,7 +509,7 @@
         return this.persistStatus >= status;
     }
 
-    private static int getDataSize(Data data, PortableContext context) {
+    public static int getDataSize(Data data, PortableContext context) {
         // type
         int total = INT_SIZE_IN_BYTES;
         // class def flag
---------------
-------------
@@ -32,7 +32,6 @@
 import com.hazelcast.mapreduce.impl.task.JobTaskConfiguration;
 import com.hazelcast.mapreduce.impl.task.MemberAssigningJobProcessInformationImpl;
 import com.hazelcast.nio.Address;
-import com.hazelcast.partition.InternalPartition;
 import com.hazelcast.partition.InternalPartitionService;
 import com.hazelcast.spi.InvocationBuilder;
 import com.hazelcast.spi.NodeEngine;
---------------
-------------
@@ -156,7 +156,7 @@
         out.writeInt(len);
         if (len > 0) {
             final int offset = out.position();
-            out.position(offset + len * 4);
+            out.writeZeroBytes(len * 4);
             for (int i = 0; i < portables.length; i++) {
                 out.writeInt(offset + i * 4, out.position());
                 final Portable portable = portables[i];
---------------
-------------
@@ -82,7 +82,7 @@
         }
     }
 
-    private class EmptyIterator implements Iterator {
+    private static class EmptyIterator implements Iterator {
 
         @Override
         public boolean hasNext() {
---------------
-------------
@@ -59,6 +59,7 @@
 
         @Override
         public void distributedObjectDestroyed(DistributedObjectEvent event) {
+            send(event);
         }
 
         private void send(DistributedObjectEvent event) {
---------------
-------------
@@ -306,7 +306,7 @@
     }
 
     private void sendClientEvent(ClientEndpoint endpoint) {
-        if (endpoint.isFirstConnection()) {
+        if (!endpoint.isFirstConnection()) {
             final EventService eventService = nodeEngine.getEventService();
             final Collection<EventRegistration> regs = eventService.getRegistrations(SERVICE_NAME, SERVICE_NAME);
             eventService.publishEvent(SERVICE_NAME, regs, endpoint, endpoint.getUuid().hashCode());
---------------
-------------
@@ -69,7 +69,7 @@
     public void shutdown() {
     }
 
-    private String convertToLetter(int size) {
+    public String convertToLetter(int size) {
         String letter;
         if (size < A_INTERVAL) {
             letter = "A";
---------------
-------------
@@ -669,6 +669,7 @@
 
     @Override
     public LocalMapStats getLocalMapStats() {
+        initNearCache();
         LocalMapStatsImpl localMapStats = new LocalMapStatsImpl();
         if (nearCache != null) {
             localMapStats.setNearCacheStats(nearCache.getNearCacheStats());
---------------
-------------
@@ -160,7 +160,7 @@
         };
         constructors[QUEUE_ITEM] = new ConstructorFunction<Integer, IdentifiedDataSerializable>() {
             public IdentifiedDataSerializable createNew(Integer arg) {
-                return new PeekOperation();
+                return new QueueItem();
             }
         };
         constructors[QUEUE_REPLICATION] = new ConstructorFunction<Integer, IdentifiedDataSerializable>() {
---------------
-------------
@@ -135,7 +135,8 @@
                     Object val = mapService.getPartitionContainer(partitionId).getRecordStore(name).get(key);
                     if (val != null) {
                         mapService.interceptAfterGet(name, val);
-                        return val;
+                        // this serialization step is needed not to expose the object, see issue 1292
+                        return mapService.toData(val);
                     }
                 }
             }
---------------
-------------
@@ -193,7 +193,7 @@
     }
 
     /**
-     * Only difference between add or update is event type to be published.
+     * Only difference between add and update is event type to be published.
      */
     private boolean entryAddedOrUpdated(Map.Entry entry, long now) {
         final Object value = entry.getValue();
---------------
-------------
@@ -50,6 +50,7 @@
     }
 
     public void run() {
+        ttl = recordInfo != null ? recordInfo.getTtl() : ttl;
         final Record record = recordStore.putBackup(dataKey, dataValue, ttl);
         if (recordInfo != null) {
             Records.applyRecordInfo(record, recordInfo);
---------------
-------------
@@ -192,7 +192,7 @@
 
             for (EventRegistration registration : registrations) {
                 EventFilter filter = registration.getFilter();
-                boolean publish = filter == null || filter.eval(key);
+                boolean publish = filter == null || filter.eval(marshallKey(key));
                 if (publish) {
                     eventService.publishEvent(ReplicatedMapService.SERVICE_NAME, registration, event, name.hashCode());
                 }
---------------
-------------
@@ -110,7 +110,7 @@
         String mapName = uri.substring(URI_MAPS.length(), indexEnd);
         String key = uri.substring(indexEnd + 1);
         byte[] data = command.getData();
-        textCommandService.put(mapName, key, new RestValue(data, command.getContentType()), 0);
+        textCommandService.put(mapName, key, new RestValue(data, command.getContentType()), -1);
         command.setResponse(HttpCommand.RES_204);
     }
 
---------------
-------------
@@ -67,7 +67,7 @@
 
     public V setValue(V value, int hash, long ttlMillis) {
         access();
-        V oldValue = value;
+        V oldValue = this.value;
         this.value = value;
         this.latestUpdateHash = hash;
         this.updateTime = System.currentTimeMillis();
---------------
-------------
@@ -1626,7 +1626,6 @@
             if (request.operation == CONCURRENT_MAP_TRY_PUT) {
                 request.response = Boolean.TRUE;
             }
-            //logger.log(Level.FINEST, " [" + request.name + "] put " + toObject(request.key));
         }
     }
 
---------------
-------------
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008-2012, Hazelcast, Inc. All Rights Reserved.
+ * Copyright (c) 2008-2013, Hazelcast, Inc. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
---------------
-------------
@@ -43,7 +43,7 @@
     public void printNodeInfo(Node node) {
         systemLogger.info("Hazelcast Community Edition " + version + " ("
                 + build + ") starting at " + node.getThisAddress());
-        systemLogger.info("Copyright (C) 2008-2013 Hazelcast.com");
+        systemLogger.info("Copyright (C) 2008-2014 Hazelcast.com");
     }
 
     public void afterInitialize(Node node) {
---------------
-------------
@@ -69,6 +69,7 @@
     private transient ResponseHandler responseHandler;
 
     public Operation() {
+        setFlag(true, BITMASK_VALIDATE_TARGET);
         setFlag(true, BITMASK_CALL_TIMEOUT_64_BIT);
     }
 
---------------
-------------
@@ -154,7 +154,7 @@
     }
 
     public boolean removeEntryListener(String registrationId) {
-        final RemoveEntryListenerRequest request = new RemoveEntryListenerRequest();
+        final RemoveEntryListenerRequest request = new RemoveEntryListenerRequest(name, registrationId);
         return stopListening(request, registrationId);
     }
 
---------------
-------------
@@ -37,7 +37,7 @@
                 String mapName = uri.substring(URI_MAPS.length(), indexEnd);
                 String key = uri.substring(indexEnd + 1);
                 byte[] data = command.getData();
-                textCommandService.put(mapName, key, new RestValue(data, command.getContentType()), 0);
+                textCommandService.put(mapName, key, new RestValue(data, command.getContentType()), -1);
                 command.setResponse(HttpCommand.RES_204);
             } else if (uri.startsWith(URI_MANCENTER_CHANGE_URL)) {
                 if (textCommandService.getNode().getGroupProperties().MC_URL_CHANGE_ENABLED.getBoolean()) {
---------------
-------------
@@ -321,7 +321,7 @@
         MAP_WRITE_BEHIND_QUEUE_CAPACITY
                 = new GroupProperty(config, PROP_MAP_WRITE_BEHIND_QUEUE_CAPACITY, "50000");
         ENTERPRISE_WAN_REP_QUEUESIZE = new GroupProperty(config, PROP_ENTERPRISE_WAN_REP_QUEUESIZE, "100000");
-        CLIENT_HEARTBEAT_TIMEOUT_SECONDS = new GroupProperty(config, PROP_CLIENT_MAX_NO_HEARTBEAT_SECONDS, "60");
+        CLIENT_HEARTBEAT_TIMEOUT_SECONDS = new GroupProperty(config, PROP_CLIENT_MAX_NO_HEARTBEAT_SECONDS, "300");
     }
 
     public static class GroupProperty {
---------------
-------------
@@ -135,7 +135,8 @@
                     Object val = mapService.getPartitionContainer(partitionId).getRecordStore(name).get(key);
                     if (val != null) {
                         mapService.interceptAfterGet(name, val);
-                        return val;
+                        // this serialization step is needed not to expose the object, see issue 1292
+                        return mapService.toData(val);
                     }
                 }
             }
---------------
-------------
@@ -306,7 +306,7 @@
     }
 
     private void sendClientEvent(ClientEndpoint endpoint) {
-        if (endpoint.isFirstConnection()) {
+        if (!endpoint.isFirstConnection()) {
             final EventService eventService = nodeEngine.getEventService();
             final Collection<EventRegistration> regs = eventService.getRegistrations(SERVICE_NAME, SERVICE_NAME);
             eventService.publishEvent(SERVICE_NAME, regs, endpoint, endpoint.getUuid().hashCode());
---------------
-------------
@@ -59,6 +59,7 @@
 
         @Override
         public void distributedObjectDestroyed(DistributedObjectEvent event) {
+            send(event);
         }
 
         private void send(DistributedObjectEvent event) {
---------------
-------------
@@ -628,7 +628,8 @@
         Set<Map.Entry<Data, Data>> entrySet = mapEntrySet.getEntrySet();
         for (Map.Entry<Data, Data> entry : entrySet) {
             // correct TTL will be set in the put method below, when creating record.
-            put(entry.getKey(), entry.getValue(), DEFAULT_TTL);
+            // use putTransient since we already fetched entries from map-loader.
+            putTransient(entry.getKey(), entry.getValue(), DEFAULT_TTL);
         }
         return mapEntrySet;
     }
---------------
-------------
@@ -34,7 +34,7 @@
             }
             return;
         }
-        if (trend == -1) {
+        if (trend < 0) {
             Comparable oldFrom = from;
             from = to;
             to = oldFrom;
---------------
-------------
@@ -431,7 +431,8 @@
         keysToDelete.removeAll(lockedRecords.keySet());
 
         final MapStoreWrapper store = mapContainer.getStore();
-        Set<Object> keysObject = new HashSet<Object>(keysToDelete.size());
+        // Use an ArrayList so that we don't trigger calls to equals or hashCode on the key objects
+        Collection<Object> keysObject = new ArrayList<Object>(keysToDelete.size());
         for (Data key : keysToDelete) {
             // todo ea have a clear(Keys) method for optimizations
             removeIndex(key);
---------------
-------------
@@ -115,6 +115,7 @@
     @Override
     public void destroyDistributedObject(String objectId) {
         statsMap.remove(objectId);
+        nodeEngine.getEventService().deregisterAllListeners(SERVICE_NAME, objectId);
     }
 
     @Override
---------------
-------------
@@ -562,6 +562,7 @@
             fireMigrationEvent(false, new Block(blockReal));
             blockReal.setOwner(blockReal.getMigrationAddress());
             blockReal.setMigrationAddress(null);
+            removeUnknownsAndResetStats();
             logger.log(Level.FINEST, "Migration complete info : " + blockReal);
             nextMigrationMillis = System.currentTimeMillis() + MIGRATION_INTERVAL_MILLIS;
         }
---------------
-------------
@@ -45,7 +45,6 @@
     }
 
     @Test
-    @Category(ProblematicTest.class)
     public void concurrent_MapTryLockTimeOutTest() throws InterruptedException {
         concurrent_MapTryLock(true);
     }
---------------
-------------
@@ -135,7 +135,8 @@
                     Object val = mapService.getPartitionContainer(partitionId).getRecordStore(name).get(key);
                     if (val != null) {
                         mapService.interceptAfterGet(name, val);
-                        return val;
+                        // this serialization step is needed not to expose the object, see issue 1292
+                        return mapService.toData(val);
                     }
                 }
             }
---------------
-------------
@@ -68,6 +68,7 @@
         for (int i=0; i<size; i++){
             final Data value = new Data();
             value.readData(in);
+            valueSet.add(value);
         }
     }
 }
---------------
-------------
@@ -100,7 +100,7 @@
         public void sendResponse(Object obj) {
             long callId = op.getCallId();
             Connection conn = op.getConnection();
-            if (!sent.compareAndSet(false, true)) {
+            if (!sent.compareAndSet(false, true) && !(obj instanceof Throwable)) {
                 throw new ResponseAlreadySentException("NormalResponse already sent for call: " + callId
                         + " to " + conn.getEndPoint() + ", current-response: " + obj);
             }
---------------
-------------
@@ -298,6 +298,8 @@
                 l.entryRemoved(event);
             } else if (event.getEventType() == EntryEvent.EntryEventType.UPDATED) {
                 l.entryUpdated(event);
+            }else if (event.getEventType() == EntryEvent.EntryEventType.EVICTED) {
+                l.entryEvicted(event);
             }
         } else if (listenerItem.instanceType == Instance.InstanceType.SET || listenerItem.instanceType == Instance.InstanceType.LIST) {
             ItemListener l = (ItemListener) listener;
---------------
-------------
@@ -156,7 +156,7 @@
         out.writeInt(len);
         if (len > 0) {
             final int offset = out.position();
-            out.position(offset + len * 4);
+            out.writeZeroBytes(len * 4);
             for (int i = 0; i < portables.length; i++) {
                 out.writeInt(offset + i * 4, out.position());
                 final Portable portable = portables[i];
---------------
-------------
@@ -84,7 +84,7 @@
 
         final QueueStoreWrapper storeWrapper = new QueueStoreWrapper();
         storeWrapper.setSerializationService(serializationService);
-        if (storeConfig == null) {
+        if (storeConfig == null || !storeConfig.isEnabled()) {
             return storeWrapper;
         }
         // create queue store.
---------------
-------------
@@ -85,7 +85,7 @@
                     cacheManager = createHazelcastCacheManager(uri, classLoader, managerProperties);
                     cacheManagersByURI.put(managerURI, cacheManager);
                 } catch (Exception e) {
-                    throw new CacheException("Error opening URI" + managerURI.toString(), e);
+                    throw new CacheException("Error opening URI " + managerURI.toString(), e);
                 }
             }
             return cacheManager;
---------------
-------------
@@ -718,7 +718,7 @@
             return;
         String source = nodeEngine.getThisAddress().toString();
         if (eventType == EntryEventType.REMOVED || eventType == EntryEventType.EVICTED) {
-            dataValue = dataValue != null ? dataValue : dataOldValue;
+                dataValue = null;
         }
         EventData event = new EventData(source, mapName, caller, dataKey, dataValue, dataOldValue, eventType.getType());
         int orderKey = dataKey.hashCode();
---------------
-------------
@@ -154,6 +154,9 @@
     }
 
     public void putForReplication(Data key, Record record) {
+        // this get is needed for updating size estimator.
+        final Record existingRecord = records.get(key);
+        updateSizeEstimator(-calculateRecordSize(existingRecord));
         records.put(key, record);
         updateSizeEstimator(calculateRecordSize(record));
         removeFromWriteBehindWaitingDeletions(key);
---------------
-------------
@@ -253,7 +253,6 @@
                     }
                     dataMap.put(entry.getKey(), data);
                 }
-                return (Map<Long, Data>) map;
             } else {
                 for (Map.Entry<Long, ?> entry : map.entrySet()) {
                     dataMap.put(entry.getKey(), serializationService.toData(entry.getValue()));
---------------
-------------
@@ -66,6 +66,7 @@
         this.client = transactionManager.getClient();
         try {
             this.connection = client.getConnectionManager().tryToConnect(null);
+            System.out.println("Transaction started on " + connection);
         } catch (Exception e) {
             throw new HazelcastException("Could not obtain Connection!!!", e);
         }
---------------
-------------
@@ -88,7 +88,7 @@
 
     @Override
     public boolean shouldBackup() {
-        return successful;
+        return true;
     }
 
     public WaitNotifyKey getNotifiedKey() {
---------------
-------------
@@ -59,6 +59,7 @@
 
         @Override
         public void distributedObjectDestroyed(DistributedObjectEvent event) {
+            send(event);
         }
 
         private void send(DistributedObjectEvent event) {
---------------
-------------
@@ -751,6 +751,7 @@
                     rethrowException(operation, (AddressAwareException) returnObject);
                 }
                 if (returnObject != Boolean.FALSE) {
+                    request.value = dataNew;
                     backup(CONCURRENT_MAP_BACKUP_PUT);
                 }
                 return returnObject;
---------------
-------------
@@ -110,7 +110,7 @@
         String mapName = uri.substring(URI_MAPS.length(), indexEnd);
         String key = uri.substring(indexEnd + 1);
         byte[] data = command.getData();
-        textCommandService.put(mapName, key, new RestValue(data, command.getContentType()), 0);
+        textCommandService.put(mapName, key, new RestValue(data, command.getContentType()), -1);
         command.setResponse(HttpCommand.RES_204);
     }
 
---------------
-------------
@@ -836,7 +836,7 @@
                 Record record = itRemovedRecords.next();
                 if (record.isActive()) {
                     itRemovedRecords.remove();
-                } else if (shouldRemove(record, now) && !setDirtyRecords.contains(record)) {
+                } else if (shouldRemove(record, now) && (setDirtyRecords == null || !setDirtyRecords.contains(record))) {
                     itRemovedRecords.remove();
                     removeAndPurgeRecord(record);
                 }
---------------
-------------
@@ -634,7 +634,8 @@
         Set<Map.Entry<Data, Data>> entrySet = mapEntrySet.getEntrySet();
         for (Map.Entry<Data, Data> entry : entrySet) {
             // correct TTL will be set in the put method below, when creating record.
-            put(entry.getKey(), entry.getValue(), DEFAULT_TTL);
+            // use putTransient since we already fetched entries from map-loader.
+            putTransient(entry.getKey(), entry.getValue(), DEFAULT_TTL);
         }
         return mapEntrySet;
     }
---------------
-------------
@@ -67,6 +67,8 @@
         ClientConfig clientConfig = new ClientConfig();
         clientConfig.setGroupConfig(new GroupConfig(group, pass)).addAddress(address);
         clientConfig.setUpdateAutomatic(true);
+        clientConfig.setInitialConnectionAttemptLimit(3);
+        clientConfig.setReconnectionAttemptLimit(5);
         return (client = HazelcastClient.newHazelcastClient(clientConfig));
     }
 
---------------
-------------
@@ -37,7 +37,7 @@
                 String mapName = uri.substring(URI_MAPS.length(), indexEnd);
                 String key = uri.substring(indexEnd + 1);
                 byte[] data = command.getData();
-                textCommandService.put(mapName, key, new RestValue(data, command.getContentType()), 0);
+                textCommandService.put(mapName, key, new RestValue(data, command.getContentType()), -1);
                 command.setResponse(HttpCommand.RES_204);
             } else if (uri.startsWith(URI_MANCENTER_CHANGE_URL)) {
                 if (textCommandService.getNode().getGroupProperties().MC_URL_CHANGE_ENABLED.getBoolean()) {
---------------
-------------
@@ -431,7 +431,8 @@
         keysToDelete.removeAll(lockedRecords.keySet());
 
         final MapStoreWrapper store = mapContainer.getStore();
-        Set<Object> keysObject = new HashSet<Object>(keysToDelete.size());
+        // Use an ArrayList so that we don't trigger calls to equals or hashCode on the key objects
+        Collection<Object> keysObject = new ArrayList<Object>(keysToDelete.size());
         for (Data key : keysToDelete) {
             // todo ea have a clear(Keys) method for optimizations
             removeIndex(key);
---------------
-------------
@@ -74,7 +74,7 @@
         isNotNull(executor, "executor");
 
         synchronized (this) {
-            if (response != null) {
+            if (response != null && !(response instanceof BasicInvocation.InternalResponse)) {
                 runAsynchronous(callback, executor);
                 return;
             }
---------------
-------------
@@ -156,7 +156,7 @@
         out.writeInt(len);
         if (len > 0) {
             final int offset = out.position();
-            out.position(offset + len * 4);
+            out.writeZeroBytes(len * 4);
             for (int i = 0; i < portables.length; i++) {
                 out.writeInt(offset + i * 4, out.position());
                 final Portable portable = portables[i];
---------------
-------------
@@ -34,6 +34,10 @@
  * <p/>
  * Store implementation can be called synchronously (write-through)
  * or asynchronously (write-behind) depending on the configuration.
+ * <p/>
+ * Note that in write-behind mode, there is a possibility that a map-store
+ * implementation can be used by multiple threads at the same time, calling methods like
+ * {@link IMap#flush()} or {@link IMap#evict(Object)} may trigger this behavior.
  */
 public interface MapStore<K, V> extends MapLoader<K, V> {
     /**
---------------
-------------
@@ -54,7 +54,7 @@
             op.run();
             //op.afterRun();
         }
-        getOrCreateContainer().unlock(dataKey, getCallerUuid(), threadId);
+        getOrCreateContainer().unlock(dataKey, caller, threadId);
     }
 
     protected void writeInternal(ObjectDataOutput out) throws IOException {
---------------
-------------
@@ -59,6 +59,7 @@
 
         @Override
         public void distributedObjectDestroyed(DistributedObjectEvent event) {
+            send(event);
         }
 
         private void send(DistributedObjectEvent event) {
---------------
-------------
@@ -70,7 +70,7 @@
         isNotNull(executor, "executor");
 
         synchronized (this) {
-            if (response != null) {
+            if (response != null && !(response instanceof BasicInvocation.InternalResponse)) {
                 runAsynchronous(callback, executor);
                 return;
             }
---------------
-------------
@@ -385,7 +385,7 @@
                 Data key = iterator.next();
                 Object cachedValue = mapService.getFromNearCache(name, key);
                 if (cachedValue != null && !NearCache.NULL_OBJECT.equals(cachedValue)) {
-                    result.put(key, cachedValue);
+                    result.put(mapService.toObject(key), mapService.toObject(cachedValue));
                     iterator.remove();
                 }
             }
---------------
-------------
@@ -281,7 +281,7 @@
         if (expirationTime == Long.MAX_VALUE && maxIdleMillis == Long.MAX_VALUE) {
             return true;
         }
-        long lastTouch = Math.max(lastAccessTime, creationTime);
+        long lastTouch = Math.max(lastUpdateTime, Math.max(lastAccessTime, creationTime));
         long idle = now - lastTouch;
         return expirationTime > now && (maxIdleMillis > idle);
     }
---------------
-------------
@@ -1049,7 +1049,7 @@
 
     public void addIndex(final String attribute, final boolean ordered) {
         final NodeEngine nodeEngine = getNodeEngine();
-        if (attribute == null) throw new IllegalArgumentException("attribute name cannot be null");
+        if (attribute == null) throw new IllegalArgumentException("Attribute name cannot be null");
         try {
             AddIndexOperation addIndexOperation = new AddIndexOperation(name, attribute, ordered);
             nodeEngine.getOperationService()
---------------
-------------
@@ -93,7 +93,7 @@
 
         // Force return null on ttl expiration (but before cleanup thread run)
         long ttlMillis = replicatedRecord == null ? 0 : replicatedRecord.getTtlMillis();
-        if (ttlMillis > 0 && System.currentTimeMillis() - replicatedRecord.getUpdateTime() > ttlMillis) {
+        if (ttlMillis > 0 && System.currentTimeMillis() - replicatedRecord.getUpdateTime() >= ttlMillis) {
             replicatedRecord = null;
         }
 
---------------
-------------
@@ -457,7 +457,7 @@
                 Object cachedValue = mapService.getFromNearCache(name, key);
                 if (cachedValue != null) {
                     if (!NearCache.NULL_OBJECT.equals(cachedValue)) {
-                        result.put(key, cachedValue);
+                        result.put(mapService.toObject(key), mapService.toObject(cachedValue));
                     }
                     iterator.remove();
                 }
---------------
-------------
@@ -135,7 +135,8 @@
                     Object val = mapService.getPartitionContainer(partitionId).getRecordStore(name).get(key);
                     if (val != null) {
                         mapService.interceptAfterGet(name, val);
-                        return val;
+                        // this serialization step is needed not to expose the object, see issue 1292
+                        return mapService.toData(val);
                     }
                 }
             }
---------------
-------------
@@ -229,7 +229,7 @@
         final List<TransactionLog> txLogs = txnImpl.getTxLogs();
         final long timeoutMillis = txnImpl.getTimeoutMillis();
         final long startTime = txnImpl.getStartTime();
-        TxBackupLog log = new TxBackupLog(txLogs, callerUuid, State.NO_TXN, timeoutMillis, startTime, xid);
+        TxBackupLog log = new TxBackupLog(txLogs, callerUuid, State.COMMITTING, timeoutMillis, startTime, xid);
         txBackupLogs.put(txnImpl.getTxnId(), log);
     }
 
---------------
-------------
@@ -97,7 +97,7 @@
             final String credentialsClassname = securityConfig.getCredentialsClassname();
             if (credentialsClassname != null) {
                 try {
-                    ClassLoaderUtil.newInstance(Credentials.class, config.getClassLoader(), credentialsClassname);
+                    c = ClassLoaderUtil.newInstance(config.getClassLoader(), credentialsClassname);
                 } catch (Exception e) {
                     throw ExceptionUtil.rethrow(e);
                 }
---------------
-------------
@@ -313,7 +313,7 @@
                 }
             } else {
                 // meanwhile remove values which are not in txMap.
-                valueSet.remove(entry.getValue());
+                valueSet.remove(entry.getValue().value);
             }
         }
 
---------------
-------------
@@ -47,7 +47,7 @@
 
     @Override
     protected void runChild(final FrameworkMethod method, final RunNotifier notifier) {
-        while (numThreads.get() > MAX_THREADS) {
+        while (numThreads.get() >= MAX_THREADS) {
             try {
                 Thread.sleep(25);
             } catch (InterruptedException e) {
---------------
-------------
@@ -117,6 +117,7 @@
         lockedEntryCount = 0;
         dirtyEntryCount = 0;
         backupCount = 0;
+        HITS_UPDATER.set(this,0);
     }
 
     @Override
---------------
-------------
@@ -313,7 +313,7 @@
                 }
             } else {
                 // meanwhile remove values which are not in txMap.
-                valueSet.remove(entry.getValue());
+                valueSet.remove(entry.getValue().value);
             }
         }
 
---------------
-------------
@@ -37,7 +37,7 @@
                 String mapName = uri.substring(URI_MAPS.length(), indexEnd);
                 String key = uri.substring(indexEnd + 1);
                 byte[] data = command.getData();
-                textCommandService.put(mapName, key, new RestValue(data, command.getContentType()), 0);
+                textCommandService.put(mapName, key, new RestValue(data, command.getContentType()), -1);
                 command.setResponse(HttpCommand.RES_204);
             } else if (uri.startsWith(URI_MANCENTER_CHANGE_URL)) {
                 if (textCommandService.getNode().getGroupProperties().MC_URL_CHANGE_ENABLED.getBoolean()) {
---------------
-------------
@@ -313,7 +313,7 @@
                 }
             } else {
                 // meanwhile remove values which are not in txMap.
-                valueSet.remove(entry.getValue());
+                valueSet.remove(entry.getValue().value);
             }
         }
 
---------------
-------------
@@ -37,7 +37,7 @@
 
   @Inject
   public SingularityCmdLineArgsMigration(CuratorFramework curator, TaskManager taskManager, ObjectMapper objectMapper, Transcoder<SingularityPendingRequest> pendingRequestTranscoder) {
-    super(3);
+    super(4);
     this.curator = curator;
     this.taskManager = taskManager;
     this.objectMapper = objectMapper;
---------------
-------------
@@ -331,7 +331,7 @@
   }
 
   private List<SingularityTaskId> getMatchingTaskIds(SingularitySchedulerStateCache stateCache, SingularityRequest request, SingularityPendingRequest pendingRequest) {
-    if (!request.isScheduled()) {
+    if (request.isLongRunning()) {
       return SingularityTaskId.matchingAndNotIn(stateCache.getActiveTaskIds(), request.getId(), pendingRequest.getDeployId(), stateCache.getCleaningTasks());
     } else {
       return Lists.newArrayList(Iterables.filter(stateCache.getActiveTaskIds(), SingularityTaskId.matchingRequest(request.getId())));
---------------
-------------
@@ -196,7 +196,7 @@
       cleanupTasks(tasksToKill, deployResult.getDeployState().getCleanupType(), deployResult.getTimestamp());
     }
 
-    if (!request.isDeployable()) {
+    if (!request.isDeployable() && !request.isOneOff()) {
       requestManager.addToPendingQueue(new SingularityPendingRequest(request.getId(), pendingDeploy.getDeployMarker().getDeployId(), PendingType.NEW_DEPLOY));
     }
 
---------------
-------------
@@ -61,7 +61,7 @@
         transformationMatrix.put(0x7C, getCodePoint('!'));  // |
         
         unsafePrefixes = new HashSet<String>();
-        unsafePrefixes.add(".");
+        //unsafePrefixes.add(".");
         unsafePrefixes.add("$");
         
         unsafeSuffixes = new HashSet<String>();
---------------
-------------
@@ -280,7 +280,7 @@
             @Transactional(readOnly = false)
             public Object doWork(Session session, ServiceFactory sf) {
 
-                SqlAction sql = (SqlAction) sf.getContext().getBean("sqlAction");
+                SqlAction sql = (SqlAction) sf.getContext().getBean("simpleSqlAction");
 
                 File f = null;
                 RepoFile file = null;
---------------
-------------
@@ -137,7 +137,7 @@
         this.mock("executorMock").expects(test.once()).method("execute").will(test.returnValue(true));
         this.mock("executorMock").expects(test.once()).method("execute").will(test.returnValue(Collections.EMPTY_LIST));
         */
-        blitz = new BlitzConfiguration(id, ring, mgr, ss, ex);
+        blitz = new BlitzConfiguration(id, ring, mgr, ss, ex, 10000);
         this.sm = (SessionManagerI) blitz.getBlitzManager();
         this.sm.setApplicationContext(ctx);
         this.ctx.addApplicationListener(this.sm);
---------------
-------------
@@ -342,6 +342,8 @@
             if (effIds == null || effIds.size() == 0) {
                 return new HashSet();
             }
+            /* paging has now been done */
+            options = options.page(0, Integer.MAX_VALUE);
         }
 
         Query<List<IObject>> q = getQueryFactory().lookup(
---------------
-------------
@@ -51,7 +51,7 @@
 	 * @return the path components
 	 */
 	private static List<String> splitComponents(String path, char separator) {
-		final String[] splitBySeparator = path.split("\\" + File.separatorChar);
+		final String[] splitBySeparator = path.split("\\" + separator);
 		final List<String> components = new ArrayList<String>(splitBySeparator.length);
 		for (final String component : splitBySeparator) {
 			if (!component.isEmpty()) 
---------------
-------------
@@ -131,7 +131,7 @@
         commentPanel = GuiCommonElements.addMainPanel(this, commentTable, 10,10,10,10, debug);
 
         String message = "Thank you for taking the time to send us your comments. \n\n" +
-                "Your feedback will be used to futher the developmment of the " +
+                "Your feedback will be used to further the developmment of the " +
                 "importer and improve our software. Any personal details you provide are" +
                 " purely optional, and will only be used for development purposes.";
 
---------------
-------------
@@ -292,6 +292,7 @@
         Image i = new ImageI();
         i.getDetails().setOwner( e );
         i.setName( rstring(name) );
+        i.setAcquisitionDate( rtime(0) );
         i = push(i);
         return i;
     }
---------------
-------------
@@ -49,7 +49,6 @@
 import ome.system.Principal;
 import ome.system.Roles;
 import ome.system.ServiceFactory;
-import omero.model.IObject;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
---------------
-------------
@@ -91,7 +91,7 @@
     /** Query to load the number of annotations per plate. */
     final static String loadCountsPlates = "select p from Plate p "
             + "left outer join fetch p.annotationLinksCountPerOwner " 
-            + "in (:list)";
+            + "where p in (:list)";
     
     /**
      * Implemented as speficied by the {@link IContainer} I/F
---------------
-------------
@@ -579,7 +579,7 @@
             }
 
             // ticket:3529
-            else if (/*(bec.getCurrentGroupId() < 0) &&*/
+            else if ((bec.getCurrentGroupId() < 0) &&
                     (isAdmin || bec.getMemberOfGroupsList()
                         .contains(sourceGroupId))) {
                 newDetails.setGroup(source.getGroup());
---------------
-------------
@@ -579,7 +579,7 @@
             }
 
             // ticket:3529
-            else if ((bec.getCurrentGroupId() < 0) &&
+            else if (/*(bec.getCurrentGroupId() < 0) &&*/
                     (isAdmin || bec.getMemberOfGroupsList()
                         .contains(sourceGroupId))) {
                 newDetails.setGroup(source.getGroup());
---------------
-------------
@@ -149,7 +149,7 @@
     if (eventbits == ONSUBMIT) {
       sinkSubmitEvent(element);
     } else {
-      if ((eventbits | Event.FOCUSEVENTS) == Event.FOCUSEVENTS) {
+      if ((eventbits | Event.FOCUSEVENTS) == Event.FOCUSEVENTS && element.getAttribute("tabIndex").length() == 0) {
         element.setAttribute("tabIndex", "0");
       }
       DOM.sinkEvents((com.google.gwt.user.client.Element) element, eventbits
---------------
-------------
@@ -500,7 +500,7 @@
         private final String loggerName;
         private final Message message;
         private final long timeMillis;
-        private final Throwable thrown;
+        private final transient Throwable thrown;
         private final ThrowableProxy thrownProxy;
         private final Map<String, String> contextMap;
         private final ThreadContext.ContextStack contextStack;
---------------
-------------
@@ -56,7 +56,7 @@
     Pipe pipe = new Each( previous, argumentFieldSelector, new Identity( new Fields( "n", "l", "v" ) ) );
 
     // name and rate against others of same movie
-    pipe = new Group( pipe, new Fields( "l" ), 2, new Fields( "n1", "l", "v1", "n2", "l2", "v2" ) );
+    pipe = new Group( pipe, new Fields( "l" ), 1, new Fields( "n1", "l", "v1", "n2", "l2", "v2" ) );
 
     // remove useless fields
     pipe = new Each( pipe, new Fields( "l", "n1", "v1", "n2", "v2" ), new Identity() );
---------------
-------------
@@ -262,7 +262,7 @@
 
       LOG.debug( "handling path: {}", stringPath );
 
-      URI uri = new URI( stringPath );
+      URI uri = new Path( stringPath ).toUri(); // safer URI parsing
       String schemeString = uri.getScheme();
       String authority = uri.getAuthority();
 
---------------
-------------
@@ -118,7 +118,7 @@
 
 			boolean matchesPath = operationPath.equals( pathToFind );
 			boolean matchesVerb = verbToFind == operationVerb;
-			boolean matchesPathPartially = pathToFind.contains( operationPath );
+			boolean matchesPathPartially = pathToFind.startsWith( operationPath );
 
 			if( matchesPath && matchesVerb )
 			{
---------------
-------------
@@ -55,7 +55,7 @@
         String containerType = System.getProperty(CONTAINER_TYPE_PROPERTY, "child");
         int numberOfContainers = Math.max(minimumNumber, Integer.parseInt(System.getProperty(CONTAINER_NUMBER_PROPERTY, "1")));
 
-        if (maximumNumber < numberOfContainers) {
+        if (maximumNumber < numberOfContainers && maximumNumber != 0) {
             numberOfContainers = minimumNumber;
         }
 
---------------
-------------
@@ -109,7 +109,6 @@
         }
 
         bridgeConnector.setLocalBrokerConfig(createBrokerConfig(pid, "localBroker", properties));
-        bridgeConnector.setRemoteBrokerConfig(createBrokerConfig(pid, "remoteBroker", properties));
         bridgeConnector.setExportedBrokerConfig(createBrokerConfig(pid, "exportedBroker", properties));
 
 
---------------
-------------
@@ -86,7 +86,7 @@
     public static final String COMPONENT_NAME = COMPONENT_PID;
 
     public static final String DEFAULT_ADMIN_USER = "admin";
-    public static final String DEFAULT_ADMIN_ROLE = "admin";
+    public static final String DEFAULT_ADMIN_ROLE = "admin,manager,viewer";
     public static final String ROLE_DELIMITER = ",";
 
     @Reference
---------------
-------------
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) FuseSource, Inc.
  * http://fusesource.com
  *
---------------
-------------
@@ -179,7 +179,7 @@
 
             for (String key : getRestricted().keySet()) {
                 Type type = getRestricted().get(key);
-                if (type.getProvides() != null && !getEnums().containsKey(key)) {
+                if (type.getProvides() != null && !getEnums().containsKey(key) && !getDescribed().containsKey(key)) {
                     String className = getTypes() + "." + toJavaClassName(key);
                     restrictedTypes.add(new RestrictedType(this, className, type));
                 }
---------------
-------------
@@ -229,7 +229,7 @@
 	 */
 	public Integer getErrorCode() {
 		try {
-			return Integer.parseInt(this.getProperty("error_code"));
+			return (Integer)this.getObject("error_code");
 		} catch (NumberFormatException e) {
 			return null;
 		}
---------------
-------------
@@ -83,6 +83,6 @@
 	 * @param events Events to provide callbacks for.
 	 */
 	public void setStatusCallbackEvents(String events) {
-		this.set("statusCallbackEvents", events);
+		this.set("statusCallbackEvent", events);
 	}
 }
---------------
-------------
@@ -73,7 +73,7 @@
 	 */
 	@Override
 	protected String getListKey() {
-		return "ip_access_control_lists";
+		return "ip_addresses";
 	}
 
 	/**
---------------
-------------
@@ -294,7 +294,6 @@
                 mongoDB.getCollection("PERSONNEL").drop();
                 mongoDB.getCollection("ADDRESS").drop();
                 mongoDB.getCollection("PERSONNEL_ADDRESS").drop();
-                
             }
             catch (SecurityException e)
             {
---------------
-------------
@@ -640,6 +640,7 @@
         {
             Index index = schemaTable.getIndex(colName);
             IndexKey indexKey = index.createIndexKey();
+            NoSqlDBUtils.add(schemaTable.getField(colName), indexKey, colValue, colName);
             rowsIter = tableAPI.tableIterator(indexKey, null, null);
         }
 
---------------
-------------
@@ -598,7 +598,7 @@
 
             for (CounterColumn counterColumn : tr.getCounterColumns())
             {
-                initialize(tr, m, entity);
+                entity = initialize(tr, m, entity);
                 onCounterColumn(counterColumn, m, entity, entityType, relationNames, isWrapReq, relations);
             }
 
---------------
-------------
@@ -176,7 +176,7 @@
 
     @Override
     public boolean flatEquals(final Entity otherEntity) {
-        return definitionsAndIdsAreEqual(otherEntity) && fieldsAreEquals(otherEntity, null, true);
+        return otherEntity != null && definitionsAndIdsAreEqual(otherEntity) && fieldsAreEquals(otherEntity, null, true);
     }
 
     @Override
---------------
-------------
@@ -677,7 +677,7 @@
                                 || mOrientationHelper.getDecoratedEnd(referenceChild)
                                 < mOrientationHelper.getStartAfterPadding();
                 if (notVisible) {
-                    anchorInfo.mCoordinate = mShouldReverseLayout
+                    anchorInfo.mCoordinate = anchorInfo.mLayoutFromEnd
                             ? mOrientationHelper.getEndAfterPadding()
                             : mOrientationHelper.getStartAfterPadding();
                 }
---------------
-------------
@@ -52,7 +52,6 @@
    public EnumConstant<JavaEnum> addEnumConstant()
    {
       EnumConstantImpl<JavaEnum> enumConst = new EnumConstantImpl<JavaEnum>(this);
-      EnumConstantImpl enumConst = new EnumConstantImpl(this);
       EnumDeclaration enumDeclaration = (EnumDeclaration) getBodyDeclaration();
       List<EnumConstantDeclaration> constants = enumDeclaration.enumConstants();
       constants.add((EnumConstantDeclaration) enumConst.getInternal());
---------------
-------------
@@ -161,7 +161,7 @@
         while(i < numBins && i*2 + 1 < arrayString.length) {
           HistogramBin bin = new HistogramBin();
           bin.setX(Double.parseDouble(arrayString[i*2 + 0]));
-          bin.setX(Double.parseDouble(arrayString[i*2 + 1]));
+          bin.setY(Double.parseDouble(arrayString[i*2 + 1]));
           i += 1;
           bins.add(bin);
         }
---------------
-------------
@@ -161,7 +161,7 @@
         while(i < numBins && i*2 + 1 < arrayString.length) {
           HistogramBin bin = new HistogramBin();
           bin.setX(Double.parseDouble(arrayString[i*2 + 0]));
-          bin.setX(Double.parseDouble(arrayString[i*2 + 1]));
+          bin.setY(Double.parseDouble(arrayString[i*2 + 1]));
           i += 1;
           bins.add(bin);
         }
---------------
-------------
@@ -115,7 +115,7 @@
     private double default_signature_Jaccard_Cutoff   = 0.125;  
     private double default_signature_Overlap_Cutoff   = 0.25;  
     private double default_signature_DirOverlap_Cutoff= 0.25;  
-    private double default_signature_Hypergeom_Cutoff = 0.25;
+    private double default_signature_Hypergeom_Cutoff = 0.05;
     
     private CutoffMetric default_signature_CutoffMetric = CutoffMetric.ABS_NUMBER;
     
---------------
-------------
@@ -24,7 +24,7 @@
     /**
      * trakt API URL.
      */
-    public static final String API_URL = "http://api.trakt.tv";
+    public static final String API_URL = "https://api.trakt.tv";
 
     /**
      * API key path parameter name.
---------------
-------------
@@ -37,7 +37,7 @@
 public class VersionCalculator
 {
 
-    private static final String SERIAL_SUFFIX_PATTERN = "([^-.]+)([-.])(\\d+)?$";
+    private static final String SERIAL_SUFFIX_PATTERN = "([^-.]+)(?:([-.])(\\d+))?$";
 
     private static final String SNAPSHOT_SUFFIX = "-SNAPSHOT";
 
---------------
-------------
@@ -97,6 +97,8 @@
 			//if we could not merge the new polygon, and it is not already there, add it!
 			if (workStack.isEmpty() && !polygons.contains(changedWay)) {
 				polygons.add(changedWay);
+			} else if (!workStack.isEmpty()) {
+				polygons.remove(changedWay);
 			}
 		}
 	}
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -162,9 +162,10 @@
      *            file descriptor pointing to a full snapshot of the
      *            application's data.  The application should consume every
      *            entity represented in this data stream.
-     * @param appVersionCode The
-     *            {@link android.R.styleable#AndroidManifest_versionCode android:versionCode}
-     *            value of the application that backed up this particular data set. This
+     * @param appVersionCode The value of the <a
+     * href="{@docRoot}guide/topics/manifest/manifest-element.html#vcode">{@code
+     *            android:versionCode}</a> manifest attribute,
+     *            from the application that backed up this particular data set. This
      *            makes it possible for an application's agent to distinguish among any
      *            possible older data versions when asked to perform the restore
      *            operation.
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -93,7 +93,7 @@
                     webView.addJavascriptInterface(object, name);
                     webView.getSettings().setJavaScriptEnabled(true);
                     webView.setWebViewClient(mWebViewClient);
-                    webView.loadData("<html><head></head><body></body></html>", "text/html", null);
+                    webView.loadData("<!DOCTYPE html><title></title>", "text/html", null);
                 }
             });
             mWebViewClient.waitForOnPageFinished();
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -23,7 +23,6 @@
 
     public static String[] children() {
         return new String[] {
-                StringTest.class.getName(),
                 HashMapPerformanceTest.class.getName(),
                 ArrayListPerformanceTest.class.getName(),
                 TreeMapPerformanceTest.class.getName(),
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -56,7 +56,7 @@
     static Pattern sAddressPattern = Pattern.compile(
             /* scheme    */ "(?:(http|https|file)\\:\\/\\/)?" +
             /* authority */ "(?:([-A-Za-z0-9$_.+!*'(),;?&=]+(?:\\:[-A-Za-z0-9$_.+!*'(),;?&=]+)?)@)?" +
-            /* host      */ "([-" + GOOD_IRI_CHAR + "%_]+(?:\\.[-" + GOOD_IRI_CHAR + "%_]+)*|\\[[0-9a-fA-F:\\.]+\\])?" +
+            /* host      */ "([" + GOOD_IRI_CHAR + "%_-][" + GOOD_IRI_CHAR + "%_\\.-]*|\\[[0-9a-fA-F:\\.]+\\])?" +
             /* port      */ "(?:\\:([0-9]*))?" +
             /* path      */ "(\\/?[^#]*)?" +
             /* anchor    */ ".*", Pattern.CASE_INSENSITIVE);
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -152,7 +152,13 @@
             concatRef.refNumber = refNumber;
             concatRef.seqNumber = i + 1;  // 1-based sequence
             concatRef.msgCount = msgCount;
-            concatRef.isEightBits = false;
+            // TODO: We currently set this to true since our messaging app will never
+            // send more than 255 parts (it converts the message to MMS well before that).
+            // However, we should support 3rd party messaging apps that might need 16-bit
+            // references
+            // Note:  It's not sufficient to just flip this bit to true; it will have
+            // ripple effects (several calculations assume 8-bit ref).
+            concatRef.isEightBits = true;
             SmsHeader smsHeader = new SmsHeader();
             smsHeader.concatRef = concatRef;
 
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -513,6 +513,8 @@
 		if (closed)
 			throw new IllegalStateException("Cannot perform query on database that was closed.");
 		
+		executePendingStatements();
+		
 		Formula f = query.getFormula();
 		VariableAssignment partialGrounding = query.getPartialGrounding();
 		Set<Variable> projectTo = query.getProjectionSubset();
---------------
-------------
@@ -69,7 +69,7 @@
 		}
 		else if (x.length == 2) {
 			x[0] = reasoner.stepSize * reasoner.z.get(zIndices[0]) - y[0];
-			x[0] -= reasoner.stepSize * coeffs[0] / coeffs[1] * (-1 * constant / coeffs[1] + reasoner.z.get(zIndices[1]) - y[1]);
+			x[0] -= reasoner.stepSize * coeffs[0] / coeffs[1] * (-1 * constant / coeffs[1] + reasoner.z.get(zIndices[1]) - y[1]/reasoner.stepSize);
 			x[0] /= reasoner.stepSize * (1 + coeffs[0] * coeffs[0] / coeffs[1] / coeffs[1]);
 			
 			x[1] = (constant - coeffs[0] * x[0]) / coeffs[1];
---------------
-------------
@@ -116,7 +116,7 @@
     return this;
   }
 
-  public StringBuilder append(StringBuilder x) {
+  public StringBuilder append(StringBuffer x) {
     impl.append(data, x);
     return this;
   }
---------------
-------------
@@ -234,7 +234,8 @@
 
     @Override
     public String toString() {
-      return (isRed ? "R: " : "B: ") + key + "=" + value;
+      // for compatibility with the real Jre: issue 3422
+      return key + "=" + value;
     }
   }
 
---------------
-------------
@@ -58,7 +58,7 @@
 
   /**
    * A configuration property that can be used to have the linker load from
-   * somewhere other than {@link #FRAGMENT_SUBDIR}
+   * somewhere other than {@link #FRAGMENT_SUBDIR}.
    */
   private static final String PROP_FRAGMENT_SUBDIR_OVERRIDE = "iframe.linker.deferredjs.subdir";
 
---------------
-------------
@@ -29,6 +29,8 @@
 /**
  * Combines the information conveyed about a set of path prefixes to quickly
  * answer questions regarding an entire set of path prefixes.
+ * <p>
+ * Is effectively immutable and should not be modified after initial use.
  */
 public class PathPrefixSet {
   /*
---------------
-------------
@@ -1498,7 +1498,7 @@
             isCurrencyFormat = true;
             if ((pos + 1) < len && pattern.charAt(pos + 1) == CURRENCY_SIGN) {
               ++pos;
-              if (pos < len - 3 && pattern.charAt(pos + 1) == CURRENCY_SIGN
+              if (pos < len - 2 && pattern.charAt(pos + 1) == CURRENCY_SIGN
                   && pattern.charAt(pos + 2) == CURRENCY_SIGN) {
                 pos += 2;
                 affix.append(currencyData.getSimpleCurrencySymbol());
---------------
-------------
@@ -218,7 +218,7 @@
   }
 
   public ListIterator<E> listIterator() {
-    return new ListIteratorImpl();
+    return listIterator(0);
   }
 
   public ListIterator<E> listIterator(int from) {
---------------
-------------
@@ -110,7 +110,8 @@
   }
 
   /**
-   * Returns the set of properties defined on this JSONObject.
+   * Returns the set of properties defined on this JSONObject. The returned set
+   * is immutable.
    */
   public Set<String> keySet() {
     final String[] keys = computeKeys();
---------------
-------------
@@ -138,7 +138,7 @@
    * @return
    */
   public String getFormValue() {
-    return inputElem.getAttribute("value");
+    return inputElem.getValue();
   }
 
   @Override
---------------
-------------
@@ -121,7 +121,7 @@
     Object[] result = a;
     Iterator<E> it = iterator();
     for (int i = 0; i < size; ++i) {
-      result[i++] = it.next();
+      result[i] = it.next();
     }
     if (a.length > size) {
       a[size] = null;
---------------
-------------
@@ -74,7 +74,7 @@
 
     if (Double.isNaN(d)) {
       // IEEE754, NaN exponent bits all 1s, and mantissa is non-zero
-      return EXPONENT_MASK | NAN_MANTISSA;
+      return (1L << (EXPONENT_BITSIZE -1)) | NAN_MANTISSA;
     }
     if (Double.isInfinite(d)) {
       // an infinite number is a number with a zero mantissa and all
---------------
-------------
@@ -215,7 +215,8 @@
 
   /**
    * This method may collapse adjacent text nodes into one text node, depending
-   * on the implementation.
+   * on the implementation. Safari 4.0 and Chrome will also merge CDATA nodes
+   * into text nodes, even though they support CDATA nodes as distinct nodes.
    */
   void normalize();
 
---------------
-------------
@@ -130,7 +130,7 @@
     decPanel = new DecoratorPanel(rowStyles, 1);
     decPanel.setStyleName("");
     setStylePrimaryName(DEFAULT_STYLENAME);
-    setWidget(decPanel);
+    super.setWidget(decPanel);
     setStyleName(getContainerElement(), "popupContent", false);
     setStyleName(decPanel.getContainerElement(), prefix + "Content", true);
   }
---------------
-------------
@@ -199,7 +199,7 @@
         orderEffectiveStartDate.setFieldValue(DateUtils.toDateTimeString((Date) order.getField(OrderFields.EFFECTIVE_DATE_FROM)));
         orderPlannedStartDate.requestComponentUpdateState();
         orderCorrectedStartDate.requestComponentUpdateState();
-        orderPlannedStartDate.requestComponentUpdateState();
+        orderEffectiveStartDate.requestComponentUpdateState();
     }
 
     public void disableReasonOfCorrection(final ViewDefinitionState view) {
---------------
-------------
@@ -100,7 +100,7 @@
 
     @RequestMapping(value = "systemInfo", method = RequestMethod.GET)
     public ModelAndView getSystemInfoView(@RequestParam final Map<String, String> arguments, final Locale locale) {
-        ModelAndView mav = crudController.prepareView("core", "systemInfo", arguments, locale);
+        ModelAndView mav = crudController.prepareView("basic", "systemInfo", arguments, locale);
 
         Map<String, String> translationsMap = new HashMap<String, String>();
         translationsMap.put("core.systemInfo.header", translationService.translate("core.systemInfo.header", locale));
---------------
-------------
@@ -42,7 +42,7 @@
     @Autowired
     private MaterialRequirementServiceImplTSOverrideUtil materialRequirementServiceImplTSOverrideUtil;
 
-    @Pointcut("execution(public com.qcadoo.mes.technologies.constants.MrpAlgorithm com.qcadoo.mes.materialRequirements.internal.MaterialRequirementServiceImpl.getDefaultMrpAlgorithm(..))")
+    @Pointcut("execution(public com.qcadoo.mes.technologies.constants.MrpAlgorithm com.qcadoo.mes.materialRequirements.MaterialRequirementServiceImpl.getDefaultMrpAlgorithm(..))")
     public void getDefaultMrpAlgorithmExecution() {
     }
 
---------------
-------------
@@ -38,7 +38,7 @@
         if (shift != null)
             logging.setField("shift", shift);
         else
-            throw new IllegalStateException();
+            logging.setField("shift", null);
         logging.setField("worker", securityService.getCurrentUserName());
         logging.setField("dateAndTime", dateTime);
 
---------------
-------------
@@ -568,7 +568,7 @@
       for (File outputFile : oldState.getOutputFiles()) {
         if (!processedOutputs.containsKey(outputFile)) {
           for (File inputFile : oldState.getAssociatedInputs(outputFile)) {
-            if (registeredInputs.containsKey(inputFile)) {
+            if (registeredInputs.containsKey(inputFile) && !processedInputs.containsKey(inputFile)) {
               result.add((OutputMetadata<T>) new DefaultOutputMetadata(this, oldStateAdaptor,
                   outputFile));
               break;
---------------
-------------
@@ -345,7 +345,7 @@
         oldState != null ? oldState.outputs.get(outputFile) : null;
 
     if (oldOutputState == null) {
-      if (state.outputs.containsKey(outputFile)) {
+      if (processedOutputs.containsKey(outputFile)) {
         return ResourceStatus.NEW;
       }
       throw new IllegalArgumentException("Output is not processed " + outputFile);
---------------
-------------
@@ -749,7 +749,7 @@
             inputIncludedInputs.put(inputFile, new LinkedHashSet<File>(includedInputs));
 
             for (File includedInput : includedInputs) {
-              putInputFileState(includedInput, oldState.getFileState(inputFile));
+              putInputFileState(includedInput, oldState.getFileState(includedInput));
             }
           }
 
---------------
-------------
@@ -91,7 +91,7 @@
       order = new Order(rnr);
       SupplyLine supplyLine = supplyLineService.getSupplyLineBy(new SupervisoryNode(rnr.getSupervisoryNodeId()), rnr.getProgram());
       order.setSupplyLine(supplyLine);
-      if (!fulfillmentPermissionService.hasPermission(userId, supplyLine.getSupplyingFacility().getId(), Right.CONVERT_TO_ORDER)) {
+      if (!fulfillmentPermissionService.hasPermissionOnWarehouse(userId, supplyLine.getSupplyingFacility().getId(), Right.CONVERT_TO_ORDER)) {
         throw new AccessDeniedException("user.not.authorized");
       }
       OrderStatus status;
---------------
-------------
@@ -111,7 +111,7 @@
   }
 
   public void clickInitiateDistribution() {
-    testWebDriver.waitForElementToAppear(initiateDistributionButton);
+    testWebDriver.waitForElementToBeEnabled(initiateDistributionButton);
     initiateDistributionButton.click();
   }
 
---------------
-------------
@@ -767,6 +767,7 @@
   }
 
   private void verifyElementsPresent() {
+    distributionPage = PageFactory.getInstanceOfDistributionPage(testWebDriver);
     assertTrue("selectDeliveryZoneSelectBox should be present", distributionPage.IsDisplayedSelectDeliveryZoneSelectBox());
     assertTrue("selectProgramSelectBox should be present", distributionPage.IsDisplayedSelectProgramSelectBox());
     assertTrue("selectPeriodSelectBox should be present", distributionPage.IsDisplayedSelectPeriodSelectBox());
---------------
-------------
@@ -97,7 +97,7 @@
     {
         testWebDriver.waitForElementToAppear(requisitionHeader);
         String headerText=testWebDriver.getText(requisitionHeader);
-        //SeleneseTestNgHelper.assertTrue(headerText.contains("Report and Requisition for "+program));
+        SeleneseTestNgHelper.assertTrue(headerText.contains("Report and Requisition for "+program));
         String facilityText=testWebDriver.getText(facilityLabel);
         SeleneseTestNgHelper.assertTrue(facilityText.contains(FCode + FCstring + " - " + FName + FCstring));
 
---------------
-------------
@@ -21,7 +21,7 @@
   protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) {
     Order order = (Order) model.get(ORDER);
 
-    String fileName = "O" + System.currentTimeMillis() + ".csv";
+    String fileName = "O" + order.getId() + ".csv";
     response.setHeader("Content-Disposition", "attachment; filename=" + fileName);
 
     try (BufferedWriter writer = new BufferedWriter(response.getWriter())) {
---------------
-------------
@@ -109,7 +109,7 @@
             return new ResponseEntity<ModelMap>(modelMap, HttpStatus.BAD_REQUEST);
         }
         modelMap.put("facility", facility);
-        modelMap.put("success", facility.getName() + " / " + facility.getCode() +" "+ message + " successfully");
+        modelMap.put("success", "\"" + facility.getName() + "\" / \"" + facility.getCode() +"\" "+ message + " successfully");
         return new ResponseEntity<ModelMap>(modelMap, HttpStatus.OK);
     }
 
---------------
-------------
@@ -63,7 +63,7 @@
   RequisitionGroup getByCode(String code);
 
   @Update("UPDATE requisition_groups " +
-    "SET code = #{code}, name = #{name}, description =  #{description}, supervisoryNodeId = #{supervisoryNode.id}, modifiedBy = #{modifiedBy}, modifiedDate = #{modifiedDate} " +
+    "SET code = #{code}, name = #{name}, description =  #{description}, supervisoryNodeId = #{supervisoryNode.id}, modifiedBy = #{modifiedBy}, modifiedDate = COALESCE(#{modifiedDate}, CURRENT_TIMESTAMP) " +
     "WHERE id = #{id}")
   void update(RequisitionGroup requisitionGroup);
 
---------------
-------------
@@ -119,7 +119,7 @@
   @FindBy(how = XPATH, using = "//ng-include/div/ul/li[2]/a/span[@class='status-icon']")
   public static WebElement overallRefrigeratorIcon = null;
 
-  @FindBy(how = XPATH, using = "//div[@id='addRefrigeratorModal']/div[2]/div[3]/div/div")
+  @FindBy(how = ID, using = "duplicateSerialNumberError")
   public static WebElement duplicateRefrigeratorMessage = null;
 
   @FindBy(how = ID, using = "noRefrigerators")
---------------
-------------
@@ -137,7 +137,7 @@
     isAddedBy = commentAddedBy.getText().contains("By: " + AddedBy);
     assertTrue(isAddedBy);
     Date date = new Date();
-    SimpleDateFormat ft = new SimpleDateFormat("dd/MM/YYYY");
+    SimpleDateFormat ft = new SimpleDateFormat("dd/MM/yyyy");
     isAddedOn = commentAddedBy.getText().contains(ft.format(date));
     assertTrue(isAddedOn);
     commentCloseIcon.click();
---------------
-------------
@@ -56,7 +56,7 @@
     try {
       report.validateForApproval();
       restRequisitionService.approve(report, requisitionId, loggedInUserId(principal));
-      return success("msg.rnr.approve.success");
+      return success("msg.rnr.approved.success");
     } catch (DataException e) {
       return error(e.getOpenLmisMessage(), BAD_REQUEST);
     }
---------------
-------------
@@ -80,7 +80,7 @@
     client.createContext();
 
     Report reportFromJson = readObjectFromFile(FULL_JSON_APPROVE_TXT_FILE_NAME, Report.class);
-    reportFromJson.setUserId("commTrack1");
+    reportFromJson.setUserName("commTrack1");
     reportFromJson.setRequisitionId(id);
     reportFromJson.getProducts().get(0).setProductCode("P10");
     reportFromJson.getProducts().get(0).setQuantityApproved(quantityApproved);
---------------
-------------
@@ -37,7 +37,7 @@
   }
 
   public List<Program> getByFacility(Integer facilityId) {
-    return programMapper.getActiveByFacility(facilityId);
+    return programMapper.getByFacilityId(facilityId);
   }
 
   public List<Program> getAll() {
---------------
-------------
@@ -83,7 +83,7 @@
     Map<String, String> validationErrorMessages = new HashMap<>();
     for (Map.Entry<String, OpenLmisMessage> entry : validationErrors.entrySet()) {
       String fieldName = entry.getKey();
-      validationErrorMessages.put(fieldName, messageService.message(entry.getValue()));
+      validationErrorMessages.put(fieldName, messageService.message(entry.getValue().getCode(), entry.getValue().getParams()));
     }
     return validationErrorMessages;
   }
---------------
-------------
@@ -114,7 +114,7 @@
     } else if (csvFile == null || csvFile.isEmpty()) {
       errorMessage = new OpenLmisMessage(FILE_IS_EMPTY);
     } else if (!csvFile.getOriginalFilename().endsWith(".csv")) {
-      errorMessage = new OpenLmisMessage(INCORRECT_FILE_FORMAT, model);
+      errorMessage = new OpenLmisMessage(messageService.message(INCORRECT_FILE_FORMAT, uploadBeansMap.get(model).getDisplayName()));
     }
     return errorMessage;
   }
---------------
-------------
@@ -42,7 +42,7 @@
   private Integer calculateTargetGroup(Double whoRatio, Long catchmentPopulation) {
     Integer targetGroup = null;
     if (whoRatio != null && catchmentPopulation != null) {
-      targetGroup = (int) round(catchmentPopulation * whoRatio);
+      targetGroup = (int) round(catchmentPopulation * whoRatio / 100);
     }
     return targetGroup;
   }
---------------
-------------
@@ -267,6 +267,8 @@
 
     assertFalse("notesTextArea enabled.", notesTextArea.isEnabled());
 
+    assertFalse("Add new button enabled", addNewButton.isEnabled());
+    assertFalse("Delete button enabled", deleteButton.isEnabled());
   }
 
   public void clickProblemSinceLastVisitNoRadio() {
---------------
-------------
@@ -27,7 +27,6 @@
 import org.jbpm.task.Task;
 import org.jbpm.task.annotations.External;
 import org.jbpm.task.api.TaskServiceEntryPoint;
-import org.jbpm.task.events.AfterTaskAddedEvent;
 import org.jbpm.task.events.AfterTaskCompletedEvent;
 import org.jbpm.task.events.AfterTaskFailedEvent;
 import org.jbpm.task.events.AfterTaskSkippedEvent;
---------------
-------------
@@ -200,7 +200,7 @@
 	        System.out.println("Apache Mina Task service running ...");
 	        
         } else if ("hornetq".equalsIgnoreCase(activeConfig)) {
-        	int port = Integer.parseInt(getConfigParameter("hornetq.port", "5446"));
+        	int port = Integer.parseInt(getConfigParameter("hornetq.port", "5445"));
         	
         	server = new HornetQTaskServer(taskService, port);
     		thread = new Thread(server);
---------------
-------------
@@ -261,7 +261,7 @@
         for (Path domainDir : domainDirs) {
             String dirName = domainDir.getFileName().toString();
             Domain domain = new Domain();
-            domain.setName(dirName + " Domain");
+            domain.setName(dirName);
             List<RuntimeId> runtimesRelease = new ArrayList<RuntimeId>();
             RuntimeId releaseRuntime = new RuntimeId();
             releaseRuntime.setName(dirName + " Runtime");
---------------
-------------
@@ -126,7 +126,7 @@
 
     List<TaskSummary> getTasksAssignedAsPotentialOwner(String userId, List<String> groupIds, String language);
 
-    List<TaskSummary> getTasksAssignedAsPotentialOwner(String userId, List<String> groupIds, String language, int firstResult, int maxResult);
+    List<TaskSummary> getTasksAssignedAsPotentialOwner(String userId, List<String> groupIds, String language, int firstResult, int maxResults);
 
     List<TaskSummary> getTasksAssignedAsPotentialOwner(String userId, String language);
 
---------------
-------------
@@ -197,7 +197,7 @@
                 oIn.close();
                 bs.close();
             } catch (Exception e) {
-                throw new RuntimeException("Error when accessing task content, e");
+            	 doc = (Map<String, Object>) TaskService.eval( new InputStreamReader(new ByteArrayInputStream(content.getContent())) );
             }
         } else {
             doc = Collections.emptyMap();
---------------
-------------
@@ -128,7 +128,7 @@
             String rules = generateRules( process );
 //            System.out.println(rules);
             try {
-                packageBuilder.addPackageFromDrl( new StringReader( rules ) );
+                packageBuilder.addPackageFromDrl( new StringReader( rules ), resource );
             } catch ( IOException e ) {
                 // should never occur
                 e.printStackTrace( System.err );
---------------
-------------
@@ -407,7 +407,7 @@
 			{
 				GroupedRunnable taskToRun;
 				synchronized (groupedNotifyTaskMap) {
-					taskToRun = tasks.pollLast();
+					taskToRun = tasks.pollFirst();
 					if (taskToRun == null) {
 						groupedNotifyTaskMap.remove(key);
 						break;
---------------
-------------
@@ -56,7 +56,7 @@
             
             // does the output have fitting size?
             int expected = query.getOutput().size();
-            int actual = query.getInput().size();
+            int actual = query.getSuffix().size();
             if(actual != expected) {
                 throw new RuntimeException("Query output in query batch with index " + i + " does not have fitting size: Expected size is " + expected + ", actual size is " + actual);
             }
---------------
-------------
@@ -68,6 +68,7 @@
         // "2007-07-25T09:26:24{Z|{+|-}01:00}"
         if (checkLayout(str, "xxxx-xx-xxTxx:xx:xxZ") ||
                 checkLayout(str, "xxxx-xx-xxTxx:xx:xx") ||
+                checkLayout(str, "xxxx-xx-xx xx:xx:xx UTC") ||
                 checkLayout(str, "xxxx-xx-xxTxx:xx:xx+xx:00") ||
                 checkLayout(str, "xxxx-xx-xxTxx:xx:xx-xx:00")) {
             calendar.set(
---------------
-------------
@@ -67,7 +67,7 @@
             set(1103, marktr("amenities type {0}"), test);
         }
         test = w.get("sport");
-        if (test != null && !test.equals("water_slide")) {
+        if (test != null && !test.equals("water_slide") && !test.equals("climbing")) {
             set(1104, marktr("sport type {0}"), test);
         }
         test = w.get("tourism");
---------------
-------------
@@ -202,7 +202,7 @@
 
         // Format
         // tag1\tval1\ntag2\tval2\n
-        tags = readTagsByRegexp(buf, "[\\r\\n]+", ".*([a-zA-Z0-9:_]+).*\\t(.*?)", false);
+        tags = readTagsByRegexp(buf, "[\\r\\n]+", ".*?([a-zA-Z0-9:_]+).*\\t(.*?)", false);
                 // try "tag\tvalue\n" format
         if (tags!=null) return tags;
 
---------------
-------------
@@ -259,7 +259,7 @@
                 return e.child != null;
             } else if (ChildOrParentSelectorType.SIBLING.equals(type)) {
                 if (e.osm instanceof Node) {
-                    for (Way w : Utils.filteredCollection(e.osm.getReferrers(), Way.class)) {
+                    for (Way w : Utils.filteredCollection(e.osm.getReferrers(true), Way.class)) {
                         final int i = w.getNodes().indexOf(e.osm);
                         if (i - 1 >= 0) {
                             final Node n = w.getNode(i - 1);
---------------
-------------
@@ -954,6 +954,7 @@
         // Method copied from OsmPrimitive in josm-ng
         // Returns only referrers that are members of the same dataset (primitive can have some fake references, for example
         // when way is cloned
+        checkDataset();
         List<OsmPrimitive> result = new ArrayList<OsmPrimitive>();
         if (referrers != null) {
             if (referrers instanceof OsmPrimitive) {
---------------
-------------
@@ -143,7 +143,7 @@
             }
         }
 
-        int tz = cal.getTimeZone().getRawOffset();
+        int tz = cal.getTimeZone().getOffset(cal.getTimeInMillis());
         if (tz == 0) {
             sb.append("Z");
         } else {
---------------
-------------
@@ -349,7 +349,7 @@
                 if (!(secondaryType instanceof SecondaryType)) {
                     throw new IllegalArgumentException(
                             "Secondary types property contains a type that is not a secondary type: "
-                                    + secondaryType.getId());
+                                    + secondaryTypeId);
                 }
 
                 allSecondaryTypes.add((SecondaryType) secondaryType);
---------------
-------------
@@ -96,7 +96,7 @@
 
             // create and fetch the document
             ObjectId id = session.createDocument(properties, testFolder, contentStream, versioningState);
-            Document doc = (Document) session.getObject(id);
+            Document doc = (Document) session.getObject(id, SELECT_ALL_NO_CACHE_OC);
 
             // check the new document
             addResult(checkObject(session, doc, getAllProperties(doc), "New document object spec compliance"));
---------------
-------------
@@ -81,7 +81,7 @@
         final List<HTML.Tag> breakers = new ArrayList<HTML.Tag>();
         breakers.add(HTML.Tag.DIV);
         breakers.add(HTML.Tag.H1);
-        breakers.add(HTML.Tag.H3);
+        breakers.add(HTML.Tag.H2);
         breakers.add(HTML.Tag.H3);
         breakers.add(HTML.Tag.H4);
         breakers.add(HTML.Tag.H5);
---------------
-------------
@@ -1,3 +1,21 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
 package org.apache.isis.security.shiro.authorization;
 
 import org.junit.Assert;
---------------
-------------
@@ -63,7 +63,7 @@
     }
 
     private static String faPrefix(final String cssClass) {
-        return cssClass.startsWith("fa-")
+        return cssClass.startsWith("fa-") || "fa".equals(cssClass)
                 ? cssClass
                 : "fa-" + cssClass;
     }
---------------
-------------
@@ -1,4 +1,4 @@
-package org.gradle.api.plugins.sonar.runner.SonarRunnerSmokeIntegrationTest.shared.nested.nested2.nestedProject.src.test.java.org.gradle.test.nestedProject;
+package org.gradle.test.nestedProject;
 
 import static org.junit.Assert.*;
 
---------------
-------------
@@ -22,7 +22,7 @@
  * An enumeration of Java versions.
  */
 public enum JavaVersion {
-    VERSION_1_1(false), VERSION_1_2(false), VERSION_1_3(false), VERSION_1_4(false), VERSION_1_5(true), VERSION_1_6(true);
+    VERSION_1_1(false), VERSION_1_2(false), VERSION_1_3(false), VERSION_1_4(false), VERSION_1_5(true), VERSION_1_6(true), VERSION_1_7(true);
 
     private final boolean hasMajorVersion;
 
---------------
-------------
@@ -1,4 +1,4 @@
-package org.gradle.test.nestedProject;
+package org.gradle.api.plugins.sonar.runner.SonarRunnerSmokeIntegrationTest.shared.nested.nested2.nestedProject.src.test.java.org.gradle.test.nestedProject;
 
 import static org.junit.Assert.*;
 
---------------
-------------
@@ -45,7 +45,7 @@
     public String getClassName() {
         if (className == null) {
             URI sourceUri = resource.getURI();
-            String name = StringUtils.substringBeforeLast(StringUtils.substringAfterLast(sourceUri.getPath(), "/"), ".");
+            String name = StringUtils.substringBeforeLast(StringUtils.substringAfterLast(sourceUri.toString(), "/"), ".");
             StringBuilder className = new StringBuilder(name.length());
             for (int i = 0; i < name.length(); i++) {
                 char ch = name.charAt(i);
---------------
-------------
@@ -242,7 +242,7 @@
                     writeRow(c1, c2, results);
                 }
                 catch (Exception e){
-                    LOG.warning(String.format("Error evaluating between %s and %s", c1, c2));
+                    LOG.warning(String.format("Error evaluating between %s and %s", c1.getBestEnglishTitle(lpDao, true), c2.getBestEnglishTitle(lpDao, true)));
                 }
 
             }
---------------
-------------
@@ -65,6 +65,10 @@
         BSFormatter.currencyCode = currencyCode;
     }
 
+    /**
+     * Note that setting the locale does not set the currency as it might be independent.
+     * @param locale
+     */
     public static void setLocale(Locale locale) {
         BSFormatter.locale = locale;
     }
---------------
-------------
@@ -1,3 +1,18 @@
+/*
+ * Copyright 2009-2011 Collaborative Research Centre SFB 632
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package annis.sqlgen;
 
 import java.util.List;
---------------
-------------
@@ -162,7 +162,7 @@
       null : ctx.id.namespace.getText();
     String name = ctx.id.name.getText();
     String value = textFromSpec(ctx.txt);
-    QueryNode.TextMatching textMatching = textMatchingFromSpec(ctx.txt, false);
+    QueryNode.TextMatching textMatching = textMatchingFromSpec(ctx.txt, ctx.NEQ() != null);
     
     QueryAnnotation anno = new QueryAnnotation(namespace,
       name, value, textMatching);
---------------
-------------
@@ -174,7 +174,7 @@
     return result;
   }
   
-  public static List<GenericUserSimilarity.UserUserSimilarity>getTopUserUserSimilarities(
+  public static List<GenericUserSimilarity.UserUserSimilarity> getTopUserUserSimilarities(
     int howMany, Iterator<GenericUserSimilarity.UserUserSimilarity> allSimilarities) {
     
     Queue<GenericUserSimilarity.UserUserSimilarity> topSimilarities
---------------
-------------
@@ -32,9 +32,6 @@
  * response to a feature vector.  This classifier uses 1 of n-1 coding where the 0-th category
  * is not stored explicitly.
  * <p/>
- * TODO: implement symbolic input with string, overall cooccurrence and n-gram hash encoding
- * TODO: implement reporter system to monitor progress
- *
  * Provides the based SGD based algorithm for learning a logistic regression, but omits all
  * annealing of learning rates.  Any extension of this abstract class must define the overall
  * and per-term annealing for themselves.
---------------
-------------
@@ -40,7 +40,7 @@
     double oldTotalWeight = totalWeight;
     totalWeight += weight;
     if (oldTotalWeight <= 0.0) {
-      average = datum * weight;
+    	average = datum;
     } else {
       average = average * oldTotalWeight / totalWeight + datum * weight / totalWeight;
     }
---------------
-------------
@@ -104,7 +104,7 @@
           int classIdx = lower.indexOf(ARFFType.NOMINAL.getIndicator());
           String[] classes = COMMA_PATTERN.split(line.substring(classIdx + 1, line.length() - 1));
           for (int i = 0; i < classes.length; i++) {
-            model.addNominal(label, classes[i].trim(), i);
+            model.addNominal(label, classes[i].trim(), i + 1);
           }
           
         } else if (lower.contains(ARFFType.DATE.getIndicator())) {
---------------
-------------
@@ -44,7 +44,7 @@
   @Override
   public void addToVector(String originalForm, double weight, Vector data) {
     dictionary.add(originalForm);
-    super.addToVector(originalForm, getWeight(originalForm, weight), data);
+    super.addToVector(originalForm, weight, data);
   }
 
   @Override
---------------
-------------
@@ -200,6 +200,7 @@
     log.info("Building average diffs...");
     try {
       buildAverageDiffsLock.writeLock().lock();
+      averageDiffs.clear();
       long averageCount = 0L;
       for (User user : dataModel.getUsers()) {
         averageCount = processOneUser(averageCount, user);
---------------
-------------
@@ -247,7 +247,7 @@
       }
     }
     boolean overwriteOriginalNer = false;
-    if (prevNerEndIndex != (start-1) && nextNerStartIndex != end) {
+    if (prevNerEndIndex != (start-1) || nextNerStartIndex != end) {
       // Cutting across already recognized NEs don't disturb
     } else if (startNer == null) {
       // No old ner, okay to replace
---------------
-------------
@@ -153,7 +153,7 @@
     nonTerminalInfo.put("UCP", new String[][]{{"left"}});
 
     // CONJP: we want different heads for "but also" and "but not" and we don't want "not" to be the head in "not to mention"; now make "mention" head of "not to mention"
-    nonTerminalInfo.put("CONJP", new String[][]{{"right", "CC", "VB", "JJ", "RB", "IN" }});
+    nonTerminalInfo.put("CONJP", new String[][]{{"right", "VB", "JJ", "RB", "IN", "CC" }});
 
     // FRAG: crap rule needs to be change if you want to parse glosses; but it is correct to have ADJP and ADVP before S because of weird parses of reduced sentences.
     nonTerminalInfo.put("FRAG", new String[][]{{"left", "IN"}, {"right", "RB"}, {"left", "NP"}, {"left", "ADJP", "ADVP", "FRAG", "S", "SBAR", "VP"}});
---------------
-------------
@@ -153,7 +153,7 @@
     nonTerminalInfo.put("UCP", new String[][]{{"left"}});
 
     // CONJP: we want different heads for "but also" and "but not" and we don't want "not" to be the head in "not to mention"; now make "mention" head of "not to mention"
-    nonTerminalInfo.put("CONJP", new String[][]{{"right", "CC", "VB", "JJ", "RB", "IN" }});
+    nonTerminalInfo.put("CONJP", new String[][]{{"right", "VB", "JJ", "RB", "IN", "CC" }});
 
     // FRAG: crap rule needs to be change if you want to parse glosses; but it is correct to have ADJP and ADVP before S because of weird parses of reduced sentences.
     nonTerminalInfo.put("FRAG", new String[][]{{"left", "IN"}, {"right", "RB"}, {"left", "NP"}, {"left", "ADJP", "ADVP", "FRAG", "S", "SBAR", "VP"}});
---------------
-------------
@@ -482,7 +482,6 @@
    * @return A String array corresponding to the encoded array
    */
 	private static String[] decodeArray(String encoded){
-    if (encoded.length() == 0) return new String[]{};
 		char[] chars = encoded.trim().toCharArray();
 
 		//--Parse the String
---------------
-------------
@@ -247,7 +247,7 @@
       }
     }
     boolean overwriteOriginalNer = false;
-    if (prevNerEndIndex != (start-1) && nextNerStartIndex != end) {
+    if (prevNerEndIndex != (start-1) || nextNerStartIndex != end) {
       // Cutting across already recognized NEs don't disturb
     } else if (startNer == null) {
       // No old ner, okay to replace
---------------
-------------
@@ -247,7 +247,7 @@
       }
     }
     boolean overwriteOriginalNer = false;
-    if (prevNerEndIndex != (start-1) && nextNerStartIndex != end) {
+    if (prevNerEndIndex != (start-1) || nextNerStartIndex != end) {
       // Cutting across already recognized NEs don't disturb
     } else if (startNer == null) {
       // No old ner, okay to replace
---------------
-------------
@@ -106,6 +106,7 @@
     }
     
     private void recalculate(){
+    	if (numberOfResults == 0) firstResult = -1;
     	calculateLastPage();
     	paginate();
     }
---------------
-------------
@@ -149,8 +149,7 @@
 
       List<URI> typeUriArticlesToShow = getArticleTypesToShow(rootKey);
 
-      //numDaysInPast = configuration.getInteger(rootKey + ".numDaysInPast", 7);
-      numDaysInPast = 1000;
+      numDaysInPast = configuration.getInteger(rootKey + ".numDaysInPast", 7);
       numArticlesToShow = configuration.getInteger(rootKey + ".numArticlesToShow", 5);
 
       //  This is the most recent midnight.  No need to futz about with exact dates.
---------------
-------------
@@ -166,7 +166,7 @@
         hibernateTemplate.findByCriteria(
             DetachedCriteria.forClass(UserProfile.class)
                 .add(Restrictions.eq("email", email))
-        ));
+                .add(Restrictions.eq("verified", true))));
     if (profile == null) {
       throw new NoSuchUserException("No user with the email: " + email);
     }
---------------
-------------
@@ -302,7 +302,7 @@
         ", sort='" + sort + "'" +
         ", startPage=" + startPage +
         ", pageSize=" + pageSize +
-        ", resultView=" + resultView +
+        ", resultView='" + resultView + "'" +
         '}';
   }
 }
---------------
-------------
@@ -76,7 +76,7 @@
         try
         {
             engineReplacementDecision.beforeExecution( script );
-            neo4jGraph.autoStartTransaction();
+            neo4jGraph.autoStartTransaction(true);
             final Bindings bindings = createBindings(params, neo4jGraph);
 
             final Object result = engine().eval( script, bindings );
---------------
-------------
@@ -492,6 +492,7 @@
         JdbcSqlStat sqlStat = statement.getSqlStat();
 
         if (sqlStat != null) {
+            sqlStat.decrementExecutingCount();
             sqlStat.error(error);
             sqlStat.addExecuteTime(statement.getLastExecuteType(), statement.isFirstResultSet(), nanos);
             statement.setLastExecuteTimeNano(nanos);
---------------
-------------
@@ -35,7 +35,7 @@
                      "   WHERE RowNumber BETWEEN ? AND ?";
 
         String expect = "SELECT *" +
-        		"\nFROM (SELECT ROW_NUMBER() OVER () ORDER BY FAlertDate DESC, FAlertLevel, FAlertType AS RowNumber, *" +
+        		"\nFROM (SELECT ROW_NUMBER() OVER (ORDER BY FAlertDate DESC, FAlertLevel, FAlertType) AS RowNumber, *" +
         		"\n\tFROM monitor_business" +
         		"\n\tWHERE FRemoveAlert = ?" +
         		"\n\t) temp_table" +
---------------
-------------
@@ -492,6 +492,7 @@
         JdbcSqlStat sqlStat = statement.getSqlStat();
 
         if (sqlStat != null) {
+            sqlStat.decrementExecutingCount();
             sqlStat.error(error);
             sqlStat.addExecuteTime(statement.getLastExecuteType(), statement.isFirstResultSet(), nanos);
             statement.setLastExecuteTimeNano(nanos);
---------------
-------------
@@ -89,7 +89,7 @@
     }
 
     @SuppressWarnings("resource")
-    private void collectSql() {
+    public void collectSql() {
         Set<Object> dataSources = DruidDataSourceStatManager.getInstances().keySet();
 
         List<DruidDataSourceStatValue> statValueList = new ArrayList<DruidDataSourceStatValue>(dataSources.size());
---------------
-------------
@@ -56,7 +56,7 @@
         }
         
         for (int i = 0; i < method.getParameterTypes().length; ++i) {
-            if (method.getParameterTypes()[i].getName().equals(other.method.getParameterTypes()[i].getName())) {
+            if (!method.getParameterTypes()[i].getName().equals(other.method.getParameterTypes()[i].getName())) {
                 return false;
             }
         }
---------------
-------------
@@ -94,7 +94,7 @@
      * @param enabled true enables acknowledging
      */
     public void enableAcknowledgeing(boolean enabled) {
-    	if (enabled && this.acknowledgeId != NOACK) {
+    	if (enabled && this.acknowledgeId == NOACK) {
     		this.acknowledgeId = generateAcknowledgeId();
     	} else if (!enabled) {
     		this.acknowledgeId = NOACK;
---------------
-------------
@@ -38,7 +38,7 @@
 			public void onEvent(String event, MessageInfo info, Object... data) {
 				try {
 					DropMessage<T> dropMessage = (DropMessage<T>) data[0];
-					if(dropMessage.getClass() == cls || cls == null)
+					if(cls == null || dropMessage.getData().getClass().isAssignableFrom(cls))
 						inputqueue.put(dropMessage);
 				} catch (InterruptedException e) {
 					e.printStackTrace();
---------------
-------------
@@ -55,7 +55,7 @@
         }
     }
 
-    private void cleanClipboard() {
+    protected void cleanClipboard() {
         Application.setClipboard(" ");
     }
 }
---------------
-------------
@@ -71,7 +71,6 @@
         BeanLoader.CONTEXT_PATH = TEST_CONTEXT_PATH;
         SakuliPropertyPlaceholderConfigurer.TEST_SUITE_FOLDER_VALUE = TEST_FOLDER_PATH;
         SakuliPropertyPlaceholderConfigurer.INCLUDE_FOLDER_VALUE = INCLUDE_FOLDER_PATH;
-        SakuliPropertyPlaceholderConfigurer.SAHI_PROXY_HOME_VALUE = SAHI_FOLDER_PATH;
     }
 
     @AfterSuite
---------------
-------------
@@ -92,7 +92,7 @@
         typingUtil = new TypingUtil<>(this);
     }
 
-    public ScreenActionLoader getScreenActionLoader() {
+    protected ScreenActionLoader getScreenActionLoader() {
         return BeanLoader.loadScreenActionLoader();
     }
 
---------------
-------------
@@ -41,7 +41,7 @@
 
     public static SakuliReceiverException buildTransferException(String host, int port, GearmanJobResult result) {
         return new SakuliReceiverException(
-                String.format("something went wrong during the transfer of the results to the gearman receiver '%s:'%s':%n%s",
+                String.format("something went wrong during the transfer of the results to the gearman receiver '%s:'%s':\n%s",
                         host,
                         port,
                         buildExceptionForGearmanResult(result)
---------------
-------------
@@ -682,7 +682,7 @@
      * The header row will be ignored
      */
     public void verifyTablePattern(int column, String patternString){
-        verifyTablePattern(1, column, patternString);
+        verifyTablePattern(0, column, patternString);
     }
     
     /**
---------------
-------------
@@ -36,6 +36,7 @@
             String instructorId) {
         browser.driver.findElement(By.id(instructorId + "_recentActions")).click();
         waitForPageToLoad();
+        switchToNewWindow();
         return changePageType(AdminActivityLogPage.class);
     }
 
---------------
-------------
@@ -113,6 +113,8 @@
         copiedFeedbackSession.feedbackSessionName = newFeedbackSessionName;
         copiedFeedbackSession.courseId = newCourseId;
         copiedFeedbackSession.createdTime = new Date();
+        copiedFeedbackSession.respondingInstructorList = new HashSet<String>();
+        copiedFeedbackSession.respondingStudentList = new HashSet<String>();
         fsDb.createEntity(copiedFeedbackSession);
         
         List<FeedbackQuestionAttributes> feedbackQuestions = fqLogic.getFeedbackQuestionsForSession(feedbackSessionName, courseId);
---------------
-------------
@@ -582,6 +582,8 @@
             deleteFeedbackQuestionCascade(questionToDeleteById.feedbackSessionName,
                                         questionToDeleteById.courseId, 
                                         questionToDeleteById.questionNumber);
+        } else {
+            // Silently fail if question does not exist.
         }
         
     }
---------------
-------------
@@ -31,7 +31,9 @@
         } catch (InvalidParametersException
                 | EntityAlreadyExistsException e) {
             setStatusForException(e, Sanitizer.sanitizeForHtml(e.getMessage()));
-            logMsg = "GAE-level exception not thrown explicitly by Logic <br/>" + e.toString();
+            //logMsg = "GAE-level exception not thrown explicitly by Logic <br/>" + e.toString();
+            
+            //TODO: this branch seems to be unreachable, to be removed  
         } catch (JoinCourseException e) {
             // Does not sanitize for html to allow insertion of mailto link
             setStatusForException(e, e.getMessage());
---------------
-------------
@@ -68,6 +68,7 @@
     
     protected StudentAttributes getStudent() {
         if (student != null) {
+            // Not covered in tests as it is not easily producible but acts as a safety net
             return student;
         } else {
             return logic.getStudentForGoogleId(courseId, account.googleId);
---------------
-------------
@@ -682,7 +682,7 @@
      * The header row will be ignored
      */
     public void verifyTablePattern(int column, String patternString){
-        verifyTablePattern(0, column, patternString);
+        verifyTablePattern(1, column, patternString);
     }
     
     /**
---------------
-------------
@@ -28,6 +28,7 @@
             String instructorId) {
         browser.driver.findElement(By.id(instructorId + "_details")).click();
         waitForPageToLoad();
+        switchToNewWindow();
         return changePageType(AdminAccountDetailsPage.class);
     }
     
---------------
-------------
@@ -1,7 +1,6 @@
 package teammates.common.util;
 
 import java.util.Arrays;
-import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
 
---------------
-------------
@@ -41,7 +41,7 @@
 
         List<WebElement> viewTeamLinks = browser.driver.findElements(By.linkText("View Team"));
 
-        viewTeamLinks.get(1).click();
+        viewTeamLinks.get(0).click();
     }
 
     public WebElement getViewEvalResultsButton(String EvalOrFeedbackName) {
---------------
-------------
@@ -75,7 +75,7 @@
     }
     
     public static String convertToStandardHtmlPart(String rawHtml) {
-        String preProcessedHtml = replaceInRawHtmlString(rawHtml);
+        String preProcessedHtml = preProcessHtml(rawHtml);
         return convertRawHtmlPartString(preProcessedHtml);
     }
 
---------------
-------------
@@ -82,7 +82,7 @@
             } else {
                 log.fine("API Servlet adding instructor :" + instructor.email);
                 //Hardcoding institute value because this is used for testing only
-                super.instructorsLogic.createInstructor(instructor);
+                super.instructorsLogic.createInstructor(instructor.googleId, instructor.courseId, instructor.name, instructor.email);
                 //TODO:may not need to access instructorsLogic here
             }
         }
---------------
-------------
@@ -1520,7 +1520,7 @@
         if (isVisibleResponse && instructor != null) {
             if (!(instructor.isAllowedForPrivilege(response.giverSection,
                     response.feedbackSessionName, Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS))
-                    || !(instructor.isAllowedForPrivilege(response.giverSection,
+                    || !(instructor.isAllowedForPrivilege(response.recipientSection,
                             response.feedbackSessionName, Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS))) {
                 isVisibleResponse = false;
             }
---------------
-------------
@@ -21,7 +21,7 @@
     @Override
     public ActionResult execute() throws EntityDoesNotExistException {
         
-        if (isPersistenceIssue()) {
+        if (!account.isInstructor && isPersistenceIssue()) {
             data = new InstructorHomePageData(account);
             ShowPageResult response = createShowPageResult(Const.ViewURIs.INSTRUCTOR_HOME, data);
             statusToUser.add(Const.StatusMessages.INSTRUCTOR_PERSISTENCE_ISSUE);
---------------
-------------
@@ -47,7 +47,7 @@
 
     @Override
     public SecretKey generateKey() {
-        if (secret == null) {
+        if (secret == null || secret.isEmpty()) {
             LOGGER.info("No secret specified for session encryption.");
             return null;
         }
---------------
-------------
@@ -36,7 +36,7 @@
     // group(1) extracts the name of the group (in that case "id").
     // group(3) extracts the regex if defined
     final static Pattern PATTERN_FOR_VARIABLE_PARTS_OF_ROUTE 
-        = Pattern.compile("\\{(.*?)(:\\s(.*))?\\}");
+        = Pattern.compile("\\{(.*?)(:\\s(.*?))?\\}");
 
     /**
      * This regex matches everything in between path slashes.
---------------
-------------
@@ -48,7 +48,7 @@
     private List<Route> routes;
 
     // This regex works for both {myParam} AND {myParam: .*} (with regex)
-    private final String VARIABLE_PART_PATTERN_WITH_PLACEHOLDER = "\\{(%s)(:\\s(.*))?\\}";
+    private final String VARIABLE_PART_PATTERN_WITH_PLACEHOLDER = "\\{(%s)(:\\s([^}]*))?\\}"; 
 
     @Inject
     public RouterImpl(
---------------
-------------
@@ -45,7 +45,7 @@
 public class MetricsServiceImpl implements MetricsService {
 
     private final Logger log = LoggerFactory.getLogger(MetricsService.class);
-    private final Map<String, MetricRegistry> metricRegistries;
+    private final ConcurrentHashMap<String, MetricRegistry> metricRegistries;
     private final NinjaProperties ninjaProps;
     private final List<JmxReporter> jmxReporters;
 
---------------
-------------
@@ -121,7 +121,9 @@
                         + ninja.utils.NinjaConstant.FLASH_SUFFIX, flashData);
                 cookie.setPath("/");
                 cookie.setSecure(false);
-                cookie.setMaxAge(0);
+                // "-1" does not set "Expires" for that cookie
+                // => Cookie will live as long as the browser is open theoretically
+                cookie.setMaxAge(-1);
 
                 context.getHttpServletResponse().addCookie(cookie);
 
---------------
-------------
@@ -5,6 +5,8 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 
+import ninja.NinjaServletDispatcher;
+
 import org.apache.http.client.utils.URIBuilder;
 import org.mortbay.jetty.Connector;
 import org.mortbay.jetty.Handler;
---------------
-------------
@@ -302,7 +302,7 @@
      *
      * @param cfs
      * @param ranges Ranges that the repair was carried out on
-     * @param validatedForRepair SSTables containing the repaired ranges
+     * @param validatedForRepair SSTables containing the repaired ranges. Should be referenced before passing them.
      * @throws InterruptedException, ExecutionException, IOException
      */
     public void performAnticompaction(ColumnFamilyStore cfs,
---------------
-------------
@@ -272,7 +272,7 @@
 
     public long maxTimestamp()
     {
-        long maxTimestamp = Long.MIN_VALUE;
+        long maxTimestamp = getMarkedForDeleteAt();
         for (IColumn column : columns)
             maxTimestamp = Math.max(maxTimestamp, column.maxTimestamp());
         return maxTimestamp;
---------------
-------------
@@ -58,7 +58,6 @@
 
         public Builder(ColumnFamily cf,
                        ByteBuffer key,
-                       DataOutput output)
                        DataOutput output,
                        boolean fromStream)
         {
---------------
-------------
@@ -675,7 +675,6 @@
         {
             if (!hasIndexes && !new Bounds<>(sstable.first.token, sstable.last.token).intersects(ranges))
             {
-                cfs.getDataTracker().replaceReaders(Arrays.asList(sstable), Collections.<SSTableReader>emptyList());
                 cfs.getDataTracker().markCompactedSSTablesReplaced(Arrays.asList(sstable), Collections.<SSTableReader>emptyList(), OperationType.CLEANUP);
                 continue;
             }
---------------
-------------
@@ -35,7 +35,7 @@
 
     public static final ISerializer<DeletionTime> serializer = new Serializer();
 
-    DeletionTime(long markedForDeleteAt, int localDeletionTime)
+    public DeletionTime(long markedForDeleteAt, int localDeletionTime)
     {
         this.markedForDeleteAt = markedForDeleteAt;
         this.localDeletionTime = localDeletionTime;
---------------
-------------
@@ -378,7 +378,7 @@
         submitUserDefined(cfs, descriptors, getDefaultGcBefore(cfs));
     }
 
-    private Future<Object> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
+    Future<Object> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
     {
         Callable<Object> callable = new Callable<Object>()
         {
---------------
-------------
@@ -587,7 +587,7 @@
     {
         return metadata.cfType == ColumnFamilyType.Standard
                ? Column.serializer()
-               : SuperColumn.serializer(getColumnComparator());
+               : SuperColumn.serializer(metadata.subcolumnComparator);
     }
 
     /**
---------------
-------------
@@ -376,7 +376,7 @@
         ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));
         int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);
         CfDef cfDef = getCfDef(columnFamily);
-        boolean isSuper = cfDef.comparator_type.equals("Super");
+        boolean isSuper = cfDef.column_type.equals("Super");
         
         byte[] superColumnName = null;
         ByteBuffer columnName;
---------------
-------------
@@ -95,7 +95,7 @@
         return udpAddr_;
     }
 
-    public static IPartitioner getPartitioner() {
+    public static IPartitioner<?> getPartitioner() {
         return partitioner_;
     }
 
---------------
-------------
@@ -468,7 +468,7 @@
             return;
 
         IndexClause clause = new IndexClause();
-        String columnFamily = statement.getChild(0).getText();
+        String columnFamily = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
         // ^(CONDITIONS ^(CONDITION $column $value) ...)
         Tree conditions = statement.getChild(1);
         
---------------
-------------
@@ -199,6 +199,7 @@
         {
             int startIndex = (int) (section.left / parameters.chunkLength());
             int endIndex = (int) (section.right / parameters.chunkLength());
+            endIndex = section.right % parameters.chunkLength() == 0 ? endIndex - 1 : endIndex;
             for (int i = startIndex; i <= endIndex; i++)
             {
                 long offset = i * 8;
---------------
-------------
@@ -367,7 +367,7 @@
 
     public ColumnStats getColumnStats()
     {
-        long maxTimestampSeen = Long.MIN_VALUE;
+        long maxTimestampSeen = getMarkedForDeleteAt();
         StreamingHistogram tombstones = new StreamingHistogram(SSTable.TOMBSTONE_HISTOGRAM_BIN_SIZE);
 
         for (IColumn column : columns)
---------------
-------------
@@ -1978,7 +1978,7 @@
             return 0;
         } else if (a == null && b != null) {
             return -1;
-        } else if (a != null && b != null) {
+        } else if (a != null && b == null) {
             return 1;
         } else {
             return a.compareTo(b);
---------------
-------------
@@ -1978,7 +1978,7 @@
             return 0;
         } else if (a == null && b != null) {
             return -1;
-        } else if (a != null && b != null) {
+        } else if (a != null && b == null) {
             return 1;
         } else {
             return a.compareTo(b);
---------------
-------------
@@ -84,7 +84,7 @@
             msg = "Failed";
         }
         try {
-            repository.createCommitStatus(sha1, state, build.getFullUrl(), msg,"DotCI");
+            repository.createCommitStatus(sha1, state, build.getFullUrl(), msg,"DotCi");
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
---------------
-------------
@@ -82,7 +82,7 @@
     private transient ViewGroupMixIn viewGroupMixIn;
     private transient OrganizationGravatarIcon icon;
 
-    protected OrganizationContainer(ItemGroup parent, String name) {
+    public OrganizationContainer(ItemGroup parent, String name) {
         super(parent, name);
         init(name);
         if(id == null) {
---------------
-------------
@@ -116,7 +116,8 @@
 						start.apply(printer);
 						strOutput.fullstop();
 
-						System.out.println(strOutput.toString());
+						// A Friendly Reminder: strOutput includes a newline!
+						System.out.print(strOutput.toString());
 					} catch (BException e) {
 						// TODO Auto-generated catch block
 						e.printStackTrace();
---------------
-------------
@@ -64,7 +64,7 @@
 
 	@Override
 	public double averageScale(final int d) {
-		return averageScale(d);
+		return axis(d).averageScale(0, 1);
 	}
 
 }
---------------
-------------
@@ -73,7 +73,6 @@
 		for (int d = 0; d < n; d++)
 			position[d] = cursor.position[d];
 
-		position[0]--;
 		type.updateContainer(this);
 	}
 
---------------
-------------
@@ -204,8 +204,8 @@
 		g2d.setStroke( new BasicStroke( 0 ) );
 		g2d.fill( transformed );
 
-		final long[] strps = new long[ 3 * width * height / 2 ]; // avoid
-																	// re-allocation
+		final long[] strps = new long[ 3 * (width==1?2:width) * height / 2 ]; // avoid
+																				// re-allocation
 		int i = 0;
 		for ( int y = 0; y < height; y++ )
 		{
---------------
-------------
@@ -140,7 +140,7 @@
 	 *         defined axes.
 	 */
 	public static AxisType[] knownTypes() {
-		return axes.values().toArray(null);
+		return axes.values().toArray(new AxisType[0]);
 	}
 
 	/**
---------------
-------------
@@ -45,7 +45,7 @@
 	@Override
 	public V compute(T z1, U z2, V output) {
 		double x = z1.getRealDouble() - z2.getRealDouble();
-		double y = z1.getRealDouble() - z2.getRealDouble();
+		double y = z1.getImaginaryDouble() - z2.getImaginaryDouble();
 		output.setComplexNumber(x, y);
 		return output;
 	}
---------------
-------------
@@ -49,7 +49,7 @@
 		public void push(long [] position) {
 			int insertPoint = this.position * dimensions;
 			if (storage.length == insertPoint) {
-				long [] newStorage = new long [storage.length * 3 / 2];
+				long [] newStorage = new long [(this.position * 3 / 2) * dimensions];
 				System.arraycopy(storage, 0, newStorage, 0, storage.length);
 				storage = newStorage;
 			}
---------------
-------------
@@ -125,7 +125,7 @@
             sb.append(input);
             part = getSuffix();
             if (part != null) {
-                sb.append(part).append(".");
+                sb.append(".").append(part);
             }
             return sb.toString();
         }
---------------
-------------
@@ -65,7 +65,7 @@
                 start = pos + 1;
             } else {
                 // we found it - walk backwards to first
-                while (pos > 0 && test(pos-1) == 0) {
+                while (pos > start && test(pos-1) == 0) {
                     pos -= 1;
                 }
                 return pos;
---------------
-------------
@@ -25,7 +25,7 @@
  * </p>
  * 
  * @author Matthias.Balke <matthias.balke@tu-dortmund.de>
- * @since 0.10
+ * @since 0.11
  * 
  */
 public class AverageAccumulator {
---------------
-------------
@@ -164,7 +164,7 @@
   public static DoubleVector logVector(DoubleVector input) {
     DenseDoubleVector log = new DenseDoubleVector(input.getDimension());
     for (int col = 0; col < log.getDimension(); col++) {
-      log.set(col, guardLogarithm(log.get(col)));
+      log.set(col, guardLogarithm(input.get(col)));
     }
     return log;
   }
---------------
-------------
@@ -150,7 +150,7 @@
       Iterator<DoubleVectorElement> iterateNonZero = vector.iterateNonZero();
       while (iterateNonZero.hasNext()) {
         DoubleVectorElement next = iterateNonZero.next();
-        int value = (int) next.getValue();
+        int value = next.getIndex();
         bytesToHash[0] = (byte) (value >> 24);
         bytesToHash[1] = (byte) (value >> 16);
         bytesToHash[2] = (byte) (value >> 8);
---------------
-------------
@@ -439,6 +439,7 @@
     void setVersions(Set<Version<T>> versions) {
         idVersionMap = new HashMap<ObjectVersionID, Version<T>>();
         timeVersionMap = new TreeMap<DvDateTime, Version<T>>();
+		trunkCounter = 0;
         for(Version<T> version : versions) {
             addVersion(version);
         }
---------------
-------------
@@ -159,7 +159,7 @@
       if (decl == null && getDefiningNode() != null && getClassDeclaration() == getDefiningNode()) {
         decl = getClassDeclaration().resolvePropertyDeclaration(ide.getName());
         if (decl != null && !isInstanceScope && !decl.isStatic()) {
-          throw Jooc.error(ide, "access to instance property in static context: '" + ide.getName() + "'");
+          decl = null;
         }
       }
     }
---------------
-------------
@@ -33,6 +33,7 @@
       put(Exmlc.EXML_COMPONENT_NODE_NAME, ConfigClassType.XTYPE);
       put(Exmlc.EXML_PLUGIN_NODE_NAME, ConfigClassType.PTYPE);
       put(Exmlc.EXML_LAYOUT_NODE_NAME, ConfigClassType.TYPE);
+      put(Exmlc.EXML_GRID_COLUMN_NODE_NAME, ConfigClassType.GCTYPE);
     }
   });
 
---------------
-------------
@@ -44,7 +44,7 @@
 
         ComponentSuite componentSuite = new ComponentSuite(
           schemaElement.getAttribute("targetNamespace"),
-          schemaElement.getAttribute("id"), null, null);
+          schemaElement.lookupPrefix(schemaElement.getAttribute("targetNamespace")), null, null);
         NodeList components = document.getElementsByTagNameNS(XML_SCHEMA_URL, "element");
         for (int i = 0; i < components.getLength(); ++i) {
           Element component = (Element) components.item(i);
---------------
-------------
@@ -34,7 +34,7 @@
 
     @ApiModelProperty(required = true)
     @NotNull
-    public FacilityStatus status = IN_OPERATION;
+    public FacilityStatus status;
 
     @ApiModelProperty(required = true)
     @Valid
---------------
-------------
@@ -34,7 +34,7 @@
 
     @ApiModelProperty(required = true)
     @NotNull
-    public FacilityStatus status = IN_OPERATION;
+    public FacilityStatus status;
 
     @ApiModelProperty(required = true)
     @Valid
---------------
-------------
@@ -194,7 +194,7 @@
     public void addInterceptors(InterceptorRegistry registry) {
         WebContentInterceptor webContentInterceptor = new WebContentInterceptor();
         Properties cacheMappings = new Properties();
-        cacheMappings.setProperty(UrlSchema.API + "/*", "0");
+        cacheMappings.setProperty(UrlSchema.API + "/**", "0");
         webContentInterceptor.setCacheMappings(cacheMappings);
         registry.addInterceptor(webContentInterceptor);
     }
---------------
-------------
@@ -34,7 +34,7 @@
 
     @ApiModelProperty(required = true)
     @NotNull
-    public FacilityStatus status = IN_OPERATION;
+    public FacilityStatus status;
 
     @ApiModelProperty(required = true)
     @Valid
---------------
-------------
@@ -47,7 +47,7 @@
 	private Map<Pattern, String> urlPatternMap = new HashMap<Pattern, String>();
 	private Set<String> safeCanonicalFilePaths = new HashSet<String>();
 
-	private StagingManager() {
+	public StagingManager() {
 	}
 
 	/**
---------------
-------------
@@ -66,7 +66,7 @@
 				try {
 					for (Schema schem : cat.getSchemas()) {
 						for (Cube cub : schem.getCubes()) {
-							cubes.add(new SaikuCube(connectionName, cat.getName(), schem.getName(), cub.getName()));
+							cubes.add(new SaikuCube(connectionName, cub.getName(), cat.getName(), schem.getName()));
 						}
 					}
 				} catch (OlapException e) {
---------------
-------------
@@ -10,6 +10,7 @@
 
 import org.codehaus.enunciate.rest.annotations.JSONP;
 import org.codehaus.enunciate.rest.annotations.RESTEndpoint;
+import org.saiku.olap.dto.SaikuConnection;
 import org.saiku.olap.dto.SaikuCube;
 import org.saiku.service.olap.OlapDiscoverService;
 import org.saiku.web.rest.objects.CubeRestPojo;
---------------
-------------
@@ -554,7 +554,7 @@
             final BRLConditionVariableColumn variableColumn = column.getChildColumns().get( 0 );
             final int index = allColumns.indexOf( variableColumn );
             final DTCellValue52 dcv = row.get( index );
-            if ( dcv.getBooleanValue() ) {
+            if ( dcv != null && dcv.getBooleanValue() ) {
                 for ( IPattern pattern : column.getDefinition() ) {
                     patterns.add( pattern );
                 }
---------------
-------------
@@ -58,7 +58,6 @@
 
         Contexts.getSessionContext().set( "org.drools.guvnor.client.rpc.RepositoryService",
                                           serviceImplementation );
-
     }
 
     protected void setUpMockIdentity() {
---------------
-------------
@@ -97,6 +97,7 @@
 
     @Before
     public void loginAsAdmin() {
+        // TODO this method seems to be called after the request and the rulesRepository therefor is created...
         if (autoLoginAsAdmin) {
             credentials.setUsername("admin");
             credentials.setCredential(new PasswordCredential("admin"));
---------------
-------------
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package org.kie.guvnor.testscenario.backend.server;
+package org.drools.guvnor.models.testscenarios.backend;
 
 import java.util.Date;
 
---------------
-------------
@@ -113,20 +113,6 @@
         }
     }
 
-//    protected void setUpMockIdentity() {
-//        MockIdentity mockIdentity = new MockIdentity();
-//        mockIdentity.setIsLoggedIn( true );
-//        RoleBasedPermissionResolver resolver = new RoleBasedPermissionResolver();
-//        resolver.setEnableRoleBasedAuthorization( false );
-//        mockIdentity.addPermissionResolver( new RoleBasedPermissionResolver() );
-//        setUpMockIdentity( mockIdentity );
-//    }
-//
-//    public void setUpMockIdentity(MockIdentity mockIdentity) {
-//        mockIdentity.inject();
-//        mockIdentity.create();
-//    }
-
     // ************************************************************************
     // Helper methods
     // ************************************************************************
---------------
-------------
@@ -244,7 +244,7 @@
         meta.categories = new String[cats.size()];
         for ( int i = 0; i < meta.categories.length; i++ ) {
             CategoryItem cat = (CategoryItem) cats.get(i);
-            meta.categories[i] = cat.getName();            
+            meta.categories[i] = cat.getFullPath();          
         }
         
         meta.state = (item.getState() != null) ? item.getState().getName() : "";
---------------
-------------
@@ -80,7 +80,7 @@
                                           repositoryCategoryService );
     }
 
-    protected RulesRepository getRulesRepository() {
+    private RulesRepository getRulesRepository() {
         if ( repository == null ) {
             repository = new RulesRepository( TestEnvironmentSessionHelper.getSession( true ) );
         }
---------------
-------------
@@ -158,7 +158,6 @@
 				+ "</i>"));
 */
 		editor.addAttribute("Dependency Path: ", new Label(parseDependencyPath(dependencyPath)[0]));
-		//editor.addAttribute("Is Imported from Global: ", new Label("No"));
 		final VersionChooser versionChoose = new VersionChooser( 
 				parseDependencyPath(dependencyPath)[1],
 				conf.uuid,
---------------
-------------
@@ -79,7 +79,7 @@
     public T extract(MultivaluedMap<String, String> parameters) {
         String v = parameters.getFirst(getName());
         try {
-            return fromString(v);
+            return fromString((v == null && isDefaultValueRegistered()) ? getDefaultValueString() : v);
         } catch (WebApplicationException ex) {
             throw ex;
         } catch (ProcessingException ex) {
---------------
-------------
@@ -191,7 +191,7 @@
         }
 
         private Form getFormParameters(ContainerRequest requestContext) {
-            if (requestContext.getMediaType().equals(MediaType.APPLICATION_FORM_URLENCODED_TYPE)) {
+            if (MediaTypes.typeEqual(MediaType.APPLICATION_FORM_URLENCODED_TYPE, requestContext.getMediaType())) {
                 requestContext.bufferEntity();
                 Form form;
                 if (decode) {
---------------
-------------
@@ -1,7 +1,7 @@
 /*
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
  *
- * Copyright (c) 2012 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012-2014 Oracle and/or its affiliates. All rights reserved.
  *
  * The contents of this file are subject to the terms of either the GNU
  * General Public License Version 2 only ("GPL") or the Common Development
---------------
-------------
@@ -94,7 +94,7 @@
 
     @Override
     public boolean isOptional(AnnotatedElement annotated, A annotation) {
-        return false; // TODO - is this ok?
+        return true;
     }
 
     @Override
---------------
-------------
@@ -88,7 +88,7 @@
     @Override
     public Pair<Request, Iterator<TreeAcceptor>> apply(final Request request) {
         final RoutingContext rc = contextProvider.get();
-        rc.pushMatchResult(new SingleMatchResult(Requests.relativePath(request)));
+        rc.pushMatchResult(new SingleMatchResult(Requests.relativePath(request, false)));
 
         return Tuples.<Request, Iterator<TreeAcceptor>>of(request, Iterators.singletonIterator(rootRoute));
     }
---------------
-------------
@@ -1,7 +1,7 @@
 /*
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
  *
- * Copyright (c) 2012-2014 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012-2015 Oracle and/or its affiliates. All rights reserved.
  *
  * The contents of this file are subject to the terms of either the GNU
  * General Public License Version 2 only ("GPL") or the Common Development
---------------
-------------
@@ -79,7 +79,7 @@
     public T extract(MultivaluedMap<String, String> parameters) {
         String v = parameters.getFirst(getName());
         try {
-            return fromString(v);
+            return fromString((v == null && isDefaultValueRegistered()) ? getDefaultValueString() : v);
         } catch (WebApplicationException ex) {
             throw ex;
         } catch (ProcessingException ex) {
---------------
-------------
@@ -130,7 +130,7 @@
             private final UnsafeValue<InputStream, IOException> in = Values.lazy(new UnsafeValue<InputStream, IOException>() {
                 @Override
                 public InputStream get() throws IOException {
-                    if (uc.getResponseCode() < 300) {
+                    if (uc.getResponseCode() < 400) {
                         return uc.getInputStream();
                     } else {
                         InputStream ein = uc.getErrorStream();
---------------
-------------
@@ -154,6 +154,7 @@
             if (entity != null) {
                 requestContext.variant(entity.getVariant());
                 requestContext.setEntity(entity.getEntity());
+                requestContext.setEntityAnnotations(entity.getAnnotations());
             }
         }
 
---------------
-------------
@@ -307,6 +307,8 @@
             throw new IllegalStateException("Method could be called only in pre-matching request filter.");
         }
 
+        this.encodedRelativePath = null;
+        this.decodedRelativePath = null;
         this.requestUri = requestUri;
     }
 
---------------
-------------
@@ -307,6 +307,8 @@
             throw new IllegalStateException("Method could be called only in pre-matching request filter.");
         }
 
+        this.encodedRelativePath = null;
+        this.decodedRelativePath = null;
         this.requestUri = requestUri;
     }
 
---------------
-------------
@@ -154,6 +154,7 @@
             if (entity != null) {
                 requestContext.variant(entity.getVariant());
                 requestContext.setEntity(entity.getEntity());
+                requestContext.setEntityAnnotations(entity.getAnnotations());
             }
         }
 
---------------
-------------
@@ -1,7 +1,7 @@
 /*
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
  *
- * Copyright (c) 2012 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012-2014 Oracle and/or its affiliates. All rights reserved.
  *
  * The contents of this file are subject to the terms of either the GNU
  * General Public License Version 2 only ("GPL") or the Common Development
---------------
-------------
@@ -688,7 +688,7 @@
 
             Feature feature = registration.getFeature();
             if (feature == null) {
-                feature = locator.create(registration.getFeatureClass());
+                feature = locator.createAndInitialize(registration.getFeatureClass());
             } else {
                 // Disable injection of Feature instances on the client-side. Instances may be registered into multiple
                 // web-targets which means that injecting anything into these instances is not safe.
---------------
-------------
@@ -32,7 +32,7 @@
 			if (b1[i] == b2[i])
 				continue;
 			else
-			if (b1[i] > b2[i])
+			if ((b1[i]&0xFF) > (b2[i]&0xFF))
 				return 1;
 			else
 				return -1;
---------------
-------------
@@ -15,7 +15,7 @@
 	
 	public static void assertFeederException(String message, FeederException e) {
 		// assert that the message is correct
-		Assert.assertEquals(e.getMessage(), message);
+		Assert.assertEquals(message, e.getMessage());
 		// check that corresponding label exists
 		Assert.assertNotNull(Labels.getLabel("exception.FeederException." + message));
 	}
---------------
-------------
@@ -78,7 +78,7 @@
 
         fields = new Field[rowLength];
         for (int i = 0; i < rowLength; i++) {
-            if (isNumber(lines.get(0)[i])) {
+            if (lines.isEmpty() || isNumber(lines.get(0)[i])) {
                 fields[i] = new NumberField(header[i]);
             } else {
                 fields[i] = new TextField(header[i]);
---------------
-------------
@@ -68,7 +68,7 @@
 
             // write data
             for (Entry entry : dataset.getEntries()) {
-                for (int i = 0; i < dataset.getFields().size() + 1; i++) {
+                for (int i = 0; i < dataset.getFields().size(); i++) {
                     Field field = dataset.getFields().get(i);
                     line[i] = entry.get(field).get().toString();
                 }
---------------
-------------
@@ -118,7 +118,7 @@
     }
 
     private double firstMajorTick(double lowerBound) {
-        return getAnchorTick() + getTickUnit() * floorToZero((lowerBound - getAnchorTick()) / getTickUnit());
+        return getAnchorTick() + getTickUnit() * ceil((lowerBound - getAnchorTick()) / getTickUnit());
     }
     
     private double floorToZero(double num) {
---------------
-------------
@@ -97,7 +97,7 @@
                 {
                     len++;
                     // surrogate pairs should always combine to create a code point with a 4 octet representation
-                    if ((c & 0xD800) == 0xD800)
+                    if ((c & 0xD800) == 0xD800 && c < 0xDC00)
                     {
                         i++;
                     }
---------------
-------------
@@ -788,7 +788,7 @@
                 _buffer.put((byte)(0xC0 | ((c >> 6) & 0x1F)));
                 _buffer.put((byte)(0x80 | (c & 0x3F)));
             }
-            else if ((c & 0xD800) != 0xD800 || (c & 0xDC00) == 0xDC00)     /* U+0800..U+FFFF - excluding surrogate pairs */
+            else if ((c & 0xD800) != 0xD800 || (c > 0xDBFF))     /* U+0800..U+FFFF - excluding surrogate pairs */
             {
                 _buffer.put((byte)(0xE0 | ((c >> 12) & 0x0F)));
                 _buffer.put((byte)(0x80 | ((c >> 6) & 0x3F)));
---------------
-------------
@@ -363,6 +363,7 @@
                                        "file path. Returns 0 in case " +
                                        "of problem.")
     @Recorded
+    @TestMethods("testNumberOfEntriesInSDF")
     public int numberOfEntriesInSDF( String filePath );
     
     /**
---------------
-------------
@@ -139,6 +139,7 @@
                       methodSummary = "Loads molecules from a file at " +
                       		          "a given path into a list of " +
                       		          "molecules")
+    @TestMethods("testLoadMolecules")
     public List<ICDKMolecule> loadMolecules(String path)
         throws IOException, BioclipseException, CoreException;
 
---------------
-------------
@@ -98,6 +98,7 @@
             intervals = IntervalUtils.parseIntervalArguments(genomeLocParser, stringIntervals);
         }
 
+        Collections.sort(intervals);
         return intervals;
     }
 
---------------
-------------
@@ -231,7 +231,7 @@
         int count = 0;
         for (PileupElement p : pileup) {
             if (p.isDeletion() || p.isInsertionAtBeginningOfRead() || BaseUtils.isRegularBase(p.getBase()))
-                count++;
+                count += p.getRepresentativeCount();
         }
 
         return count;
---------------
-------------
@@ -91,6 +91,7 @@
     protected static Logger logger = Logger.getLogger(ParsingEngine.class);
 
     public ParsingEngine( CommandLineProgram clp ) {
+        RodBinding.resetNameCounter();
         parsingMethods.add( ParsingMethod.FullNameParsingMethod );
         parsingMethods.add( ParsingMethod.ShortNameParsingMethod );
 
---------------
-------------
@@ -1000,7 +1000,7 @@
     public static VariantContext trimAlleles(final VariantContext inputVC, final boolean trimForward, final boolean trimReverse) {
         if ( inputVC == null ) throw new IllegalArgumentException("inputVC cannot be null");
 
-        if ( inputVC.getNAlleles() <= 1 )
+        if ( inputVC.getNAlleles() <= 1 || inputVC.isSNP() )
             return inputVC;
 
         // see whether we need to trim common reference base from all alleles
---------------
-------------
@@ -385,7 +385,7 @@
         // this was very likely unintentional, the user should be informed of this. Note that this is different
         // from the case where intervals == null, which indicates either that there were no interval arguments,
         // or that -L all was specified.
-        if ( intervals != null && intervals.isEmpty() ) {
+        if ( intervals != null && intervals.isEmpty() && argCollection.excludeIntervals != null ) {
             throw new ArgumentException("The given combination of -L and -XL options results in an empty set. " +
                                         "No intervals to process.");
         }
---------------
-------------
@@ -256,7 +256,7 @@
             // Naive algorithm: find all elements in current contig for proper schedule creation.
             List<GenomeLoc> lociInContig = new LinkedList<GenomeLoc>();
             for(GenomeLoc locus: loci) {
-                if(dataSource.getHeader().getSequence(locus.getContig()).getSequenceIndex() == lastReferenceSequenceLoaded)
+                if(!GenomeLoc.isUnmapped(locus) && dataSource.getHeader().getSequence(locus.getContig()).getSequenceIndex() == lastReferenceSequenceLoaded)
                     lociInContig.add(locus);
             }
 
---------------
-------------
@@ -224,7 +224,7 @@
                 if ( ! expectedMD5.equals(filemd5sum) ) {
                     // we are going to fail for real in assertEquals (so we are counted by the testing framework).
                     // prepare ourselves for the comparison
-                    System.out.printf("##### Test %s is going fail #####%n", name);
+                    System.out.printf("##### Test %s is going to fail #####%n", name);
                     String pathToExpectedMD5File = getMD5FilePath(expectedMD5, "[No DB file found]");
                     String pathToFileMD5File = getMD5FilePath(filemd5sum, "[No DB file found]");
                     System.out.printf("##### Path to expected   file (MD5=%s): %s%n", expectedMD5, pathToExpectedMD5File);
---------------
-------------
@@ -50,7 +50,7 @@
     @Argument(fullName="numKMeans", shortName="nKM", doc="The number of k-means iterations to perform in order to initialize the means of the Gaussians in the Gaussian mixture model.", required=false)
     public int NUM_KMEANS_ITERATIONS = 30;
     @Argument(fullName="stdThreshold", shortName="std", doc="If a variant has annotations more than -std standard deviations away from mean then don't use it for building the Gaussian mixture model.", required=false)
-    public double STD_THRESHOLD = 8.0;
+    public double STD_THRESHOLD = 14.0;
     @Argument(fullName="qualThreshold", shortName="qual", doc="If a known variant has raw QUAL value less than -qual then don't use it for building the Gaussian mixture model.", required=false)
     public double QUAL_THRESHOLD = 80.0;
     @Argument(fullName="shrinkage", shortName="shrinkage", doc="The shrinkage parameter in variational Bayes algorithm.", required=false)
---------------
-------------
@@ -371,7 +371,7 @@
 
 	long totalBases = 0;
 	for(GenomeLoc loc : locs)
-	    totalBases += loc.getStop() - loc.getStart();
+	    totalBases += loc.size();
 
 	long idealBasesPerPart = totalBases / scatterParts.size();
 	if(idealBasesPerPart == 0)
---------------
-------------
@@ -66,7 +66,7 @@
                 return new Pair<GenomeLoc, String>(context.getLocation(), (SEQUENOM ? refBase.concat("[-/"+variant.getAltBasesFWD()+"]") : refBase.concat(variant.getAltBasesFWD())));
             } else if ( variant.isSNP() ) {
                 basesSeen++;
-                return new Pair<GenomeLoc, String>(context.getLocation(), (rod.getName().startsWith("snpmask") ? "N" : ("[" + refBase + "/" + variant.getAltBasesFWD() + "]")));
+                return new Pair<GenomeLoc, String>(context.getLocation(), (rod.getName().startsWith("snpmask") ? "N" : (SEQUENOM ? "[" + refBase + "/" + variant.getAltBasesFWD() + "]" : variant.getAltBasesFWD())));
             }
         }
 
---------------
-------------
@@ -98,6 +98,7 @@
             intervals = IntervalUtils.parseIntervalArguments(genomeLocParser, stringIntervals);
         }
 
+        Collections.sort(intervals);
         return intervals;
     }
 
---------------
-------------
@@ -414,7 +414,7 @@
      * @return vc subcontext
      */
     public VariantContext subContextFromGenotypes(Collection<Genotype> genotypes, Set<Allele> alleles) {
-        return new VariantContext(getSource(), contig, start, stop, alleles, genotypes, getNegLog10PError(), getFilters(), getAttributes());
+        return new VariantContext(getSource(), contig, start, stop, alleles, genotypes, getNegLog10PError(), filtersWereApplied() ? getFilters() : null, getAttributes());
     }
 
 
---------------
-------------
@@ -72,7 +72,7 @@
         ReadBackedPileup pileup = stratifiedContext.getBasePileup();
         for ( PileupElement p : pileup ) {
             if ( alleleCounts.containsKey(p.getBase()) )
-                alleleCounts.put(p.getBase(), alleleCounts.get(p.getBase())+1);
+                alleleCounts.put(p.getBase(), alleleCounts.get(p.getBase())+p.getRepresentativeCount());
         }
 
         // we need to add counts in the correct order
---------------
-------------
@@ -321,7 +321,7 @@
             haplotypeMap.clear();
 
             if (getAlleleListFromVCF) {
-                 for( final VariantContext vc_input : tracker.getValues(UAC.alleles) ) {
+                 for( final VariantContext vc_input : tracker.getValues(UAC.alleles, loc) ) {
                       if( vc_input != null &&
                               allowableTypes.contains(vc_input.getType()) &&
                               ref.getLocus().getStart() == vc_input.getStart()) {
---------------
-------------
@@ -358,7 +358,7 @@
         if (error instanceof RuntimeException)
             this.error = (RuntimeException)error;
         else
-            this.error = new ReviewedStingException("An error occurred during the traversal.", error);
+            this.error = new ReviewedStingException("An error occurred during the traversal.  Message=" + error.getMessage(), error);
 
     }
 
---------------
-------------
@@ -414,7 +414,7 @@
      * @return vc subcontext
      */
     public VariantContext subContextFromGenotypes(Collection<Genotype> genotypes, Set<Allele> alleles) {
-        return new VariantContext(getSource(), contig, start, stop, alleles, genotypes, getNegLog10PError(), getFilters(), getAttributes());
+        return new VariantContext(getSource(), contig, start, stop, alleles, genotypes, getNegLog10PError(), filtersWereApplied() ? getFilters() : null, getAttributes());
     }
 
 
---------------
-------------
@@ -316,6 +316,7 @@
             // if in GENOTYPE_GIVEN_ALLELES mode, we still want to allow the use of a poor allele
             else if ( UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {
                 myAlleles.add(alternateAllele);
+                alleleCountsofMLE.add(AFresult.getAlleleCountsOfMLE()[indexOfAllele-1]);
             }
         }
 
---------------
-------------
@@ -239,7 +239,7 @@
                 if ( ! expectedMD5.equals(filemd5sum) ) {
                     // we are going to fail for real in assertEquals (so we are counted by the testing framework).
                     // prepare ourselves for the comparison
-                    System.out.printf("##### Test %s is going fail #####%n", name);
+                    System.out.printf("##### Test %s is going to fail #####%n", name);
                     String pathToExpectedMD5File = getMD5FilePath(expectedMD5, "[No DB file found]");
                     String pathToFileMD5File = getMD5FilePath(filemd5sum, "[No DB file found]");
                     System.out.printf("##### Path to expected   file (MD5=%s): %s%n", expectedMD5, pathToExpectedMD5File);
---------------
-------------
@@ -550,8 +550,7 @@
             if (vc.hasAttribute(VCFConstants.DEPTH_KEY))
                 depth += Integer.valueOf(vc.getAttributeAsString(VCFConstants.DEPTH_KEY));
 
-            // TODO -- REVERT CHANGE
-            if (rsIDs.isEmpty() && vc.hasID()) rsIDs.add(vc.getID());
+            if ( vc.hasID() && ! vc.getID().equals(VCFConstants.EMPTY_ID_FIELD) ) rsIDs.add(vc.getID());
 
             if (mergeInfoWithMaxAC && vc.hasAttribute(VCFConstants.ALLELE_COUNT_KEY)) {
                 String rawAlleleCounts = vc.getAttributeAsString(VCFConstants.ALLELE_COUNT_KEY);
---------------
-------------
@@ -152,7 +152,7 @@
         }
     }
 
-    private double calcEpsilon( byte ref, byte read, byte qualB ) {
+    protected double calcEpsilon( byte ref, byte read, byte qualB ) {
         return EPSILONS[ref][read][qualB];
     }
 
---------------
-------------
@@ -207,7 +207,7 @@
             throw new RuntimeException(String.format("BUG: p Reference error is out of bounds (0.0 - 0.01) is allow range %f", pRefError));
         }
 
-        double pTriStateGenotype = heterozyosity * PROB_OF_REFERENCE_ERROR;
+        double pTriStateGenotype = heterozyosity * pRefError;
 //        if ( pTriStateGenotype >= heterozyosity ) {
 //            throw new RuntimeException(String.format("p Tristate genotype %f is greater than the heterozygosity %f", pTriStateGenotype, heterozyosity));
 //        }
---------------
-------------
@@ -1153,7 +1153,7 @@
     }
 
     private static final List<Allele> NO_CALL_ALLELES = Arrays.asList(Allele.NO_CALL, Allele.NO_CALL);
-    public static final double SUM_GL_THRESH_NOCALL = -0.001; // if sum(gl) is bigger than this threshold, we treat GL's as non-informative and will force a no-call.
+    public static final double SUM_GL_THRESH_NOCALL = -0.1; // if sum(gl) is bigger than this threshold, we treat GL's as non-informative and will force a no-call.
 
     /**
      * subset the Variant Context to the specific set of alleles passed in (pruning the PLs appropriately)
---------------
-------------
@@ -298,7 +298,7 @@
     public static Pair<Double,Double> calculatePRecursively(int n, int m, long u, boolean twoSided, ExactMode mode) {
         if ( m > 8 && n > 5 ) { throw new StingException(String.format("Please use the appropriate (normal or sum of uniform) approximation. Values n: %d, m: %d",n,m)); }
         double p = mode == ExactMode.POINT ? cpr(n,m,u) : cumulativeCPR(n,m,u);
-        p *= twoSided ? 2.0 : 1.0;
+        //p *= twoSided ? 2.0 : 1.0;
         double z;
         try {
 
---------------
-------------
@@ -29,7 +29,7 @@
 public class QualByDepth extends InfoFieldAnnotation implements StandardAnnotation, ActiveRegionBasedAnnotation {
 
     public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {
-        if ( stratifiedContexts.size() == 0 )
+        if ( !vc.hasLog10PError() || stratifiedContexts.size() == 0 )
             return null;
 
         final GenotypesContext genotypes = vc.getGenotypes();
---------------
-------------
@@ -1000,7 +1000,7 @@
     public static VariantContext trimAlleles(final VariantContext inputVC, final boolean trimForward, final boolean trimReverse) {
         if ( inputVC == null ) throw new IllegalArgumentException("inputVC cannot be null");
 
-        if ( inputVC.getNAlleles() <= 1 )
+        if ( inputVC.getNAlleles() <= 1 || inputVC.isSNP() )
             return inputVC;
 
         // see whether we need to trim common reference base from all alleles
---------------
-------------
@@ -64,7 +64,7 @@
     protected int windowSize = 10;
 
     @Argument(fullName="mismatchFraction", shortName="mismatch", doc="fraction of base qualities needing to mismatch for a position to have high entropy; to disable set to <= 0 or > 1", required=false)
-    protected double mismatchThreshold = 0.15;
+    protected double mismatchThreshold = 0.0;
 
     @Argument(fullName="minReadsAtLocus", shortName="minReads", doc="minimum reads at a locus to enable using the entropy calculation", required=false)
     protected int minReadsAtLocus = 4;
---------------
-------------
@@ -374,7 +374,7 @@
         int start = 1;
         int stop = -1;
 
-        final int colonIndex = str.indexOf(":");
+        final int colonIndex = str.lastIndexOf(":");
         if(colonIndex == -1) {
             contig = str.substring(0, str.length());  // chr1
             stop = Integer.MAX_VALUE;
---------------
-------------
@@ -47,8 +47,8 @@
         Scanner scanner = new Scanner(indexFile);
 
         while( scanner.hasNext() ) {
-            // Tokenize and validate the index line.
-            String result = scanner.findInLine("([\\w\\s\\.]+)\\t+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)");
+            // Tokenize and validate the index line.                     
+            String result = scanner.findInLine("(.+)\\t+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)");
             if( result == null )
                 throw new PicardException("Found invalid line in index file:" + scanner.nextLine());
             MatchResult tokens = scanner.match();
---------------
-------------
@@ -50,7 +50,7 @@
             ByteBuf buffer,
             List<Object> out) throws Exception {
 
-        switch(state()) {
+        switch (state()) {
         case READ_HEADER_VERSION:
             int headerVersion = buffer.readInt();
             checkState(headerVersion == MessageEncoder.HEADER_VERSION, "Unexpected header version");
---------------
-------------
@@ -246,7 +246,6 @@
          * @return self, for chaining
          */
         public Row cell(String columnId, Object value) {
-            checkNotNull(value, "Must supply some value");
             checkId(columnId);
             cells.put(columnId, value);
             return this;
---------------
-------------
@@ -22,7 +22,6 @@
 import org.onlab.onos.net.packet.PacketProviderService;
 import org.onlab.onos.net.provider.AbstractProvider;
 import org.onlab.onos.net.provider.ProviderId;
-import org.onlab.onos.openflow.controller.DefaultOpenFlowPacketContext;
 import org.onlab.onos.openflow.controller.Dpid;
 import org.onlab.onos.openflow.controller.OpenFlowController;
 import org.onlab.onos.openflow.controller.OpenFlowPacketContext;
---------------
-------------
@@ -343,7 +343,7 @@
                 kernelPool.shutdownNow();
                 kernelPool = null;
             }
-            state.setState(State.STOPPING);
+            state.setState(State.STOPPED);
             notifyProbesStop(this);
         } finally {
             lock.unlock();
---------------
-------------
@@ -332,7 +332,7 @@
                 + "  poolName: " + poolName + "\r\n"
                 + "  corePoolSize: " + corePoolSize + "\r\n"
                 + "  maxPoolSize: " + maxPoolSize + "\r\n"
-                + "  queue: " + queue.getClass() + "\r\n"
+                + "  queue: " + (queue != null ? queue.getClass() : "undefined") + "\r\n"
                 + "  queueLimit: " + queueLimit + "\r\n"
                 + "  keepAliveTime (millis): " + keepAliveTimeMillis + "\r\n"
                 + "  threadFactory: " + threadFactory + "\r\n"
---------------
-------------
@@ -290,7 +290,7 @@
         final Reentrant reentrants = getWriteReentrant();
         
         try {
-            if (reentrants.incAndGet() >= maxWriteReentrants) {
+            if (reentrants.incAndGet() > maxWriteReentrants) {
                 // Max number of reentrants is reached
                 
                 queueRecord.setMessage(
---------------
-------------
@@ -980,7 +980,7 @@
                         final String expiresDate =
                                 cookiesStr.substring(valueStart, valueEnd);
                         final Date date = OLD_COOKIE_FORMAT.get().parse(expiresDate);
-                        cookie.setMaxAge((int) (date.getTime() - System.currentTimeMillis()));
+                        cookie.setMaxAge((int) (date.getTime() - System.currentTimeMillis()) / 1000);
                     } catch (ParseException ignore) {
                     }
 
---------------
-------------
@@ -1,7 +1,7 @@
 /*
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
  *
- * Copyright (c) 2008-2010 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008-2011 Oracle and/or its affiliates. All rights reserved.
  *
  * The contents of this file are subject to the terms of either the GNU
  * General Public License Version 2 only ("GPL") or the Common Development
---------------
-------------
@@ -555,6 +555,7 @@
         configureMonitoring(listener);
     }
 
+    @SuppressWarnings("unchecked")
     private void configureMonitoring(final NetworkListener listener) {
         final TCPNIOTransport transport = listener.getTransport();
 
---------------
-------------
@@ -77,7 +77,7 @@
     private static class SettableHolder<L> extends Holder<L> {
         private L obj;
                 
-        public SettableHolder set(final L obj) {
+        public SettableHolder<L> set(final L obj) {
             this.obj = obj;
             return this;
         }
---------------
-------------
@@ -581,7 +581,7 @@
      *
      * @param filterChain the {@link FilterChain}.
      */
-    public void setFilterChain(final FilterChain filterChain) {
+    void setFilterChain(final FilterChain filterChain) {
         if (!transport.isStopped()) {
             return;
         }
---------------
-------------
@@ -1612,6 +1612,7 @@
      */
     private FilterConfigImpl createFilterConfig(final FilterRegistration registration) {
         final FilterConfigImpl fConfig = new FilterConfigImpl(this);
+        fConfig.setFilterName(registration.getName());
         if (!registration.initParameters.isEmpty()) {
             fConfig.setInitParameters(registration.initParameters);
         }
---------------
-------------
@@ -1,7 +1,7 @@
 /*
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
  *
- * Copyright (c) 2010-2011 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010-2012 Oracle and/or its affiliates. All rights reserved.
  *
  * The contents of this file are subject to the terms of either the GNU
  * General Public License Version 2 only ("GPL") or the Common Development
---------------
-------------
@@ -161,6 +161,7 @@
             ((WorkerThread) currentThread).setSelectorThread(false);
         }
         
+        runnerThreadActivityCounter.compareAndSet(1, 0);
         selectorRunnerThread = null;
         isResume = true;
         dumbVolatile++;
---------------
-------------
@@ -98,6 +98,7 @@
 
 
     @Override
+    @SuppressWarnings("unchecked")
     public NextAction handleWrite(final FilterChainContext ctx) throws IOException {
         final FilterChainContext suspendedParentContext =
                 puFilter.suspendedContextAttribute.get(ctx);
---------------
-------------
@@ -172,7 +172,7 @@
             if (content.isLast()) {
                 contentRead = true;
             }
-            if (content.getContent().position() > 0) {
+            if (content.getContent().hasRemaining()) {
                 buffers.append(content.getContent());
             }
         }
---------------
-------------
@@ -202,7 +202,7 @@
         String lastModified = headers.getHeader("Last-Modified");
         entry.lastModified = (lastModified == null
                 ? String.valueOf(cacheFile.lastModified()) : lastModified);
-        entry.contentType = headers.getHeader("Content-type");
+        entry.contentType = response.getContentType();
         entry.xPoweredBy = headers.getHeader("X-Powered-By");
         entry.date = headers.getHeader("Date");
         entry.Etag = headers.getHeader("Etag");
---------------
-------------
@@ -810,7 +810,7 @@
 
     @Override
     public BuffersBuffer get(final ByteBuffer dst) {
-        get(dst, 0, dst.remaining());
+        get(dst, dst.position(), dst.remaining());
         dst.position(dst.limit());
 
         return this;
---------------
-------------
@@ -1,7 +1,7 @@
 /*
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
  *
- * Copyright (c) 2011 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011-2012 Oracle and/or its affiliates. All rights reserved.
  *
  * The contents of this file are subject to the terms of either the GNU
  * General Public License Version 2 only ("GPL") or the Common Development
---------------
-------------
@@ -491,7 +491,7 @@
                 isSpecial = false;
                 // $Version must be the first avpair in the cookie header
                 // (sc must be null)
-                if (CookieUtils.equals("Version", bytes, nameStart - arrayOffset, nameEnd - arrayOffset)
+                if (CookieUtils.equals("Version", bytes, nameStart, nameEnd)
                         && cookie == null) {
                     // Set version
                     if (bytes[valueStart] == '1'
---------------
-------------
@@ -55,6 +55,7 @@
     this.webSocketServerFactory = webSocketServerFactory;
     this.tmpdir = tmpdir;
     this.multiPartConfig = new MultipartConfigElement(tmpdir);
+    this.addManaged(webSocketServerFactory);
   }
 
   @Override
---------------
-------------
@@ -307,6 +307,7 @@
 			if (delegate != this) {
 				if (delegate instanceof MessageListener) {
 					((MessageListener) delegate).onMessage(message, pattern);
+					return;
 				}
 			}
 
---------------
-------------
@@ -526,7 +526,6 @@
 			return;
 		}
 		isMulti = true;
-		openPipeline();
 		try {
 			if (isPipelined()) {
 				pipeline(asyncConn.multi());
---------------
-------------
@@ -154,6 +154,7 @@
           // fall through and retry
           interrupted = true;
         } catch (ExecutionException ex) {
+          if(future != null) cache.remove(source, future);
           throw launderThrowable(source, ex.getCause());
         }
       }
---------------
-------------
@@ -11,7 +11,7 @@
   @Test
   public void args() throws IOException {
     shouldCompileTo("{{i18nJs bundle=\"args\" wrap=false}}", null,
-        "  // English (United States)\n" +
+        "  /* English (United States) */\n" +
             "  I18n.translations = I18n.translations || {};\n" +
             "  I18n.translations['en_US'] = {\n" +
             "    \"arg3\": \"{{arg0}}, {{arg1}}, {{arg2}}\",\n" +
---------------
-------------
@@ -117,7 +117,7 @@
     /** Add a {@link TypeConverter} to provide bidirectional mapping between
      * a native and Java type.  
      */
-    protected void addTypeConverter(Class cls, TypeConverter converter) {
+    public void addTypeConverter(Class cls, TypeConverter converter) {
         addFromNativeConverter(cls, converter);
         addToNativeConverter(cls, converter);
     }
---------------
-------------
@@ -173,7 +173,6 @@
             }
         }
         catch(Exception e) {
-            throw new RuntimeException("Native library delete failed: " + e.getMessage());
         }
         return false;
     }
---------------
-------------
@@ -226,7 +226,6 @@
                                                     callingConvention, flags);
             cbstruct = peer != 0 ? new Pointer(peer) : null;
         }
-
     }
     
     private Class getNativeType(Class cls) {
---------------
-------------
@@ -117,7 +117,7 @@
     /** Add a {@link TypeConverter} to provide bidirectional mapping between
      * a native and Java type.  
      */
-    protected void addTypeConverter(Class cls, TypeConverter converter) {
+    public void addTypeConverter(Class cls, TypeConverter converter) {
         addFromNativeConverter(cls, converter);
         addToNativeConverter(cls, converter);
     }
---------------
-------------
@@ -1287,7 +1287,7 @@
     }
 
     public String toString(boolean debug) {
-        return toString(0, true, true);
+        return toString(0, true, debug);
     }
 
     private String format(Class type) {
---------------
-------------
@@ -219,7 +219,7 @@
                 result |= Kernel32.FILE_NOTIFY_CHANGE_CREATION;
             }
             if ((mask & FILE_DELETED) != 0) {
-                result |= Kernel32.FILE_NOTIFY_CHANGE_CREATION;
+                result |= Kernel32.FILE_NOTIFY_CHANGE_NAME;
             }
             if ((mask & FILE_MODIFIED) != 0) {
                 result |= Kernel32.FILE_NOTIFY_CHANGE_LAST_WRITE;
---------------
-------------
@@ -144,6 +144,7 @@
                             + " - set the system property jna.nosys=true" + LS
                             + " - set jna.boot.library.path to include the path to the version of the " + LS + "   jnidispatch library included with the JNA jar file you are using" + LS);
         }
+        setPreserveLastError(Boolean.parseBoolean(System.getProperty("jna.preserve_last_error", "true")));
     }
     
     /** Force a dispose when this class is GC'd. */
---------------
-------------
@@ -1189,7 +1189,7 @@
                 throw new IllegalArgumentException(rclass + " is not a supported return type (in method " + method.getName() + " in " + cls + ")");
             case CVT_TYPE_MAPPER:
                 fromNative = mapper.getFromNativeConverter(rclass);
-                closure_rtype = FFIType.get(Pointer.class).peer;
+                closure_rtype = FFIType.get(rclass).peer;
                 rtype = FFIType.get(fromNative.nativeType()).peer;
                 break;
             case CVT_NATIVE_MAPPED:
---------------
-------------
@@ -26,7 +26,7 @@
  */
 @RunWith(Suite.class)
 @Suite.SuiteClasses({
-//  Trace_summaryTest.class
+    Trace_7564_20101203T004633_IntegrationTest.class,
     Trace_0927_20101209T124742_IntegrationTest.class,
     Trace_1325_20101215T014845_IntegrationTest.class,
     Trace_1379_20101211T010025_IntegrationTest.class,
---------------
-------------
@@ -110,7 +110,7 @@
                 sPageMapping = pageMappingService.create(key, form, externalUrlAdapter, authorizationRules);
                 break;
             case SFormMapping.TARGET_LEGACY:
-                sPageMapping = pageMappingService.create(key, null, legacyUrlAdapter, authorizationRules);
+                sPageMapping = pageMappingService.create(key, null, legacyUrlAdapter, null);
                 break;
             case SFormMapping.TARGET_UNDEFINED:
                 sPageMapping = null;
---------------
-------------
@@ -278,7 +278,6 @@
         return "SUserImpl{" +
                 "firstName='" + firstName + '\'' +
                 ", lastName='" + lastName + '\'' +
-                ", password='" + password + '\'' +
                 ", userName='" + userName + '\'' +
                 ", iconName='" + iconName + '\'' +
                 ", iconPath='" + iconPath + '\'' +
---------------
-------------
@@ -567,6 +567,7 @@
         pageBuilder.updateDescription(pageProperties.getProperty(PROPERTIES_DESCRIPTION));
         pageBuilder.updateDisplayName(pageProperties.getProperty(PROPERTIES_DISPLAY_NAME));
         pageBuilder.updateName(pageProperties.getProperty(PROPERTIES_NAME));
+        pageBuilder.updateContentType(pageProperties.getProperty(PROPERTIES_CONTENT_TYPE, SContentType.PAGE));
         final SPage sPage = updatePage(pageId, pageBuilder.done());
         for (final PageServiceListener pageServiceListener : pageServiceListeners) {
             pageServiceListener.pageUpdated(sPage, content);
---------------
-------------
@@ -121,7 +121,7 @@
     public SPageURL resolvePageURL(SPageMapping pageMapping, Map<String, Serializable> context) throws SExecutionException {
         String url = pageMapping.getUrl();
         String urlAdapter = pageMapping.getUrlAdapter();
-        if (url != null && urlAdapter != null) {
+        if (urlAdapter != null) {
             url = getUrlAdapter(urlAdapter).adapt(url, pageMapping.getKey(), context);
         }
         return new SPageURL(url, pageMapping.getPageId());
---------------
-------------
@@ -4056,7 +4056,7 @@
                 countersForProcessInstance.put(flownodeName, flownodeCounters);
             }
             // Archived flownodes:
-            final List<SFlowNodeInstanceStateCounter> archivedFlownodes = serviceAccessor.getActivityInstanceService().getNumberOfFlownodesInAllStates(
+            final List<SFlowNodeInstanceStateCounter> archivedFlownodes = serviceAccessor.getActivityInstanceService().getNumberOfArchivedFlownodesInAllStates(
                     processInstanceId);
             for (SFlowNodeInstanceStateCounter nodeCounter : archivedFlownodes) {
                 String flownodeName = nodeCounter.getFlownodeName();
---------------
-------------
@@ -44,7 +44,7 @@
     }
 
     public SConstraintDefinitionImpl(final ConstraintDefinition rule) {
-        this(rule.getName(), rule.getExpression(), rule.getExplanation(), SConstraintType.CUSTOM);
+        this(rule.getName(), rule.getExpression(), rule.getExplanation(), SConstraintType.valueOf(rule.getConstraintType().toString()));
         for (final String inputName : rule.getInputNames()) {
             inputNames.add(inputName);
         }
---------------
-------------
@@ -1,4 +1,4 @@
-package $site;format="normalize"$.element.$type;format="normalize"$;
+package $site;format="normalize"$.element.$type;format="ndeprefix"$;
 import static wcs.Api.*;
 import wcs.api.Log;
 import wcs.api.Index;
---------------
-------------
@@ -108,6 +108,7 @@
         if (Entities.isManaged(this)) {
             Entities.manage(dockerHosts);
             Entities.manage(fabric);
+            Entities.manage(buckets);
         }
 
         dockerHosts.addEnricher(Enrichers.builder()
---------------
-------------
@@ -173,7 +173,7 @@
             }
         }
 
-        if( m_taxonset.get() == null && labels != null ) {
+        if( m_taxonset.get() == null && labels != null && isLabelledNewickInput.get() ) {
             m_taxonset.setValue(new TaxonSet(TaxonSet.createTaxonList(labels)), this);
         }
 
---------------
-------------
@@ -110,6 +110,7 @@
                 } else {
                     labels = new ArrayList<String>();
                     createUnrecognizedTaxa = true;
+            		sortNodesAlphabetically = true;
                 }
             } else {
                 if (m_initial.get() != null) {
---------------
-------------
@@ -18,7 +18,7 @@
 
     @Override
     public final boolean isEmpty() {
-        return getFromMap(REGISTERED_KEYS_KEY) != null;
+        return getFromMap(REGISTERED_KEYS_KEY) == null;
     }
 
     @Override
---------------
-------------
@@ -11,7 +11,7 @@
 
 	public static final String TRACEE_CONFIG_PREFIX = "tracee.";
 
-	private static final String DEFAULT_PROFILE_PREFIX = DEFAULT_PROFILE+".";
+	static final String DEFAULT_PROFILE_PREFIX = DEFAULT_PROFILE+".";
 	public static final String GENERATE_REQUEST_ID = "requestIdLength";
 	public static final String GENERATE_SESSION_ID = "sessionIdLength";
 
---------------
-------------
@@ -375,6 +375,7 @@
             lastMatch = startoff;
             newpos = EditorHelper.offsetToCharacterPosition(editor, newend);
 
+            lnum += newpos.line - endpos.line;
             line2 += newpos.line - endpos.line;
           }
         }
---------------
-------------
@@ -301,7 +301,7 @@
               state = STATE_RANGE_MARK;
             }
             else if (ch == '+' || ch == '-') {
-              location.append('0');
+              location.append('.');
               state = STATE_RANGE_OFFSET;
             }
             else if (ch == '\\') {
---------------
-------------
@@ -211,7 +211,7 @@
    * @param context The data context
    */
   public void insertAtPreviousInsert(Editor editor, DataContext context) {
-    int offset = CommandGroups.getInstance().getMotion().moveCaretToMark(editor, context, '^');
+    int offset = CommandGroups.getInstance().getMotion().moveCaretToMark(editor, '^');
     if (offset != -1) {
       MotionGroup.moveCaret(editor, offset);
     }
---------------
-------------
@@ -15,7 +15,7 @@
 
     @Override
     protected int getExpectedElements() {
-        return 1;
+        return 6;
     }
 
     @Autowired
---------------
-------------
@@ -56,7 +56,7 @@
         travelExpenseReportService.reject(travelExpenseReport, principal.getName());
     }
 
-    @PreAuthorize("hasRole('ROLE_SUPERVISOR')")
+    @PreAuthorize("hasRole('ROLE_SUPERVISOR') or #travelExpenseReport.employee.id == principal?.id")
     @RequestMapping(value = "/{id}/pdf", produces = "application/pdf")
     @Transactional
     public ResponseEntity<byte[]> asPdf(@PathVariable("id") Report travelExpenseReport) {
---------------
-------------
@@ -50,6 +50,6 @@
     }
 
     public boolean equals(Object object) {
-        return this.element.equals(object);
+        return (object.getClass().equals(this.getClass())) && this.element.getId().equals(((ReadOnlyElement) object).getId());
     }
 }
---------------
-------------
@@ -84,7 +84,7 @@
 
         try {
             // First, get the skin directory
-            String path = "/skins/" + xwiki.getSkin(xcontext) +  "/less";
+            String path = "/skins/" + xwiki.getBaseSkin(xcontext) +  "/less";
             Path lessFilesPath = Paths.get(xwiki.getEngineContext().getRealPath(path));
             Path[] includePaths = {lessFilesPath};
 
---------------
-------------
@@ -438,7 +438,7 @@
     /*-{
         var attrNames = [];
         for(var i = 0; i < element.attributes.length; i++) {
-            attrNames.push(element.attributes.item(i));
+            attrNames.push(element.attributes.item(i).nodeName);
         }
         return attrNames;
     }-*/;
---------------
-------------
@@ -528,7 +528,7 @@
      * @param session the Hibernate session, used to get the Dialect object
      * @since 5.0RC1
      */
-    private String[] addHibernateSequenceIfRequired(String[] schemaSQL, String schemaName, Session session)
+    protected String[] addHibernateSequenceIfRequired(String[] schemaSQL, String schemaName, Session session)
     {
         String[] result = schemaSQL;
 
---------------
-------------
@@ -350,7 +350,7 @@
             }
 
             try {
-                beanManager.populate(content, properties);
+                beanManager.populate(this, properties);
             } catch (PropertyException e) {
                 // Should never happen
                 logger.error("Failed to populate properties of template", e);
---------------
-------------
@@ -273,7 +273,7 @@
         }
 
         // 4) Make sure that the original document's locale is there as well.
-        documentLocales.add(getLocale(xdocument.getDocumentReference()));
+        locales.add(getLocale(xdocument.getDocumentReference()));
 
         return locales;
     }
---------------
-------------
@@ -58,6 +58,10 @@
         // See http://www.jdom.org/docs/apidocs/org/jdom/output/Format.html#setLineSeparator(java.lang.String)
         format.setLineSeparator("\n");
 
+        // TODO: Remove this line (I think we want to have XML declaration) when Wikimodel has fixed this issue:
+        // http://code.google.com/p/wikimodel/issues/detail?id=45
+        format.setOmitDeclaration(true);
+
         XMLOutputter outputter = new XMLOutputter(format);
         return outputter.outputString(jdomDoc);
     }
---------------
-------------
@@ -245,7 +245,7 @@
 
             // Import package
             try {
-                importer.Import(packFile.getContent(context));
+                importer.Import(packFile.getContentInputStream(context));
             } catch (IOException e) {
                 throw new WikiManagerException(WikiManagerException.ERROR_WM_PACKAGEIMPORT,
                     this.localizationManager.getTranslationPlain(WikiManagerMessageTool.ERROR_PACKAGEIMPORT,
---------------
-------------
@@ -1715,7 +1715,8 @@
             // called
             // directly from a template and in this case we only want HTML as a result and not wiki syntax.
             // TODO: find a more generic way to handle html macro because this works only for XWiki 1.0 and XWiki 2.0
-            if (isInRenderingEngine && !is10Syntax(syntaxId)) {
+            // Add the {{html}}{{/html}} only when result really contains html since it's not needed for pure text
+            if (isInRenderingEngine && !is10Syntax(syntaxId) && (result.indexOf("<") != -1 || result.indexOf(">") != -1)) {
                 result.insert(0, "{{html clean=\"false\" wiki=\"false\"}}");
                 result.append("{{/html}}");
             }
---------------
-------------
@@ -124,7 +124,7 @@
     }
 
     public Path getChunkPath(Vector3i chunkPos) {
-        return worldsPath.resolve(getChunkFilename(chunkPos));
+        return worldPath.resolve(getChunkFilename(chunkPos));
     }
 
     public Path getChunkTempPath(Vector3i chunkPos) {
---------------
-------------
@@ -50,7 +50,7 @@
     }
 
     public boolean isTemplate() {
-        return template;
+        return template || familyFactory == null;
     }
 
     public void setTemplate(boolean template) {
---------------
-------------
@@ -94,7 +94,7 @@
       "(" + URL_VALID_DOMAIN + ")" +                               //  $5 Domain(s)
       "(?::(" + URL_VALID_PORT_NUMBER +"))?" +                     //  $6 Port number (optional)
       "(/" +
-        URL_VALID_PATH + "*" +
+        URL_VALID_PATH + "*+" +
       ")?" +                                                       //  $7 URL Path and anchor
       "(\\?" + URL_VALID_URL_QUERY_CHARS + "*" +                   //  $8 Query String
               URL_VALID_URL_QUERY_ENDING_CHARS + ")?" +
---------------
-------------
@@ -54,7 +54,7 @@
   private static final String URL_VALID_PRECEEDING_CHARS = "(?:[^A-Z0-9@＠$#＃\u202A-\u202E]|^)";
 
   private static final String URL_VALID_CHARS = "[\\p{Alnum}" + LATIN_ACCENTS_CHARS + "]";
-  private static final String URL_VALID_SUBDOMAIN = "(?:(?:" + URL_VALID_CHARS + "[" + URL_VALID_CHARS + "\\-_]*)?" + URL_VALID_CHARS + "\\.)";
+  private static final String URL_VALID_SUBDOMAIN = "(?>(?:" + URL_VALID_CHARS + "[" + URL_VALID_CHARS + "\\-_]*)?" + URL_VALID_CHARS + "\\.)";
   private static final String URL_VALID_DOMAIN_NAME = "(?:(?:" + URL_VALID_CHARS + "[" + URL_VALID_CHARS + "\\-]*)?" + URL_VALID_CHARS + "\\.)";
   /* Any non-space, non-punctuation characters. \p{Z} = any kind of whitespace or invisible separator. */
   private static final String URL_VALID_UNICODE_CHARS = "[.[^\\p{Punct}\\s\\p{Z}\\p{InGeneralPunctuation}]]";
---------------
-------------
@@ -46,7 +46,7 @@
 
     @GET
     public Response getAvailablePhoneNumber(@PathParam("accountSid") final String accountSid,
-            @PathParam("IsoCountryCode") final String isoCountryCode, @QueryParam("areaCode") String areaCode,
+            @PathParam("IsoCountryCode") final String isoCountryCode, @QueryParam("AreaCode") String areaCode,
             @QueryParam("Contains") String filterPattern, @QueryParam("SmsEnabled") String smsEnabled,
             @QueryParam("MmsEnabled") String mmsEnabled, @QueryParam("VoiceEnabled") String voiceEnabled,
             @QueryParam("FaxEnabled") String faxEnabled, @QueryParam("UssdEnabled") String ussdEnabled,
---------------
-------------
@@ -46,7 +46,7 @@
 
     @GET
     public Response getAvailablePhoneNumber(@PathParam("accountSid") final String accountSid,
-            @PathParam("IsoCountryCode") final String isoCountryCode, @QueryParam("areaCode") String areaCode,
+            @PathParam("IsoCountryCode") final String isoCountryCode, @QueryParam("AreaCode") String areaCode,
             @QueryParam("Contains") String filterPattern, @QueryParam("SmsEnabled") String smsEnabled,
             @QueryParam("MmsEnabled") String mmsEnabled, @QueryParam("VoiceEnabled") String voiceEnabled,
             @QueryParam("FaxEnabled") String faxEnabled, @QueryParam("UssdEnabled") String ussdEnabled,
---------------
-------------
@@ -46,7 +46,7 @@
 
     @GET
     public Response getAvailablePhoneNumber(@PathParam("accountSid") final String accountSid,
-            @PathParam("IsoCountryCode") final String isoCountryCode, @QueryParam("AreaCode") String areaCode,
+            @PathParam("IsoCountryCode") final String isoCountryCode, @QueryParam("areaCode") String areaCode,
             @QueryParam("Contains") String filterPattern, @QueryParam("SmsEnabled") String smsEnabled,
             @QueryParam("MmsEnabled") String mmsEnabled, @QueryParam("VoiceEnabled") String voiceEnabled,
             @QueryParam("FaxEnabled") String faxEnabled, @QueryParam("UssdEnabled") String ussdEnabled,
---------------
-------------
@@ -165,7 +165,7 @@
                 // is one folder level below the one we loockig for and starts
                 // with path...
                 if (stack.length == directoryStack.length + 1) {
-                    children.add(string);
+                    children.add(stack[stack.length-1]);
                 }
             }
 
---------------
-------------
@@ -108,6 +108,7 @@
                     LOG.info("Attaching existing events to TimeTree in batch " + batchNumber);
                 }
                 if (configuration.getInclusionPolicies().getNodeInclusionPolicy().include(input)) {
+                    deleteTimeTreeRelationship(input);
                     createTimeTreeRelationship(input);
                 }
             }
---------------
-------------
@@ -28,7 +28,7 @@
 
 		PropertyMeta<T, E> property = propertyFinder.findProperty(propertyNameMatcher);
 
-		if (property == null && ! selectedParameters.isEmpty()) {
+		if (property == null && selectedParameters.isEmpty()) {
 			ConstructorDefinition<T> constructorDefinition = getSmallestConstructorWithAtLeast(selectedParameters.size() + 1);
 
 			if (constructorDefinition != null) {
---------------
-------------
@@ -122,7 +122,7 @@
 	}
 
 	private boolean isAllConsumedFromMark(int bufferIndex) {
-		return csvBuffer.getMark() >= bufferIndex -1 ;
+		return (bufferIndex) <  (csvBuffer.getMark() + 1)  ;
 	}
 
 	private int unescape(char[] chars, int offset, int length) {
---------------
-------------
@@ -28,6 +28,7 @@
 
 	public Object execute(final URL url, final String pMethodName, final Object[] pParams) throws ConfluenceXmlRpcClientException {
 		try {
+			logger.debug("execute url: " + url + " method: " + pMethodName);
 			track();
 			return xmlrpcService.execute(url, pMethodName, pParams);
 		} catch (final XmlrpcServiceException e) {
---------------
-------------
@@ -32,7 +32,7 @@
 			final MapperCalendar mapperCalendar) {
 		final List<StringObjectMapper<ShortenerUrlBean>> result = new ArrayList<StringObjectMapper<ShortenerUrlBean>>();
 		result.add(new StringObjectMapperAdapter<ShortenerUrlBean, ShortenerUrlIdentifier>("id", shortenerUrlIdentifierMapper));
-		result.add(new StringObjectMapperAdapter<ShortenerUrlBean, String>("name", mapperString));
+		result.add(new StringObjectMapperAdapter<ShortenerUrlBean, String>("url", mapperString));
 		result.add(new StringObjectMapperAdapter<ShortenerUrlBean, Calendar>("created", mapperCalendar));
 		result.add(new StringObjectMapperAdapter<ShortenerUrlBean, Calendar>("modified", mapperCalendar));
 		return result;
---------------
-------------
@@ -30,7 +30,7 @@
 		@Override
 		public boolean validate(final String object) {
 			for (final char c : object.toCharArray()) {
-				if (!Character.isLetter(c) && c != AnalyticsReportDao.SEPERATOR) {
+				if (!Character.isLetterOrDigit(c) || c == AnalyticsReportDao.SEPERATOR) {
 					return false;
 				}
 			}
---------------
-------------
@@ -31,6 +31,6 @@
 		response.setCharacterEncoding("UTF-8");
 		response.setContentType("text/html");
 		final PrintWriter out = response.getWriter();
-		out.println("<h2>Dashboard</h2>");
+		out.println("<h2>Sample</h2>");
 	}
 }
---------------
-------------
@@ -32,7 +32,6 @@
 	protected Widget createWidget(final HttpServletRequest request, final HttpServletResponse response, final HttpContext context) throws Exception {
 		final TagWidget a = new TagWidget("a", content);
 		a.addAttribute("href", "mailto:" + email);
-		a.render(request, response, context);
 		return a;
 	}
 }
---------------
-------------
@@ -27,7 +27,7 @@
 
 	private static final long serialVersionUID = 1328676176772634649L;
 
-	private static final String DEFAULT_TARGET = "dashboard";
+	private static final String DEFAULT_TARGET = "search";
 
 	private final Logger logger;
 
---------------
-------------
@@ -54,6 +54,7 @@
 		EasyMock.expect(context.getServiceReferences("de.benjaminborbe.search.api.SearchSpecial", null)).andReturn(emptyServiceReferences).anyTimes();
 		EasyMock.expect(context.getServiceReferences("de.benjaminborbe.configuration.api.ConfigurationDescription", null)).andReturn(emptyServiceReferences).anyTimes();
 		EasyMock.expect(context.getServiceReferences("de.benjaminborbe.xmpp.api.XmppCommand", null)).andReturn(emptyServiceReferences).anyTimes();
+		EasyMock.expect(context.getServiceReferences("de.benjaminborbe.messageservice.api.MessageConsumer", null)).andReturn(emptyServiceReferences).anyTimes();
 		EasyMock.expect(context.getService(extServiceReference)).andReturn(extBundle);
 
 		EasyMock.expect(context.registerService(EasyMock.anyObject(String.class), EasyMock.anyObject(Object.class), EasyMock.anyObject(Dictionary.class)))
---------------
-------------
@@ -7,6 +7,6 @@
 
 	@Override
 	public String getValue(final TaskContext o) {
-		return o.getName();
+		return o.getName() != null ? o.getName().toLowerCase() : o.getName();
 	}
 }
---------------
-------------
@@ -89,6 +89,7 @@
 			logger.debug(e.getClass().getName(), e);
 			throw new LdapException(e);
 		}
+
 	}
 
 	public String getFullname(final String username) throws LdapException {
---------------
-------------
@@ -31,6 +31,7 @@
 				bundle.start();
 			}
 			catch (final Exception e) {
+				servletContext.log("Starting bundle [" + bundle.getSymbolicName() + "] failed!", e);
 			}
 		}
 	}
---------------
-------------
@@ -79,7 +79,7 @@
 		final ChatManager chatManager = connection.getChatManager();
 		final MessageListener messageListener = new MyMessageListener();
 		final Chat chat = chatManager.createChat(user.getUid(), messageListener);
-		chat.sendMessage("hello ben!");
+		chat.sendMessage(message);
 	}
 
 	public XmppUser getUserByName(final String name) {
---------------
-------------
@@ -371,7 +371,6 @@
 		finally {
 			if (duration.getTime() > DURATION_WARN)
 				logger.debug("duration " + duration.getTime());
-
 		}
 	}
 
---------------
-------------
@@ -8,7 +8,7 @@
 
 	@Override
 	public boolean apply(final String input) {
-		return input != null && input.length() >= DistributedSearchConstants.MAX_WORD_LENGTH;
+		return input != null && input.length() <= DistributedSearchConstants.MAX_WORD_LENGTH;
 	}
 
 }
---------------
-------------
@@ -446,7 +446,7 @@
 
         String rootPath = StringUtils.substringBeforeLast( pathInfo, "/" );
 
-        if ( StringUtils.endsWith( rootPath, "/" + repoGroupConfig.getMergedIndexPath() ) )
+        if ( StringUtils.endsWith( rootPath, repoGroupConfig.getMergedIndexPath() ) )
         {
             // we are in the case of index file request
             String requestedFileName = StringUtils.substringAfterLast( pathInfo, "/" );
---------------
-------------
@@ -24,7 +24,7 @@
 
 /**
  * @author Olivier Lamy
- * @since TODO
+ * @since 1.4
  */
 @Service( "pingService#rest" )
 public class DefaultPingService
---------------
-------------
@@ -263,8 +263,6 @@
         return repository;
     }
 
-
-    // FIXME cleanup repositoryGroups when deleting a ManagedRepo
     public Boolean deleteManagedRepository( String repositoryId, AuditInformation auditInformation,
                                             boolean deleteContent )
         throws RepositoryAdminException
---------------
-------------
@@ -1,20 +1,22 @@
 package org.apache.maven.archiva.webdav.httpunit;
 
 /*
- *  Copyright 2008 jdumay.
- * 
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *  under the License.
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
  */
 
 import com.meterware.httpunit.HeaderOnlyWebRequest;
---------------
-------------
@@ -65,6 +65,7 @@
         cloned.setPlugins( clonePlugins( model.getPlugins() ) );
         cloned.setReports( cloneReports( model.getReports() ) );
         cloned.setDependencyManagement( cloneDependencies( model.getDependencyManagement() ) );
+        cloned.setProperties( clone(model.getProperties() ) );
 
         return cloned;
     }
---------------
-------------
@@ -25,6 +25,7 @@
  * @author Edwin Punzalan
  */
 public abstract class AbstractCompoundQuery
+    implements Query
 {
     protected List queries;
     
---------------
-------------
@@ -1687,8 +1687,6 @@
                 namespace ).withProjectId( project ).build();
 
         this.projectVersionMetadataModelTemplate.deleteRow( key );
-
-
     }
 
     @Override
---------------
-------------
@@ -261,7 +261,7 @@
                 if ( !projectMetadataFileInTargetRepo.exists() )
                 {
 
-                    copyFile( projectMetadataFileInSourceRepo, projectMetadataFileInSourceRepo );
+                    copyFile( projectMetadataFileInSourceRepo, projectMetadataFileInTargetRepo );
                 }
                 else
                 {
---------------
-------------
@@ -107,8 +107,7 @@
 
     protected void setObservableRepos( List<String> repoIds )
     {
-        //(UserRepositoriesStub) lookup( UserRepositories.class );
-        UserRepositoriesStub repos = applicationContext.getBean( "userRepositories#test", UserRepositoriesStub.class );
+        UserRepositoriesStub repos = applicationContext.getBean( "userRepositories", UserRepositoriesStub.class );
         repos.setObservableRepositoryIds( repoIds );
     }
 
---------------
-------------
@@ -98,7 +98,7 @@
         servletAuth = wac.getBean( ServletAuthenticator.class );
         httpAuth = wac.getBean( "httpAuthenticator#basic", HttpAuthenticator.class );
         // TODO: what if there are other types?
-        repositorySessionFactory = wac.getBean( RepositorySessionFactory.class );
+        repositorySessionFactory = wac.getBean( "repositorySessionFactory", RepositorySessionFactory.class );
     }
 
     public void doGet( HttpServletRequest req, HttpServletResponse res )
---------------
-------------
@@ -110,6 +110,7 @@
      * plexus.requirement
      */
     @Inject
+    @Named(value="metadataTools#default")
     private MetadataTools metadataTools;
 
     @Inject
---------------
-------------
@@ -550,7 +550,7 @@
         }
         catch ( NotFoundException e )
         {
-            // Do not cache url here.
+            urlFailureCache.cacheFailure( url );
             throw e;
         }
         catch ( NotModifiedException e )
---------------
-------------
@@ -75,7 +75,7 @@
         {
             selenium.windowMaximize();
             File fileName = new File( targetPath, fileBaseName + ".png" );
-            selenium.captureEntirePageScreenshot( fileName.getAbsolutePath(), "" );
+            selenium.captureEntirePageScreenshot( fileName.getAbsolutePath(), "background=#FFFFFF" );
         }
         catch ( RuntimeException e )
         {
---------------
-------------
@@ -198,7 +198,7 @@
         }
         catch ( LayoutException e )
         {
-            log.debug( "Not processing file that is not an artifact: " + e.getMessage() );
+            log.debug( "Not processing file that is not an artifact: {}", e.getMessage() );
         }
         catch ( ContentNotFoundException e )
         {
---------------
-------------
@@ -115,8 +115,6 @@
     public void prepare()
         throws RepositoryAdminException
     {
-        Configuration config = archivaConfiguration.getConfiguration();
-
         remoteRepositories = new ArrayList<RemoteRepository>( getRemoteRepositoryAdmin().getRemoteRepositories() );
         managedRepositories = new ArrayList<ManagedRepository>( getManagedRepositoryAdmin().getManagedRepositories() );
         repositoryToGroupMap = getRepositoryGroupAdmin().getRepositoryToGroupMap();
---------------
-------------
@@ -43,7 +43,7 @@
  *
  * @version $Id$
  */
-public abstract class AbstractManagedReposigettoriesAction
+public abstract class AbstractManagedRepositoriesAction
     extends AbstractRepositoriesAdminAction
 {
     /**
---------------
-------------
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 Thomas Bouffard (redfish4ktc)
+ * Copyright 2013 Thomas Bouffard (redfish4ktc)
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
---------------
-------------
@@ -102,7 +102,7 @@
 
         try {
             String name = this.findString(this.name, "name", "Resource bundle name is required. Example: foo or foo_en");
-            ResourceBundle bundle = (ResourceBundle) findValue("texts('" + name + "')");
+            ResourceBundle bundle = (ResourceBundle) findValue("getTexts('" + name + "')");
 
             if (bundle == null) {
                 bundle = LocalizedTextUtil.findResourceBundle(name, (Locale) getStack().getContext().get(ActionContext.LOCALE));
---------------
-------------
@@ -60,6 +60,6 @@
         super.evaluateExtraParams();
 
         // force the onchange parameter
-        addParameter("onchange", getParameters().get("name") + "Redirect(this.options.selectedIndex)");
+        addParameter("onchange", getParameters().get("id") + "Redirect(this.options.selectedIndex)");
     }
 }
---------------
-------------
@@ -351,6 +351,8 @@
             value = getValue(expr, asType);
             if (value == null) {
                 value = findInContext(expr);
+                final XWorkConverter conv = ((Container)getContext().get(ActionContext.CONTAINER)).getInstance(XWorkConverter.class);
+                return conv.convertValue(getContext(), value, asType);
             }
         } finally {
             context.remove(THROW_EXCEPTION_ON_FAILURE);
---------------
-------------
@@ -831,7 +831,7 @@
     protected String escape(String name) {
         // escape any possible values that can make the ID painful to work with in JavaScript
         if (name != null) {
-            return name.replaceAll("[\\/\\.\\[\\]]", "_");
+            return name.replaceAll("[^a-zA-Z0-9_]", "_");
         } else {
             return "";
         }
---------------
-------------
@@ -66,7 +66,7 @@
 
         File file = new File(retrieveFileParams.getPathToFile());
         FileApiClientAdapter smartlingFAPI = new FileApiClientAdapterImpl(retrieveFileParams.isProductionMode(), retrieveFileParams.getApiKey(), retrieveFileParams.getProjectId());
-        StringResponse response = smartlingFAPI.getFile(file.getName(), retrieveFileParams.getLocale(), null);
+        StringResponse response = smartlingFAPI.getFile(file.getName(), retrieveFileParams.getLocale(), null, null);
 
         File translatedFile = new File(getTranslatedFilePath(file, retrieveFileParams.getLocale(), retrieveFileParams.getPathToStoreFile()));
         FileUtils.writeStringToFile(translatedFile, response.getContents(), response.getEncoding());
---------------
-------------
@@ -17,7 +17,7 @@
 
     @Produces
     Map<Class<?>, LogConverter<Object>> loadConverters() {
-        Map<Class<?>, LogConverter<Object>> converters = new HashMap<>();
+        Map<Class<?>, LogConverter<Object>> converters = new LinkedHashMap<>();
         for (LogConverter<Object> converter : converterInstances) {
             String converterType = converter.getClass().getName();
             log.debug("register converter {}", converterType);
---------------
-------------
@@ -11,7 +11,7 @@
  */
 public class Parameter {
     public static List<Parameter> allOf(Method method) {
-        final List<Parameter> list = new ArrayList<Parameter>();
+        final List<Parameter> list = new ArrayList<>();
         for (int i = 0; i < method.getParameterTypes().length; i++) {
             list.add(new Parameter(method, i));
         }
---------------
-------------
@@ -66,7 +66,7 @@
 
     private Log log;
 
-    private static final int DEFAULT_DOCKER_PORT = 4243;
+    private static final int DEFAULT_DOCKER_PORT = 2375;
     private static final String DEFAULT_DOCKER_HOST = "127.0.0.1";
     public static final String DOCKER_HOST_SYSTEM_ENV = "DOCKER_HOST";
     public static final String DOCKER_HOST_PROPERTY = "docker.host";
---------------
-------------
@@ -248,7 +248,7 @@
 		if (shouldLoadFunctionFromClassPath(reducePath)) {
 			reduce = loadResourceFromClasspath(repositoryClass, reducePath.substring(10));
 		} else {
-			reduce = mapPath;
+			reduce = reducePath.length() > 0 ? reducePath : null;
 		}
 		return new DesignDocument.View(map, reduce);
 	}
---------------
-------------
@@ -184,7 +184,7 @@
 		}
 
 		private String getError() {
-			return nodeAsString(rowNode.findValue(ERROR_FIELD_NAME));
+			return nodeAsString(rowNode.get(ERROR_FIELD_NAME));
 		}
 
 		private String nodeAsString(JsonNode node) {
---------------
-------------
@@ -393,7 +393,7 @@
 	 */
 	public ViewQuery staleOk(boolean b) {
 		reset();
-		staleOk = "ok";
+		staleOk = b ? "ok" : null;
 		return this;
 	}
 	/**
---------------
-------------
@@ -202,7 +202,7 @@
       // "die Kenntnisse der Sprache":
       build("<chunk=NPP> <chunk=NPS & pos=GEN>+", NPP, true),
       // "die Pyramide des Friedens und der Eintracht":
-      build("<chunk=NPS>+ <und> <chunk=NP[SP] & pos=GEN>+", NPS, true),
+      build("<chunk=NPS>+ <und> <chunk=NP[SP] & (pos=GEN | pos=ADV)>+", NPS, true),
       // "Teil der dort ausgestellten Bestände":
       build("<chunk=NPS>+ <der> <pos=ADV> <pos=PA2> <chunk=I-NP>", NPS, true),
       // "Autor der ersten beiden Bücher":
---------------
-------------
@@ -49,7 +49,7 @@
 	private static final String FILE_NAME = "rules" +File.separator+ "uk" +File.separator+ "replace.txt";
 	private static final String FILE_ENCODING = "utf-8";
 
-	private Map<String, String> wrongWords;        // e.g. "Đ˛Ń€ĐµŃ�Ń‚Ń– Ń€ĐµŃ�Ń‚" -> "Đ·Ń€ĐµŃ�Ń‚ĐľŃŽ"
+	private Map<String, String> wrongWords;        // e.g. "вреѿті реѿт" -> "зреѿтою"
 
 	public SimpleReplaceRule(ResourceBundle messages) throws IOException {
 		if (messages != null)
---------------
-------------
@@ -239,7 +239,7 @@
     for (int i = startPos; i < tokens.length; i++) {
       AnalyzedTokenReadings token = tokens[i];
       if (token.hasPartialPosTag("SUB") || token.hasPartialPosTag("PRO")) {
-        if (token.hasPartialPosTag("NOM") && token.hasPartialPosTag("PLU")) {
+        if (token.hasPartialPosTag("NOM:PLU") || token.getChunkTags().contains(new ChunkTag("NPP"))) {  // NPP catches 'und' phrases
           return true;
         }
       }
---------------
-------------
@@ -126,7 +126,7 @@
    */
   public final AnalyzedSentence replace(final AnalyzedSentence text)
       throws IOException {
-    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();
+    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace(); 
     AnalyzedTokenReadings[] whTokens = text.getTokens();
     final int[] tokenPositions = new int[tokens.length + 1];
     final int patternSize = patternElements.size();
---------------
-------------
@@ -211,6 +211,8 @@
 
       // ===== prepositional phrases ===========================================================
 
+      // "laut den meisten Quellen":
+      build("<laut> <regex=.*>{0,3} <Quellen>", PP, true),
       // "bei den sehr niedrigen Oberflächentemperaturen" (OpenNLP doesn't find this)
       build("<pos=PRP> <pos=ART:> <pos=ADV>* <pos=ADJ> <NP>", PP, true),
       // "in den alten Religionen, Mythen und Sagen":
---------------
-------------
@@ -239,7 +239,7 @@
   }
 
   /**
-   * Get the location of the rule file(s).
+   * Get the location of the rule file(s) in a form like {@code /org/languagetool/rules/de/grammar.xml}.
    */
   public List<String> getRuleFileNames() {
     final List<String> ruleFiles = new ArrayList<>();
---------------
-------------
@@ -520,7 +520,7 @@
   private void potentiallyAddLowercaseMatch(List<RuleMatch> ruleMatches, AnalyzedTokenReadings tokenReadings, boolean prevTokenIsDas, String token, boolean nextTokenIsPersonalPronoun) {
     if (prevTokenIsDas && !nextTokenIsPersonalPronoun) {
       // e.g. essen -> Essen
-      if (Character.isLowerCase(token.charAt(0)) && !substVerbenExceptions.contains(token)) {
+      if (Character.isLowerCase(token.charAt(0)) && !substVerbenExceptions.contains(token) && tokenReadings.hasPartialPosTag("VER:INF")) {
         final String msg = "Substantivierte Verben werden großgeschrieben.";
         final RuleMatch ruleMatch = new RuleMatch(this, tokenReadings.getStartPos(),
             tokenReadings.getStartPos() + token.length(), msg);
---------------
-------------
@@ -35,6 +35,8 @@
   
   public GermanCompoundTokenizer() throws IOException {
     wordSplitter = new GermanWordSplitter(false);
+    wordSplitter.setStrictMode(true); // required for now to make minimum length work
+    wordSplitter.setMinimumWordLength(3);
   }
   
   public List<String> tokenize(String word) {
---------------
-------------
@@ -46,7 +46,7 @@
 						+ "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"
 						+ "\u205F\u2060\u2061\u2062\u2063\u206A\u206b\u206c\u206d"
 						+ "\u206E\u206F\u3000\u3164\ufeff\uffa0\ufff9\ufffa\ufffb"
-						+ ",.;()[]{}!?:\"'’‘„“”…\\/\t\n«»<>" + "-", true);
+						+ ",.;()[]{}!?:\"'’‘„“”…\\/\t\n«»<>%" + "-", true);
 		while (st.hasMoreElements()) {
 			l.add(st.nextToken());
 		}
---------------
-------------
@@ -54,7 +54,7 @@
         // ignore
         continue;
       } else {
-        if (prevToken != null && prevToken.endsWith("-")) {
+        if (prevToken != null && !prevToken.equals("-") && !prevToken.equals("--") && prevToken.endsWith("-")) {
           char firstChar = token.charAt(0);
           if (Character.isUpperCase(firstChar)) {
             String msg = "Möglicherweise fehlt ein 'und' oder es wurde nach dem Wort " +
---------------
-------------
@@ -517,7 +517,7 @@
       // calculate matching column:      
       final int lineBreakPos = sentence.indexOf('\n');
       if (lineBreakPos == -1) {
-        columnCount += sentence.length() -1;        
+        columnCount += sentence.length();
       } else {
         if (lineBreakPos == 0) {
           columnCount = sentence.length();
---------------
-------------
@@ -199,6 +199,10 @@
           }
           allFeatsUnified &= featUnified;
         }
+        //FIXME: this is wrong! if there are multiple readings that are equivalent
+        // in different ways, we loose this information as soon as one of the
+        // equivalence is not found by another token; at the same time, we
+        // need to filter out whatever has not been found
         tokenFeaturesFound.set(i, tokenFeaturesFound.get(i) && allFeatsUnified);
         anyFeatUnified = anyFeatUnified || allFeatsUnified;
       }
---------------
-------------
@@ -58,7 +58,7 @@
     if (isLengthDifferent(getPureText(sourceText), getPureText(targetText))) {
       final AnalyzedTokenReadings[] tokens = targetText.getTokens();
       final int len = tokens[tokens.length - 1].getStartPos() + tokens[tokens.length - 1].getToken().length();
-      return new RuleMatch[] { new RuleMatch(this, 1, len, getMessage()) };
+      return new RuleMatch[] { new RuleMatch(this, 0, len, getMessage()) };
     }
     return new RuleMatch[0];
   }
---------------
-------------
@@ -234,6 +234,8 @@
       build("<pos=PRP> <chunk=NPP>+ <,> <NP>", PP, true),
       // "für die Stadtteile und selbständigen Ortsteile":
       build("<pos=PRP> <chunk=NPP>+", PP, true),
+      // "Das Bündnis zwischen der Sowjetunion und Kuba":
+      build("<pos=PRP> <der> <chunk=NPP>+", PP),
       // "in chemischen Komplexverbindungen", "für die Fische":
       build("<pos=PRP> <NP>", PP),
       // "einschließlich der biologischen und sozialen Grundlagen":
---------------
-------------
@@ -115,7 +115,7 @@
     "ich",
     "du",
     "er", "sie", "es",
-    //"wir",
+    "wir",
     "mir",
     "uns",
     "ihnen",
---------------
-------------
@@ -36,7 +36,7 @@
 
   private static final Pattern NUMERALS_EN =
           Pattern.compile("(?i)\\d{1,2}?[a-z']*|M*(D?C{0,3}|C[DM])(L?X{0,3}|X[LC])(V?I{0,3}|I[VX])$");
-  private static final Pattern PUNCTUATION = Pattern.compile("\\p{Punct}");
+  private static final Pattern PUNCTUATION = Pattern.compile("[\\p{Punct}–—]");
   private static final Pattern PUNCTUATION_NO_DOT =
           Pattern.compile("[ldmnstLDMNST]'|[–—\\p{Punct}&&[^\\.]]");
   // "[ldmnst]'" allows dealing with apostrophed words in Catalan (i.e. l'«home) 
---------------
-------------
@@ -77,7 +77,7 @@
         ruleMatches.add(ruleMatch);
         dotCount = 0;
       } else if (commaCount == 2 && !",".equals(nextToken)) {
-        final int fromPos = Math.max(0, startPos);
+        final int fromPos = Math.max(0, startPos - 1);
         final RuleMatch ruleMatch = new RuleMatch(this, fromPos, startPos + 1,
             getCommaMessage(), messages.getString("double_commas_short"));
         ruleMatch.setSuggestedReplacement(",");
---------------
-------------
@@ -195,6 +195,8 @@
       build("<chunk=NPS>+ <der> <pos=ADJ> <pos=ADV> <pos=PA2> <NP>", NPS, true),
       // "die Krankheit unserer heutigen Städte und Siedlungen":
       build("<chunk=NPS>+ <pos=PRO:POS> <pos=ADJ> <NP>", NPS, true),
+      // "der letzte der vier großen Flüsse":
+      build("<der|das> <pos=ADJ> <der> <pos=ZAL> <NP>", NPS, true),
       // "Elemente eines axiomatischen Systems":  -- führt zu Fehlalarm anderswo
       //build("<chunk=B-NP & pos=PLU> <chunk=I-NP>* <chunk=B-NP & pos=GEN> <chunk=I-NP>*", NPP),
 
---------------
-------------
@@ -93,7 +93,7 @@
     return errorMarkerEnd;
   }
 
-  public boolean isHasRealReplacement() {
+  public boolean hasRealReplacement() {
     return hasRealReplacement;
   }
 }
---------------
-------------
@@ -48,7 +48,7 @@
   }
 
   @Override
-  synchronized List<PatternRule> getPatternRules() throws IOException {
+  protected synchronized List<PatternRule> getPatternRules() throws IOException {
     return Collections.emptyList();
   }
 
---------------
-------------
@@ -492,6 +492,8 @@
         !analyzedToken.hasReadingOfType(POSType.PROPER_NOUN) &&
         !isNilReading(analyzedToken) &&
         !analyzedToken.isSentenceEnd() &&
+        !( (tokens[i-1].getToken().equals("]") || tokens[i-1].getToken().equals(")")) &&
+           ( (i == 4 && tokens[i-2].getToken().equals("…")) || (i == 6 && tokens[i-2].getToken().equals(".")) ) ) &&
         !isExceptionPhrase(i, tokens)) {
       final String msg = "Außer am Satzanfang werden nur Nomen und Eigennamen großgeschrieben";
       final RuleMatch ruleMatch = new RuleMatch(this, tokens[i].getStartPos(),
---------------
-------------
@@ -111,7 +111,8 @@
 
   @Override
   public void reset() {
-    // nothing
+    lastToken = "";
+    beforeLastToken = "";
   }
 
 }
---------------
-------------
@@ -39,7 +39,7 @@
           Pattern.compile("(?i)\\d{1,2}?[a-z']*|M*(D?C{0,3}|C[DM])(L?X{0,3}|X[LC])(V?I{0,3}|I[VX])$");
   private static final Pattern PUNCTUATION = Pattern.compile("\\p{Punct}");
   private static final Pattern PUNCTUATION_NO_DOT =
-          Pattern.compile("[ldmnst]'|[–—\\p{Punct}&&[^\\.]]");
+          Pattern.compile("[ldmnstLDMNST]'|[–—\\p{Punct}&&[^\\.]]");
   // "[ldmnst]'" allows dealing with apostrophed words in Catalan (i.e. l'«home) 
 
   protected Pattern numerals;
---------------
-------------
@@ -32,7 +32,7 @@
   private static final String[] EN_START_SYMBOLS = { "[", "(", "{", "“", "\"", "'" };
   private static final String[] EN_END_SYMBOLS   = { "]", ")", "}", "”", "\"", "'" };
 
-  private static final Pattern NUMBER = Pattern.compile("\\d+");
+  private static final Pattern NUMBER = Pattern.compile("\\d+(?:-\\d+)?");
   private static final Pattern YEAR_NUMBER = Pattern.compile("\\d\\d");
   private static final Pattern ALPHA = Pattern.compile("\\p{L}+");
 
---------------
-------------
@@ -46,7 +46,7 @@
 						+ "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"
 						+ "\u205F\u2060\u2061\u2062\u2063\u206A\u206b\u206c\u206d"
 						+ "\u206E\u206F\u3000\u3164\ufeff\uffa0\ufff9\ufffa\ufffb"
-						+ ",.;()[]{}!?:\"'’‘„“”…\\/\t\n" + "-", true);
+						+ ",.;()[]{}!?:\"'’‘„“”…\\/\t\n«»" + "-", true);
 		while (st.hasMoreElements()) {
 			l.add(st.nextToken());
 		}
---------------
-------------
@@ -83,6 +83,7 @@
     for (int i = chunkStartPos; i < tokens.size(); i++) {
       ChunkTaggedToken token = tokens.get(i);
       if (false && "and".equals(token.getToken())) {   // e.g. "Tarzan and Jane" is a plural noun phrase
+        // TODO: "Additionally, there are over 500 college and university chapter."
         isPlural = true;
       } else if (hasNounWithPluralReading(token)) {   // e.g. "ten books" is a plural noun phrase
         isPlural = true;
---------------
-------------
@@ -59,7 +59,7 @@
       for (AnalyzedTokenReadings aToken : tokens) {
         final String token = aToken.getToken();
         pos += token.length();  // won't match the whole offending sentence, but much of it
-        if (!token.matches("[!-~’]") && !aToken.isSentenceStart()) {
+        if (!token.matches("[?!:;,~’-]") && !aToken.isSentenceStart()) {
           numWords++;
         }
       }
---------------
-------------
@@ -218,7 +218,7 @@
     int tmpLineOffset = 0;
     final List<String> unknownWords = new ArrayList<String>();
     StringBuilder sb = new StringBuilder();
-    for (int ruleIndex = 0; ruleIndex < runCount; ruleIndex++) {
+    for (int ruleIndex = 0; !rules.isEmpty() && ruleIndex < runCount; ruleIndex++) {
       currentRule = rules.get(ruleIndex);
       int matches = 0;
       long sentences = 0;
---------------
-------------
@@ -175,8 +175,8 @@
     
     s = s.replaceAll("(\\d+\\.) " + EOS + "([\\p{L}&&[^\\p{Lu}]]+)", "$1 $2");
 
-    // z.B. "Das hier ist ein(!) Satz."
-      s = s.replaceAll("\\(([!?]+)\\) " + EOS, "($1) ");
+    // np. "Uczeń napisał: "Szfecja (sic!) jest wielkim krajem".
+      s = s.replaceAll("\\(((sic)?[!?]+)\\) " + EOS, "($1) ");
     return s;
   } 
 
---------------
-------------
@@ -155,6 +155,7 @@
     "ihn",
     "dessen",
     "deren",
+    "denen",
     "sich",
     "unser",
     "aller",
---------------
-------------
@@ -457,7 +457,7 @@
     final StringBuilder filter = new StringBuilder();
     for (int i = 0; i < str.length(); i++) {
       final char c = str.charAt(i);
-      if (c != '\n' && c != ' ' && c != '\t') {
+      if (c != '\n' && c != ' ' && c != '\t' && c != '\r') {
         filter.append(c);
       }
     }
---------------
-------------
@@ -46,7 +46,7 @@
 						+ "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"
 						+ "\u205F\u2060\u2061\u2062\u2063\u206A\u206b\u206c\u206d"
 						+ "\u206E\u206F\u3000\u3164\ufeff\uffa0\ufff9\ufffa\ufffb"
-						+ ",.;()[]{}!?:\"'’‘„“”…\\/\t\n«»<>%" + "-", true);
+						+ ",.;()[]{}!?:\"'’‘„“”…\\/\t\n«»<>%°" + "-", true);
 		while (st.hasMoreElements()) {
 			l.add(st.nextToken());
 		}
---------------
-------------
@@ -209,7 +209,7 @@
   public void visit(XmlEntityRef er) {
     addMapping(er);
     if ("nbsp".equals(er.getName())) {
-      write(' ');
+      write('\u00A0');  // non-breaking space
     } else {
       String ch = StringEscapeUtils.unescapeHtml("&" + er.getName() + ";");
       write(ch);
---------------
-------------
@@ -193,6 +193,10 @@
       build("<chunk=NPS>+ <und> <chunk=NP[SP] & pos=GEN>+", NPS, true),
       // "Teil der dort ausgestellten Bestände":
       build("<chunk=NPS>+ <der> <pos=ADV> <pos=PA2> <NP>", NPS, true),
+      // "Autor der ersten beiden Bücher":
+      build("<chunk=NPS>+ <der> (<pos=ADJ>|<pos=ZAL>) <NP>", NPS, true),
+      // "Autor der beiden Bücher":
+      build("<chunk=NPS>+ <der> <NP>", NPS, true),
       // "Teil der umfangreichen dort ausgestellten Bestände":
       build("<chunk=NPS>+ <der> <pos=ADJ> <pos=ADV> <pos=PA2> <NP>", NPS, true),
       // "die Krankheit unserer heutigen Städte und Siedlungen":
---------------
-------------
@@ -66,7 +66,7 @@
 
   @Override
   public String[] getCountryVariants() {
-    return new String[]{"ANY"};
+    return new String[]{"ES"};
   }
   
   @Override
---------------
-------------
@@ -293,7 +293,7 @@
       if (currentTranslationLanguage == motherTongue) {
         translations.add(translation);
       }
-      if (currentTranslationLanguage == textLanguage) {
+      if (currentTranslationLanguage == textLanguage && language == motherTongue) {
         suggestions.add(translation.toString());
       }
       translation = new StringBuilder();
---------------
-------------
@@ -113,6 +113,8 @@
 
   private static final List<RegularExpressionWithPhraseType> REGEXES2 = Arrays.asList(
       // ===== plural and singular noun phrases, based on OpenNLP chunker output ===============
+      // "In christlichen, islamischen und jüdischen Traditionen":
+      build("<pos=ADJ> <,> <chunk=B-NP> <chunk=I-NP>* <und|sowie> <NP>", NPP),
       // "ein Hund und eine Katze":
       build("<chunk=B-NP & !regex=jede[rs]?> <chunk=I-NP>* <und|sowie> <NP>", NPP),
       // "größte und erfolgreichste Erfindung" (fixes mistagging introduced above):
---------------
-------------
@@ -88,7 +88,7 @@
           token = parts[0];
         }
         //html entities!
-        token = token.replaceAll("&quot|&amp|&lt|&gt|[^a-zA-Z0-9]", "");         // e.g. >>an "industry party"<<
+        token = token.replaceAll("&quot|&amp|&lt|&gt|[^a-zA-Z0-9\\.]", "");         // e.g. >>an "industry party"<<
         if (token.length() == 0) {
           continue;
         }
---------------
-------------
@@ -72,7 +72,7 @@
           suggestionText = ")";
           fixLen = 1;
     		} else if (prevToken.trim().equals(",") && !token.trim().equals("") &&
-    				!token.equals("'") && !token.equals("\"") && !token.matches(".*\\d.*")) {
+    				!token.equals("'") && !token.equals("\"") && !token.matches(".*\\d.*") && !token.equals("-")) {
     			msg = messages.getString("missing_space_after_comma");
           suggestionText = ", ";
     		} else if (token.trim().equals(",") && prevToken.trim().equals("")) {
---------------
-------------
@@ -82,7 +82,7 @@
       if (parts.length >= 1 && !parts[0].equalsIgnoreCase("a")) {  // avoid false alarm on "A-levels are..."
         token = parts[0];
       }
-      token = token.replaceAll("[^αa-zA-Z0-9\\.']", "");         // e.g. >>an "industry party"<<
+      token = token.replaceAll("[^αa-zA-Z0-9\\.;,:']", "");         // e.g. >>an "industry party"<<
       if (StringTools.isEmpty(token)) {
         continue;
       }
---------------
-------------
@@ -37,7 +37,7 @@
   private final static String EOS = "\0";
   // private final static String EOS = "#"; // for testing only
   private final static String P = "[\\.!?]"; // PUNCTUATION
-  private final static String AP = "(?:'|\"||\\)|\\]|\\})?"; // AFTER PUNCTUATION
+  private final static String AP = "(?:'|«|\"||\\)|\\]|\\})?"; // AFTER PUNCTUATION
   private final static String PAP = P + AP;
 
   // Check out the private methods for comments and examples about these
---------------
-------------
@@ -79,7 +79,7 @@
         if (parts.length >= 1) {
           token = parts[0];
         }
-        token = token.replaceAll("[^a-zA-Z]", "");         // e.g. >>an "industry party"<<
+        token = token.replaceAll("[^a-zA-Z0-9]", "");         // e.g. >>an "industry party"<<
         if (token.length() == 0)
           continue;
         char tokenFirstChar = token.charAt(0);
---------------
-------------
@@ -55,7 +55,7 @@
     public int evaluate(UUID e) {
         if (attrs.isSet(e, key)) {
             try {
-                return (Integer) attrs.get(e, key);
+                return attrs.getLong(e, key).intValue();
             } catch (Exception ex) {
                 return parent.evaluate(e);
             }
---------------
-------------
@@ -155,7 +155,7 @@
         if (!ret) {
             return false;
         }
-        if (cstr.isContinuous()) {
+        if (cstr.isContinuous() && cstr.isSatisfied(plan.getOrigin()).equals(SatConstraint.Sat.SATISFIED)) {
             Model m = plan.getOrigin().clone();
             for (Action a : plan) {
                 a.apply(m);
---------------
-------------
@@ -85,7 +85,7 @@
 
     @Override
     public int hashCode() {
-        return Objects.hash(getInvolvedNodes(), isContinuous());
+        return Objects.hash(getInvolvedVMs(), isContinuous());
     }
 
     @Override
---------------
-------------
@@ -88,6 +88,8 @@
         s.post(s.leq(hostingStart, rp.getEnd()));
         s.post(s.leq(hostingEnd, rp.getEnd()));
         s.post(s.leq(start, rp.getEnd()));
+
+        s.post(s.eq(duration, s.minus(end, start)));
         /**
          * If it is state to shutdown the node, then the duration of the dSlice is not null
          */
---------------
-------------
@@ -281,6 +281,7 @@
    public final void reset() {
       lastPercentage = -1;
       maxIteration.reset();
+      maxIteration.add(0l);
       accumulatedResults = new HashMap<>();
       doReset();
    }
---------------
-------------
@@ -187,7 +187,7 @@
       for (final Entry<String, Object> entry : results.entrySet()) {
          final String key = entry.getKey();
          final Object value = entry.getValue();
-         Accumulator accumulator = accumulatedResults.getIfAbsentWith(key, getAccumulatorFunction, entry);
+         Accumulator accumulator = accumulatedResults.getIfAbsentPutWith(key, getAccumulatorFunction, entry);
 
          if (accumulator != null) {
             accumulator.add(value);
---------------
-------------
@@ -70,7 +70,7 @@
       try {
          final boolean fileExists = queueFile.exists();
          file = new RandomAccessFile(queueFile.getAbsolutePath(), "rw");
-         if (fileExists) {
+         if (fileExists && file.length() > 0) {
             queueSize = file.readLong();
             pointer = file.readLong();
          } else {
---------------
-------------
@@ -193,7 +193,7 @@
 
     @Override
     public RpslObject getByKeyOrNull(final ObjectType type, final CIString key) {
-        return getByKey(type, key.toString());
+        return getByKeyOrNull(type, key.toString());
     }
 
     @Override
---------------
-------------
@@ -126,6 +126,7 @@
         }
         else {
             if (!sourceContext.getAdditionalSourceNames().isEmpty()) {
+                sources.add(sourceContext.getWhoisSlaveSource());
                 sources.addAll(Sets.newLinkedHashSet(Iterables.transform(sourceContext.getAdditionalSourceNames(), new Function<CIString, Source>() {
                     @Override
                     public Source apply(final CIString input) {
---------------
-------------
@@ -17,7 +17,7 @@
 public class ParagraphParser {
     private static final Pattern PASSWORD_PATTERN = Pattern.compile("(?im)^password:\\s*(.*)\\s*");
     private static final Pattern OVERRIDE_PATTERN = Pattern.compile("(?im)^override:\\s*(.*)\\s*");
-    private static final Pattern DRY_RUN_PATTERN = Pattern.compile("(?im)^dry-run:(.*)");
+    private static final Pattern DRY_RUN_PATTERN = Pattern.compile("(?im)^dry-run:(.*)\n*");
 
     private static final Splitter CONTENT_SPLITTER = Splitter.on(Pattern.compile("\\n[ \\t]*\\n")).omitEmptyStrings();
 
---------------
-------------
@@ -44,7 +44,7 @@
     }
 
     @Override
-    public boolean supports(Query query) {
+    public boolean supports(final Query query) {
         return false;
 //        return query.isObjectTimestampVersion();
     }
---------------
-------------
@@ -170,7 +170,6 @@
     public RpslObject lookup(final ObjectType objectType, final String pkey) {
         try {
             WebTarget webTarget = client.target(baseUrl)
-                .path(baseUrl)
                     .path(source)
                     .path(objectType.getName())
                     .path(pkey);
---------------
-------------
@@ -17,7 +17,7 @@
 public class ParagraphParser {
     private static final Pattern PASSWORD_PATTERN = Pattern.compile("(?im)^password:\\s*(.*)\\s*");
     private static final Pattern OVERRIDE_PATTERN = Pattern.compile("(?im)^override:\\s*(.*)\\s*");
-    private static final Pattern DRY_RUN_PATTERN = Pattern.compile("(?im)^dry-run:\\s*(.*)\\s*");
+    private static final Pattern DRY_RUN_PATTERN = Pattern.compile("(?im)^dry-run:(.*)");
 
     private static final Splitter CONTENT_SPLITTER = Splitter.on(Pattern.compile("\\n[ \\t]*\\n")).omitEmptyStrings();
 
---------------
-------------
@@ -279,7 +279,7 @@
             "must be a letter, and the last character of a name must be a\n" +
             "letter or a digit.\n");
 
-    AttributeSyntax NIC_HANDLE_SYNTAX = new AttributeSyntaxRegexp(30, Pattern.compile("(?i)^([A-Z]{2,4}([1-9][0-9]{0,5})?(-[A-Z]{2,6})?|AUTO-[1-9][0-9]*([A-Z]{2,4})?)$"), "" +
+    AttributeSyntax NIC_HANDLE_SYNTAX = new AttributeSyntaxRegexp(30, Pattern.compile("(?i)^([A-Z]{2,4}([1-9][0-9]{0,5})?(-[A-Z]{2,10})?|AUTO-[1-9][0-9]*([A-Z]{2,4})?)$"), "" +
             "From 2 to 4 characters optionally followed by up to 6 digits\n" +
             "optionally followed by a source specification.  The first digit\n" +
             "must not be \"0\".  Source specification starts with \"-\" followed\n" +
---------------
-------------
@@ -572,7 +572,7 @@
                 } catch(IOException exc){
                     log.error("IOException while reading record");
                     if (log.isDebugEnabled()) {
-                        log.debug(exc);
+                        log.debug("IOException while trying to read record number " + this.curIdx, exc);
                     }
                     throw new NoSuchElementException("Error getting next " +
                                                      "element: " +
---------------
-------------
@@ -29,6 +29,8 @@
 /**
  * Combines the information conveyed about a set of path prefixes to quickly
  * answer questions regarding an entire set of path prefixes.
+ * <p>
+ * Is effectively immutable and should not be modified after initial use.
  */
 public class PathPrefixSet {
   /*
---------------
-------------
@@ -130,7 +130,7 @@
     decPanel = new DecoratorPanel(rowStyles, 1);
     decPanel.setStyleName("");
     setStylePrimaryName(DEFAULT_STYLENAME);
-    setWidget(decPanel);
+    super.setWidget(decPanel);
     setStyleName(getContainerElement(), "popupContent", false);
     setStyleName(decPanel.getContainerElement(), prefix + "Content", true);
   }
---------------
-------------
@@ -1498,7 +1498,7 @@
             isCurrencyFormat = true;
             if ((pos + 1) < len && pattern.charAt(pos + 1) == CURRENCY_SIGN) {
               ++pos;
-              if (pos < len - 3 && pattern.charAt(pos + 1) == CURRENCY_SIGN
+              if (pos < len - 2 && pattern.charAt(pos + 1) == CURRENCY_SIGN
                   && pattern.charAt(pos + 2) == CURRENCY_SIGN) {
                 pos += 2;
                 affix.append(currencyData.getSimpleCurrencySymbol());
---------------
-------------
@@ -121,7 +121,7 @@
     Object[] result = a;
     Iterator<E> it = iterator();
     for (int i = 0; i < size; ++i) {
-      result[i++] = it.next();
+      result[i] = it.next();
     }
     if (a.length > size) {
       a[size] = null;
---------------
-------------
@@ -47,7 +47,6 @@
   private final File file;
 
   private FileResource(String abstractPathName, File file) {
-    assert (file.isFile()) : file + " is not a file.";
     this.abstractPathName = abstractPathName;
     this.file = file;
   }
---------------
-------------
@@ -116,7 +116,7 @@
     return this;
   }
 
-  public StringBuilder append(StringBuilder x) {
+  public StringBuilder append(StringBuffer x) {
     impl.append(data, x);
     return this;
   }
---------------
-------------
@@ -234,7 +234,8 @@
 
     @Override
     public String toString() {
-      return (isRed ? "R: " : "B: ") + key + "=" + value;
+      // for compatibility with the real Jre: issue 3422
+      return key + "=" + value;
     }
   }
 
---------------
-------------
@@ -218,7 +218,7 @@
   }
 
   public ListIterator<E> listIterator() {
-    return new ListIteratorImpl();
+    return listIterator(0);
   }
 
   public ListIterator<E> listIterator(int from) {
---------------
-------------
@@ -110,7 +110,8 @@
   }
 
   /**
-   * Returns the set of properties defined on this JSONObject.
+   * Returns the set of properties defined on this JSONObject. The returned set
+   * is immutable.
    */
   public Set<String> keySet() {
     final String[] keys = computeKeys();
---------------
-------------
@@ -74,7 +74,7 @@
 
     if (Double.isNaN(d)) {
       // IEEE754, NaN exponent bits all 1s, and mantissa is non-zero
-      return EXPONENT_MASK | NAN_MANTISSA;
+      return (1L << (EXPONENT_BITSIZE -1)) | NAN_MANTISSA;
     }
     if (Double.isInfinite(d)) {
       // an infinite number is a number with a zero mantissa and all
---------------
-------------
@@ -138,7 +138,7 @@
    * @return
    */
   public String getFormValue() {
-    return inputElem.getAttribute("value");
+    return inputElem.getValue();
   }
 
   @Override
---------------
-------------
@@ -58,7 +58,7 @@
 
   /**
    * A configuration property that can be used to have the linker load from
-   * somewhere other than {@link #FRAGMENT_SUBDIR}
+   * somewhere other than {@link #FRAGMENT_SUBDIR}.
    */
   private static final String PROP_FRAGMENT_SUBDIR_OVERRIDE = "iframe.linker.deferredjs.subdir";
 
---------------
-------------
@@ -215,7 +215,8 @@
 
   /**
    * This method may collapse adjacent text nodes into one text node, depending
-   * on the implementation.
+   * on the implementation. Safari 4.0 and Chrome will also merge CDATA nodes
+   * into text nodes, even though they support CDATA nodes as distinct nodes.
    */
   void normalize();
 
---------------
-------------
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) FuseSource, Inc.
  * http://fusesource.com
  *
---------------
-------------
@@ -179,7 +179,7 @@
 
             for (String key : getRestricted().keySet()) {
                 Type type = getRestricted().get(key);
-                if (type.getProvides() != null && !getEnums().containsKey(key)) {
+                if (type.getProvides() != null && !getEnums().containsKey(key) && !getDescribed().containsKey(key)) {
                     String className = getTypes() + "." + toJavaClassName(key);
                     restrictedTypes.add(new RestrictedType(this, className, type));
                 }
---------------
-------------
@@ -55,7 +55,7 @@
         String containerType = System.getProperty(CONTAINER_TYPE_PROPERTY, "child");
         int numberOfContainers = Math.max(minimumNumber, Integer.parseInt(System.getProperty(CONTAINER_NUMBER_PROPERTY, "1")));
 
-        if (maximumNumber < numberOfContainers) {
+        if (maximumNumber < numberOfContainers && maximumNumber != 0) {
             numberOfContainers = minimumNumber;
         }
 
---------------
-------------
@@ -109,7 +109,6 @@
         }
 
         bridgeConnector.setLocalBrokerConfig(createBrokerConfig(pid, "localBroker", properties));
-        bridgeConnector.setRemoteBrokerConfig(createBrokerConfig(pid, "remoteBroker", properties));
         bridgeConnector.setExportedBrokerConfig(createBrokerConfig(pid, "exportedBroker", properties));
 
 
---------------
-------------
@@ -396,6 +396,8 @@
                                   @Nullable InstanceRegionChecker instanceRegionChecker) {
         this.virtualHostNameAppMap.clear();
         this.secureVirtualHostNameAppMap.clear();
+        this.shuffleVirtualHostNameMap.clear();
+        this.shuffledSecureVirtualHostNameMap.clear();
         for (Application application : appNameApplicationMap.values()) {
             if (indexByRemoteRegions) {
                 application.shuffleAndStoreInstances(remoteRegionsRegistry, clientConfig, instanceRegionChecker);
---------------
-------------
@@ -396,6 +396,8 @@
                                   @Nullable InstanceRegionChecker instanceRegionChecker) {
         this.virtualHostNameAppMap.clear();
         this.secureVirtualHostNameAppMap.clear();
+        this.shuffleVirtualHostNameMap.clear();
+        this.shuffledSecureVirtualHostNameMap.clear();
         for (Application application : appNameApplicationMap.values()) {
             if (indexByRemoteRegions) {
                 application.shuffleAndStoreInstances(remoteRegionsRegistry, clientConfig, instanceRegionChecker);
---------------
-------------
@@ -156,7 +156,7 @@
 
   @Override
   public Page getAbsoluteParent(final int level) {
-    String parentPath = Text.getAbsoluteParent(this.resource.getPath(), level);
+    String parentPath = Text.getAbsoluteParent(this.resource.getPath(), level - 1);
     return getPage(parentPath);
   }
 
---------------
-------------
@@ -362,6 +362,6 @@
      */
     protected String[] getPrincipalsAndCredentials(String scheme, String encoded) {
         String decoded = Base64.decodeToString(encoded);
-        return decoded.split(":");
+        return decoded.split(":", 2);
     }
 }
---------------
-------------
@@ -35,7 +35,7 @@
 
     private final static Pattern TC_COMMAND_PATTERN = Pattern.compile("T(\\d+)C(\\d+.\\d+).*");
     private final static Pattern T_COMMAND_PATTERN = Pattern.compile("T(\\d+)");
-    private final static Pattern COORDINATES_PATTERN = Pattern.compile("X(\\d+)Y(\\d+)");
+    private final static Pattern COORDINATES_PATTERN = Pattern.compile("(?:G01)?X(\\d+)Y(\\d+)");
 
     private HashMap<Integer, RealNumber> tools = new HashMap<Integer, RealNumber>();
     private RealNumber currentDiameter;
---------------
-------------
@@ -36,7 +36,7 @@
 
     private final static Pattern TC_COMMAND_PATTERN = Pattern.compile("T(\\d+)C(\\d+.\\d+).*");
     private final static Pattern T_COMMAND_PATTERN = Pattern.compile("T(\\d+)");
-    private final static Pattern COORDINATES_PATTERN = Pattern.compile("(?:G01)?X(\\d+)Y(\\d+)");
+    private final static Pattern COORDINATES_PATTERN = Pattern.compile("(?:G01)?X(-?\\d+)Y(-?\\d+)");
     private final static Pattern MEASUREMENT_SYSTEM_PATTERN = Pattern.compile("(INCH|METRIC),(LZ|TZ)");
 
     private HashMap<Integer, RealNumber> tools = new HashMap<Integer, RealNumber>();
---------------
-------------
@@ -296,8 +296,6 @@
                 header.lastIndex.addAtomicValue(1);
                 writeByte.setValue(lastByte2);
                 bytes.writeOrderedInt(lastByte, (int) length);
-                long l = lastByte + 4 + wireLen + length;
-                bytes.skip(length30((int)l));
                 return firstByte;
             }
 
---------------
-------------
@@ -263,7 +263,7 @@
 
         long indexSize = 1L << 17L;
 
-        try (NativeBytesStore<Void> allocate = NativeBytesStore.nativeStore(6)) {
+        try (NativeBytesStore<Void> allocate = NativeBytesStore.nativeStoreWithFixedCapacity(6)) {
 
             final Bytes<Void> buffer = allocate.bytes();
 
---------------
-------------
@@ -192,7 +192,7 @@
         @Override
         public void run() {
             try {
-                long index = readIndex(socket);
+                long index = readIndex(socket) + 1; //Catch-up up to the first index that the remote sink doesn't have (last known remote index + 1)
                 ExcerptTailer excerpt = chronicle.createTailer();
                 ByteBuffer bb = TcpUtil.createBuffer(1, ByteOrder.nativeOrder()); // minimum size
                 long sendInSync = 0;
---------------
-------------
@@ -82,7 +82,7 @@
         if (a.getValue() != null) {
             action.addAttribute("value", a.getValue(), null);
         } else if (a.getXpath() != null) {
-            action.addAttribute("xpath", a.getValue(), null);
+            action.addAttribute("xpath", a.getXpath().toString(), null);
         }
 
         if (a.getRegex() != null) {
---------------
-------------
@@ -353,6 +353,7 @@
                         pattern.toString() + " with the property value :" + value;
                 synLog.traceOrDebug(msg);
             }
+            matchedValue = ""; //if not matched ideally should return empty string
         }
         
         return matchedValue;
---------------
-------------
@@ -73,6 +73,6 @@
         break;
       }
     }
-    return virtualFile == null ? null : new OpenFileHyperlinkInfo(myModule.getProject(), virtualFile, line);
+    return virtualFile == null ? null : new OpenFileHyperlinkInfo(myModule.getProject(), virtualFile, line - 1);
   }
 }
---------------
-------------
@@ -55,6 +55,6 @@
     @Override
     public boolean isValid(String value, ConstraintValidatorContext context) {
         JCUser user = service.getCurrentUser();
-        return user.isAnonymous() || !user.getUsername().equals(value);
+        return user.isAnonymous() || !user.getUsername().equalsIgnoreCase(value);
     }
 }
---------------
-------------
@@ -66,6 +66,7 @@
         deletedEntities
                 .addSynchronizedEntityClass(LastReadPost.class)
                 .setParameter("user", forWho.getId())
+                .setParameter("branch", branch.getId())
                 .setCacheable(false)
                 .executeUpdate();
 
---------------
-------------
@@ -130,7 +130,7 @@
             branch.clearLastPost();
         }
 
-        if (post.getLastTouchedDate().equals(topic.getModificationDate())) {
+        if (post.getCreationDate().equals(topic.getModificationDate())) {
             topic.recalculateModificationDate();
         }
 
---------------
-------------
@@ -86,7 +86,7 @@
 
     /**
      * Process avatar file from request and return avatar preview in response.
-     * Used for IE, Opera specific request processing
+     * Used for IE, Opera specific request processing.
      *
      * @param request incoming request
      * @return ResponseEntity
---------------
-------------
@@ -55,6 +55,6 @@
     @Override
     public boolean isValid(String value, ConstraintValidatorContext context) {
         JCUser user = service.getCurrentUser();
-        return user.isAnonymous() || !user.getUsername().equals(value);
+        return user.isAnonymous() || !user.getUsername().equalsIgnoreCase(value);
     }
 }
---------------
-------------
@@ -69,7 +69,7 @@
                         encoded.replaceFirst("<a.*href=\"", "<a href=\""));
             } else if(href.startsWith("<img")) {
                 decodedText = decodedText.replace(href,
-                        encoded.replaceFirst("<img.*src=\"", "<img class=\"thumbnail\" src=\""));
+                        encoded.replaceFirst("<img.*src=\"", "<img alt=\" \" class=\"thumbnail\" src=\""));
             }
         }
 
---------------
-------------
@@ -16,6 +16,7 @@
 
 import org.jtalks.jcommune.model.entity.Branch;
 import org.jtalks.jcommune.model.entity.JCUser;
+import org.jtalks.jcommune.model.entity.JCommuneProperty;
 import org.jtalks.jcommune.model.entity.Topic;
 import org.jtalks.jcommune.service.UserService;
 
---------------
-------------
@@ -77,7 +77,7 @@
                 .addObject(PAGE_DTO, new SamplePageDto(page));
     }
 
-    @RequestMapping(value = "/pages/{pagetId}/edit", method = RequestMethod.POST)
+    @RequestMapping(value = "/pages/{pageId}/edit", method = RequestMethod.POST)
     public ModelAndView update(@Valid @ModelAttribute SamplePageDto samplePageDto,
                                BindingResult result,
                                @PathVariable(PAGE_ID) Long pageId) throws NotFoundException {
---------------
-------------
@@ -58,7 +58,7 @@
      */
     @Override
     public Collection<JCUser> getNonActivatedUsers() {
-        return getSession().createQuery("from JCUser u where u.enabled = true")
+        return getSession().createQuery("from JCUser u where u.enabled = false")
                 .setCacheable(false)
                 .list();
     }
---------------
-------------
@@ -191,7 +191,6 @@
         Iterator<MultipartFile> fileIterator = fileCollection.iterator();
         MultipartFile file = fileIterator.next();
 
-
         try {
             avatarService.validateAvatarFormat(file);
             byte[] bytes = file.getBytes();
---------------
-------------
@@ -65,7 +65,7 @@
     public byte[] convertImageToByteArray(Image image) throws ImageProcessException {
 
         if (image == null) {
-            throw new ImageProcessException();
+            throw new IllegalArgumentException();
         }
 
         byte[] result;
---------------
-------------
@@ -98,7 +98,7 @@
         if (value != null) {
             DateTime time = (DateTime) value;
             DateTimeZone zone = time.getZone();
-            long utcTime = zone.convertLocalToUTC(time.getMillis(), true);
+            long utcTime = zone.convertLocalToUTC(time.getMillis(), false);
             time = new DateTime(utcTime + offset);
             super.setValue(time);
         } else {
---------------
-------------
@@ -216,6 +216,7 @@
         editedUser.setLanguage(editedUserProfileInfo.getLanguage());
         editedUser.setPageSize(editedUserProfileInfo.getPageSize());
         editedUser.setLocation(editedUserProfileInfo.getLocation());
+        editedUser.setAutosubscribe(editedUserProfileInfo.isAutosubscribe());
 
         this.getDao().saveOrUpdate(editedUser);
         LOGGER.info("Updated user profile. Username: {}", editedUser.getUsername());
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -162,9 +162,10 @@
      *            file descriptor pointing to a full snapshot of the
      *            application's data.  The application should consume every
      *            entity represented in this data stream.
-     * @param appVersionCode The
-     *            {@link android.R.styleable#AndroidManifest_versionCode android:versionCode}
-     *            value of the application that backed up this particular data set. This
+     * @param appVersionCode The value of the <a
+     * href="{@docRoot}guide/topics/manifest/manifest-element.html#vcode">{@code
+     *            android:versionCode}</a> manifest attribute,
+     *            from the application that backed up this particular data set. This
      *            makes it possible for an application's agent to distinguish among any
      *            possible older data versions when asked to perform the restore
      *            operation.
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -93,7 +93,7 @@
                     webView.addJavascriptInterface(object, name);
                     webView.getSettings().setJavaScriptEnabled(true);
                     webView.setWebViewClient(mWebViewClient);
-                    webView.loadData("<html><head></head><body></body></html>", "text/html", null);
+                    webView.loadData("<!DOCTYPE html><title></title>", "text/html", null);
                 }
             });
             mWebViewClient.waitForOnPageFinished();
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -23,7 +23,6 @@
 
     public static String[] children() {
         return new String[] {
-                StringTest.class.getName(),
                 HashMapPerformanceTest.class.getName(),
                 ArrayListPerformanceTest.class.getName(),
                 TreeMapPerformanceTest.class.getName(),
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -56,7 +56,7 @@
     static Pattern sAddressPattern = Pattern.compile(
             /* scheme    */ "(?:(http|https|file)\\:\\/\\/)?" +
             /* authority */ "(?:([-A-Za-z0-9$_.+!*'(),;?&=]+(?:\\:[-A-Za-z0-9$_.+!*'(),;?&=]+)?)@)?" +
-            /* host      */ "([-" + GOOD_IRI_CHAR + "%_]+(?:\\.[-" + GOOD_IRI_CHAR + "%_]+)*|\\[[0-9a-fA-F:\\.]+\\])?" +
+            /* host      */ "([" + GOOD_IRI_CHAR + "%_-][" + GOOD_IRI_CHAR + "%_\\.-]*|\\[[0-9a-fA-F:\\.]+\\])?" +
             /* port      */ "(?:\\:([0-9]*))?" +
             /* path      */ "(\\/?[^#]*)?" +
             /* anchor    */ ".*", Pattern.CASE_INSENSITIVE);
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -152,7 +152,13 @@
             concatRef.refNumber = refNumber;
             concatRef.seqNumber = i + 1;  // 1-based sequence
             concatRef.msgCount = msgCount;
-            concatRef.isEightBits = false;
+            // TODO: We currently set this to true since our messaging app will never
+            // send more than 255 parts (it converts the message to MMS well before that).
+            // However, we should support 3rd party messaging apps that might need 16-bit
+            // references
+            // Note:  It's not sufficient to just flip this bit to true; it will have
+            // ripple effects (several calculations assume 8-bit ref).
+            concatRef.isEightBits = true;
             SmsHeader smsHeader = new SmsHeader();
             smsHeader.concatRef = concatRef;
 
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -58,6 +58,7 @@
 		public static final String WIDGET = "widget"; //$NON-NLS-1$
 		public static final String RENDERER = "renderer"; //$NON-NLS-1$
 		public static final String TOBERENDERED = "toBeRendered"; //$NON-NLS-1$
+		public static final String ONTOP = "onTop"; //$NON-NLS-1$
 		public static final String VISIBLE = "visible"; //$NON-NLS-1$
 		public static final String PARENT = "parent"; //$NON-NLS-1$
 	}
---------------
-------------
@@ -101,7 +101,7 @@
             for (int i = 0; i < len; i++) {
                 Object item = Array.get(obj, i);
                 if (item == null) {
-                    descriptor.setProperty(i++, null);
+                    descriptor.setProperty(i, null);
                 } else {
                     JavaBeanDescriptor itemDescriptor = createDescriptorIfAbsent(item, accessor, cache);
                     descriptor.setProperty(i, itemDescriptor);
---------------
-------------
@@ -17,6 +17,7 @@
       Serializer<N> columnNameSerializer,
       ExecutionResult<Map<ByteBuffer, List<ColumnOrSuperColumn>>> executionResult, ColumnFamilyRowMapper mapper) {
     super(keySerializer, columnNameSerializer, executionResult);    
+    this.rowMapper = mapper;
   }
 
   @Override
---------------
-------------
@@ -109,9 +109,6 @@
     } catch (Exception e) {
       log.error("Discovery Service failed attempt to connect CassandraHost", e);
     }
-//    } finally {
-//      connectionManager.releaseClient(thriftClient);
-//    }
     return foundHosts;
   }
 
---------------
-------------
@@ -97,7 +97,7 @@
         cfDefList.add(new CfDef("TestKeyspace", "CustomIdColumnFamily").setComparator_type(BytesType.class.getSimpleName())
             .setKey_cache_size(0).setRow_cache_size(0).setGc_grace_seconds(86400));
       
-        Cluster cluster = HFactory.getOrCreateCluster("TestPool", "localhost:9170");
+        Cluster cluster = HFactory.getOrCreateCluster("TestPool", "localhost:9161");
         createKeyspace(cluster, "TestKeyspace", "org.apache.cassandra.locator.SimpleStrategy", 1, cfDefList);
         keyspace = HFactory.createKeyspace("TestKeyspace", cluster);
       }
---------------
-------------
@@ -186,7 +186,7 @@
         }
 
         /**
-         * If this value is true, the query returns a matching document once, even if more than one of the document’s location fields match
+         * If this value is true, the query returns a matching document once, even if more than one of the document's location fields match
          * the query. If this value is false, the query returns a document multiple times if the document has multiple matching location
          * fields. See $uniqueDocs for more information.
          *
---------------
-------------
@@ -37,7 +37,7 @@
 
     //FixMe: super-hacky
     if (val instanceof LazyBSONList || val instanceof ArrayList) {
-      return ReflectionUtils.convertToArray(double.class, (List<?>) val);
+      return ReflectionUtils.convertToArray(Double.class, (List<?>) val);
     }
 
     final String sVal = val.toString();
---------------
-------------
@@ -839,7 +839,7 @@
         } else if (mf.getMapper().getMappedClass(type) != null && mf.getMapper().getMappedClass(type).getMappedIdField() != null
                    && value.getClass().equals(mf.getMapper().getMappedClass(type).getMappedIdField().getConcreteType())) {
             return true;
-        } else if (!value.getClass().isAssignableFrom(type) && !value.getClass().getSimpleName().equalsIgnoreCase(type.getSimpleName())) {
+        } else if (!type.isInstance(value) && !value.getClass().getSimpleName().equalsIgnoreCase(type.getSimpleName())) {
             return false;
         }
         return true;
---------------
-------------
@@ -40,7 +40,7 @@
             @Override
             public void eval(final Object key, final Object val) {
                 final Object objKey = converters.decode(mf.getMapKeyClass(), key, mf);
-                values.put(objKey, val != null ? converters.decode(val.getClass(), val, mf) : null);
+                values.put(objKey, val != null ? converters.decode(mf.getSubClass(), val, mf) : null);
             }
         });
 
---------------
-------------
@@ -832,7 +832,7 @@
             return true;
         } else if (value.getClass().getAnnotation(Entity.class) != null && Key.class.equals(type)) {
             return true;
-        } else if (value.getClass().isAssignableFrom(Key.class) && type.equals(((Key) value).getKindClass())) {
+        } else if (Key.class.isInstance(value) && type.equals(((Key) value).getKindClass())) {
             return true;
         } else if (value instanceof List<?>) {
             return true;
---------------
-------------
@@ -108,7 +108,7 @@
 				if (dbObject.containsField(name)) {
 					BasicDBObject dbVal = (BasicDBObject) dbObject.get(name);
 					Object refObj = ReflectionUtils.createInstance(fieldType, dbVal);
-					refObj = mapper.fromDb(dbVal, refObj, null);
+					refObj = mapper.fromDb(dbVal, refObj, retrieved);
 					if (refObj != null) {
 						mf.setFieldValue(entity, refObj);
 					}
---------------
-------------
@@ -388,7 +388,7 @@
             try {
                 if (value instanceof Iterable) {
                     MappedClass mapped = getMappedClass(mf.getSubClass());
-                    if (mapped != null && Key.class.isAssignableFrom(mapped.getClazz())) {
+                    if (mapped != null && (Key.class.isAssignableFrom(mapped.getClazz()) || mapped.getEntityAnnotation() != null)) {
                         mappedValue = getDBRefs((Iterable) value);
                     } else {
                         mappedValue = toMongoObject(value, false);
---------------
-------------
@@ -391,7 +391,7 @@
                     if (mapped != null && Key.class.isAssignableFrom(mapped.getClazz())) {
                         mappedValue = getDBRefs((Iterable) value);
                     } else {
-                        mappedValue = value;
+                        mappedValue = toMongoObject(value, false);
                     }
                 } else {
                     final Key<?> key = (value instanceof Key) ? (Key<?>) value : getKey(value);
---------------
-------------
@@ -422,7 +422,7 @@
 
     b.rule(IDENTIFIER_NAME).is(
       SPACING,
-      b.regexp(EcmaScriptLexer.IDENTIFIER)).skip();
+      b.regexp(EcmaScriptLexer.IDENTIFIER));
 
     lexical(b);
     expressions(b);
---------------
-------------
@@ -1,4 +1,5 @@
-package org.sonar.javascript.checks;/*
+package org.sonar.javascript.checks;
+/*
  * SonarQube JavaScript Plugin
  * Copyright (C) 2011 SonarSource and Eriks Nukis
  * dev@sonar.codehaus.org
---------------
-------------
@@ -86,7 +86,7 @@
   }
 
   private boolean isElseIf(AstNode astNode) {
-    return astNode.getParent().getPreviousSibling() != null
+    return astNode.is(Kind.IF_STATEMENT) && astNode.getParent().getPreviousSibling() != null
       && astNode.getParent().getPreviousSibling().is(EcmaScriptKeyword.ELSE);
   }
 
---------------
-------------
@@ -1004,7 +1004,7 @@
   }
 
   /**
-   * Add a command object.
+   * Add a command object and its aliases.
    */
   public void addCommand(String name, Object object, String... aliases) {
     JCommander jc = new JCommander(object);
---------------
-------------
@@ -1172,7 +1172,7 @@
         current += word.length() + 1;
       } else {
         out.append("\n").append(s(indent + 1)).append(word);
-        current = indent;
+        current = indent + 1 + word.length();
       }
       i++;
     }
---------------
-------------
@@ -287,7 +287,6 @@
      * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, Date value) {
-        
         long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
         this.query.equalTo(columnIndices, value);
         return this;
---------------
-------------
@@ -246,7 +246,7 @@
     public Date maxDate(String fieldName) {
         long columnIndex = table.getColumnIndex(fieldName);
         if (table.getColumnType(columnIndex) == ColumnType.DATE) {
-            return table.minimumDate(columnIndex);
+            return table.maximumDate(columnIndex);
         }
         else {
             throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "Date"));
---------------
-------------
@@ -369,9 +369,6 @@
 
     protected native void nativeRemoveLast(long nativeTablePtr);
 
-    /**
-     *  EXPERIMENTAL function
-     */
     public void moveLastOver(long rowIndex) {
         checkImmutable();
         nativeMoveLastOver(nativePtr, rowIndex);
---------------
-------------
@@ -504,7 +504,7 @@
         Realm realm = realms.get(absolutePath.hashCode());
 
         if (realm != null) {
-            if (realm.key != key) {
+            if (!Arrays.equals(realm.key, key)) {
                 throw new IllegalStateException(DIFFERENT_KEY_MESSAGE);
             }
             localRefCount.put(id, references + 1);
---------------
-------------
@@ -369,9 +369,6 @@
 
     protected native void nativeRemoveLast(long nativeTablePtr);
 
-    /**
-     *  EXPERIMENTAL function
-     */
     public void moveLastOver(long rowIndex) {
         checkImmutable();
         nativeMoveLastOver(nativePtr, rowIndex);
---------------
-------------
@@ -363,6 +363,8 @@
             realm = new Realm(absolutePath, key, autoRefresh);
             realms.put(absolutePath, realm);
             realmsCache.set(realms);
+        } else {
+            return realm;
         }
         if (validateSchema) {
             Class<?> validationClass;
---------------
-------------
@@ -453,7 +453,7 @@
             simpleClassName = clazz.getSimpleName();
             simpleClassNames.put(clazz, simpleClassName);
         }
-        return transaction.hasTable(simpleClassName);
+        return transaction.hasTable(TABLE_PREFIX+simpleClassName);
     }
 
     /**
---------------
-------------
@@ -55,7 +55,7 @@
 
     // test:
     protected int tableNo;
-    protected boolean DEBUG = true;
+    protected boolean DEBUG = false;
     protected static int TableCount = 0;
 
     static {
---------------
-------------
@@ -364,9 +364,6 @@
 
     protected native void nativeRemoveLast(long nativeTablePtr);
 
-    /**
-     *  EXPERIMENTAL function
-     */
     public void moveLastOver(long rowIndex) {
         checkImmutable();
         nativeMoveLastOver(nativePtr, rowIndex);
---------------
-------------
@@ -365,7 +365,7 @@
 
     private static Realm createAndValidate(String absolutePath, byte[] key, boolean validateSchema, boolean autoRefresh) {
         Map<Integer, Realm> realms = realmsCache.get();
-        Realm realm = realms.get(absolutePath);
+        Realm realm = realms.get(absolutePath.hashCode());
 
         if (realm != null) {
             return realm;
---------------
-------------
@@ -108,7 +108,7 @@
         Long lowestUnAckedTag = (pendingTags.isEmpty()) ? null : pendingTags.first();
         long ackUntil = (lowestUnAckedTag != null) ? lowestUnAckedTag - 1 : highestDeliveredTag;
         // don't ack 0 as it will ack all pending messages!!!
-        if(ackUntil > 0) {
+        if(ackUntil > 0 && ackUntil > lastAckedTag) {
             try {
                 consumerChannel.basicAck(ackUntil,true);
                 if(logger.isInfoEnabled()) {
---------------
-------------
@@ -197,6 +197,7 @@
 					int extensionCode = dis.readUnsignedByte();
 					if(extensionCode == 0x10 || extensionCode == 0x11 || extensionCode == 0x13) {
 						// Alternate thumbnail, perfectly valid
+						dos.write(extensionCode);
 						skipRest(blockLength, countAtStart, cis, dis, dos, "thumbnail frame");
 						Logger.minor(this, "Thumbnail frame");
 					} else
---------------
-------------
@@ -101,7 +101,7 @@
 		}
 		
 		/** A blocking method to force-migrate from a RAMBucket to a FileBucket */
-		private final void migrateToFileBucket() throws IOException {
+		public final void migrateToFileBucket() throws IOException {
 			Bucket toMigrate = null;
 			synchronized(this) {
 				if(!isRAMBucket() || hasBeenFreed)
---------------
-------------
@@ -49,6 +49,7 @@
                     // Ignore.
                 }
             }
+            waiting--;
         }
     }
     
---------------
-------------
@@ -3513,7 +3513,7 @@
 				if(s == null) throw new NullPointerException(); 
 			}
 			if(fontWords.size() == 1) {
-				if(ElementInfo.isGenericFontFamily(fontWords.get(0)))
+				if(ElementInfo.isGenericFontFamily(fontWords.get(0).toLowerCase()))
 					return true;
 			}
 			StringBuffer sb = new StringBuffer();
---------------
-------------
@@ -24,7 +24,7 @@
 	public static final String protocolVersion = "1.0";
 
 	/** The build number of the current revision */
-	private static final int buildNumber = 1166
+	private static final int buildNumber = 1167;
 
 	/** Oldest build of Fred we will talk to */
 	private static final int oldLastGoodBuild = 1165;
---------------
-------------
@@ -55,7 +55,8 @@
    */
   public static long getMaxVisibleTimestamp(Transaction tx) {
     // NOTE: +1 here because we want read up to writepointer inclusive, but timerange's end is exclusive
-    return tx.getWritePointer() + 1;
+    // however, we also need to guard against overflow in the case write pointer is set to MAX_VALUE
+    return tx.getWritePointer() < Long.MAX_VALUE ? tx.getWritePointer() + 1 : tx.getWritePointer();
   }
 
   /**
---------------
-------------
@@ -2401,7 +2401,7 @@
     private static void initPlayer() throws IOException, InterruptedException {
         if (playerABCs.isEmpty()) {
             if (Configuration.getPlayerSWC() == null) {
-                throw new IOException("Player SWC library not found, please place it to " + Configuration.getPlayerSWC());
+                throw new IOException("Player SWC library not found, please place it to " + Configuration.getFlashLibPath());
             }
             SWC swc = new SWC(new FileInputStream(Configuration.getPlayerSWC()));
             SWF swf = new SWF(swc.getSWF("library.swf"), true);
---------------
-------------
@@ -21,7 +21,7 @@
 /**
  * Character iterator that is backed by a {@link java.lang.CharSequence}.
  */
-public class CharSequenceCharacterIterator implements CharacterIterator {
+public final class CharSequenceCharacterIterator implements CharacterIterator {
     private CharSequence charSequence;
     private int beginIndex;
     private int endIndex;
---------------
-------------
@@ -97,7 +97,7 @@
     public void setUp(){
         data = new FakeSubsetData(scores);
         obj = new FakeSubsetObjectiveWithData();
-        problem = new SubsetProblemWithData(obj, data, SUBSET_SIZE);
+        problem = new SubsetProblemWithData<>(obj, data, SUBSET_SIZE);
         constraint = new FakeSubsetPenalizingConstraint(MIN_SCORE_DIFF);
         neigh = new SingleSwapNeighbourhood();
     }
---------------
-------------
@@ -69,7 +69,7 @@
                 concept.setSubtitleFormula(getSubtitleFormula());
             }
             if (getTimeFormula() != null) {
-                concept.setTitleFormula(getTimeFormula());
+                concept.setTimeFormula(getTimeFormula());
             }
             if (getParentConceptIRI() != null) {
                 concept.setParentConcept(getParentConceptIRI());
---------------
-------------
@@ -43,7 +43,7 @@
         LoopingIterator propertyVizIterator = new LoopingIterator(propertyVisibilities);
         List<String> vertexIds = new ArrayList<>();
         for (int i = 0; i < numVertices; i++) {
-            ClientApiElement vertex = setupVertexApi.create(CONCEPT_TEST_PERSON, (String) vertexVizIterator.next());
+            ClientApiElement vertex = setupVertexApi.create(TestOntology.CONCEPT_PERSON, (String) vertexVizIterator.next());
             String vertexId = vertex.getId();
             setVertexProperties(numPropertiesPerVertex, propertyVizIterator, vertexId);
             vertexIds.add(vertexId);
---------------
-------------
@@ -83,7 +83,7 @@
             transaction = session.beginTransaction();
             newUser = new SqlUser();
             newUser.setDisplayName(displayName);
-            if (password != null) {
+            if (password != null && !password.equals("")) {
                 byte[] salt = UserPasswordUtil.getSalt();
                 byte[] passwordHash = UserPasswordUtil.hashPassword(password, salt);
                 newUser.setPasswordSalt(salt);
---------------
-------------
@@ -55,6 +55,7 @@
     public void handle(TraceStart traceStart) {
         traceCount++;
         expectedNumberOfFrames = traceStart.getNumberOfFrames();
+        reversalStack.clear();
         currentThread = traceStart.getThreadId();
         currentTreeNode = null;
     }
---------------
-------------
@@ -60,6 +60,7 @@
     suite.addTestSuite(ErlangIntroduceFunctionFixTest.class);
     suite.addTestSuite(ErlangIntroduceVariableFixTest.class);
     suite.addTestSuite(ErlangIntroduceRecordFixTest.class);
+    suite.addTestSuite(ErlangIntroduceRecordFieldTest.class);
     suite.addTestSuite(ErlangSmartEnterClauseProcessorTest.class);
     suite.addTestSuite(ErlangSdkReleaseTest.class);
     suite.addTestSuite(ErlangBehaviourInspectionsTest.class);
---------------
-------------
@@ -85,7 +85,7 @@
       .around(ERL_OP_GT_EQ).spaceIf(settings.SPACE_AROUND_LOGICAL_OPERATORS)
       .around(ERL_OR_OR).spaceIf(settings.SPACE_AROUND_LOGICAL_OPERATORS)
       .around(ERL_OR).spaceIf(settings.SPACE_AROUND_LOGICAL_OPERATORS)
-
+      .around(ERL_ANDALSO).spaceIf(settings.SPACE_AROUND_LOGICAL_OPERATORS)
 
       .after(ERL_BRACKET_LEFT).none()
       .before(ERL_BRACKET_RIGHT).none()
---------------
-------------
@@ -101,6 +101,7 @@
                   }
                 }
                 else {
+                  if (args instanceof ErlangMaxExpression && ((ErlangMaxExpression) args).getQVar() != null) return;
                   problemsHolder.registerProblem(args, "Format arguments not a list");
                 }
               }
---------------
-------------
@@ -82,6 +82,7 @@
     suite.addTestSuite(ErlangIntroduceRecordFieldTest.class);
     suite.addTestSuite(ErlangIntroduceMacroQuickFixTest.class);
     suite.addTestSuite(ErlangIntroduceVariableTest.class);
+    suite.addTestSuite(ErlangFindIncludeQuickFixTest.class);
     suite.addTestSuite(ErlangExtractFunctionTest.class);
     suite.addTestSuite(ErlangSafeDeleteTest.class);
     suite.addTestSuite(ErlangSmartEnterClauseProcessorTest.class);
---------------
-------------
@@ -59,6 +59,7 @@
     suite.addTestSuite(ErlangHeadMismatchFixTest.class);
     suite.addTestSuite(ErlangIntroduceFunctionFixTest.class);
     suite.addTestSuite(ErlangIntroduceVariableFixTest.class);
+    suite.addTestSuite(ErlangIntroduceRecordFixTest.class);
     suite.addTestSuite(ErlangSmartEnterClauseProcessorTest.class);
     suite.addTestSuite(ErlangSdkReleaseTest.class);
     suite.addTestSuite(ErlangBehaviourInspectionsTest.class);
---------------
-------------
@@ -125,6 +125,7 @@
       .aroundInside(ERL_OP_AR_DIV, ERL_FUN_TYPE_SIGS).none()
       .aroundInside(ERL_OP_AR_DIV, ERL_EXPORT_FUNCTION).none()
       .aroundInside(ERL_OP_AR_DIV, ERL_EXPORT_TYPE).none()
+      .aroundInside(ERL_OP_AR_DIV, ERL_FUNCTION_WITH_ARITY).none()
 
       .aroundInside(ERL_COLON_COLON, ERL_FUN_TYPE_SIGS).spaces(1)
       .betweenInside(ERL_COLON_COLON, ERL_TYPE_SIG, ERL_FUN_TYPE_SIGS).spaces(1)
---------------
-------------
@@ -54,7 +54,8 @@
         (PsiTreeUtil.isAncestor(clause, psiElement, false) && (inDefinition(psiElement) || inAssignment(psiElement)))
         || isInModule(psiElement)
         || PsiTreeUtil.isAncestor(spec, psiElement, false)) {
-        if (inArgumentList(psiElement)) return true;
+        //noinspection unchecked
+        if (inArgumentList(psiElement) && PsiTreeUtil.getParentOfType(psiElement, ErlangArgumentList.class, ErlangAssignmentExpression.class) instanceof ErlangArgumentList) return true;
 
         myVarList.add(0, (ErlangQVar) psiElement); // put all possible variables to list
         return true;
---------------
-------------
@@ -99,7 +99,7 @@
             } catch (Exception e) {
                 depth = 0;
             }
-            md.setValue(depthKeyName, Integer.toString(depth++));
+            md.setValue(depthKeyName, Integer.toString(++depth));
         }
 
         return md;
---------------
-------------
@@ -428,7 +428,7 @@
           // Protocols can't be used in typedefs.
           printf("\n#define %s %s\n", unprefixedName, typeName);
         } else {
-          printf("\ntypedef %s %s;\n", typeName, unprefixedName);
+          printf("\n@compatibility_alias %s %s;\n", unprefixedName, typeName);
         }
       }
     }
---------------
-------------
@@ -600,7 +600,7 @@
           if (l == Long.MIN_VALUE) {
             println("((long long) 0x8000000000000000LL)");
           } else {
-            println(value.toString());
+            println(value.toString() + "LL");
           }
         } else if (value instanceof Integer) {
           long l = ((Integer) value).intValue();
---------------
-------------
@@ -65,7 +65,7 @@
   public static String createFieldTypeSignature(IVariableBinding variable) {
     ITypeBinding type = variable.getType();
     if (type.isArray()) {
-      if (!type.getElementType().isTypeVariable()) {
+      if (!type.getElementType().isTypeVariable() && !type.getElementType().isParameterizedType()) {
         return null;
       }
     } else if (!type.isTypeVariable() && !type.isParameterizedType()) {
---------------
-------------
@@ -920,7 +920,7 @@
         return -1;
     }
     int rc =
-      TEMP_FAILURE_RETRY(pwrite64([fd getInt$], bytes + bufferOffset, byteCount, offset));
+      TEMP_FAILURE_RETRY(pread64([fd getInt$], bytes + bufferOffset, byteCount, offset));
     return LibcoreIoPosix_throwIfMinusOneWithNSString_withInt_(@"pread", rc);
   ]-*/;
 
---------------
-------------
@@ -967,7 +967,6 @@
 
   private native int readBytes(FileDescriptor fd, Object buffer, int offset, int byteCount)
       throws ErrnoException /*-[
-    IOSArray_checkRange([(IOSArray *)buffer length], offset, byteCount);
     char *bytes = BytesRW(buffer);
     if (!bytes) {
       return -1;
---------------
-------------
@@ -336,7 +336,7 @@
 
   public static String javaTypeToObjC(ITypeBinding binding, boolean includeInterfaces) {
     if (binding.isInterface() && !includeInterfaces || binding == Types.resolveIOSType("id") ||
-        binding == Types.resolveIOSType("NSObject")) {
+        binding == Types.resolveIOSType("NSObject") || Types.isJavaObjectType(binding)) {
       return NameTable.ID_TYPE;
     }
     if (binding.isTypeVariable()) {
---------------
-------------
@@ -150,7 +150,7 @@
   private String methodKey(IMethodBinding method) {
     StringBuilder sb = new StringBuilder();
     if (method.isConstructor()) {
-      sb.append(NameTable.getFullName(method.getDeclaringClass()));
+      sb.append("init");
     } else {
       sb.append(NameTable.getName(method));
     }
---------------
-------------
@@ -192,7 +192,7 @@
      * @return the arc tangent of {@code y/x}.
      */
     public static native double atan2(double y, double x) /*-[
-      return atan2(x, y);
+      return atan2(y, x);
     ]-*/;
 
     /**
---------------
-------------
@@ -130,7 +130,7 @@
             File commandsFile = findConfigFile(configFile);
             if (commandsFile != null) {
                 try {
-                    preProcessedCommands.load(new FileInputStream(commandsFile));
+                    loadFromFile(preProcessedCommands, commandsFile);
                 } catch (FileNotFoundException fnfex) {
                     // in case of a file within a jar in classpath, try to open stream using url
                     InputStream stream = PropertiesUtil.openStreamFromURL(configFile);
---------------
-------------
@@ -45,7 +45,7 @@
     VersionDao _dao;
     public DatabaseUpgradeChecker() {
         _dao = ComponentLocator.inject(VersionDaoImpl.class);
-        _upgradeMap.put(new Pair<String, String>("2.1.7", "2.2.3"), new DbUpgrade[] { new Upgrade217to22(), new UpgradeSnapshot217to223()});
+        _upgradeMap.put(new Pair<String, String>("2.1.7", "2.2.3"), new DbUpgrade[] { new Upgrade217to22(), new Upgrade221to222(), new UpgradeSnapshot217to223()});
     }
     
     protected void runScript(File file) {
---------------
-------------
@@ -951,7 +951,7 @@
             if (_listenAddr != null) {
                 graphicBuilder.append(" listen='" + _listenAddr + "'");
             } else {
-                graphicBuilder.append(" listen='' ");
+                graphicBuilder.append(" listen=''");
             }
             if (_passwd != null) {
                 graphicBuilder.append(" passwd='" + _passwd + "'");
---------------
-------------
@@ -86,7 +86,7 @@
         return avgSummary;
     }
 
-    private double getStatAverage(SearchResponse response) {
+    private Double getStatAverage(SearchResponse response) {
         double average = ((InternalAvg) response.getAggregations().asMap().get("counter_average")).value();
         return (average >= 0.0 ? average : null);
     }
---------------
-------------
@@ -50,7 +50,7 @@
 				finputstream.close();
 				dir = props.getProperty("paths.pid");
 				if (dir == null) {
-					dir = "/var/run";
+					dir = pidDir==null?"/var/run":pidDir;
 				}
 			}
 		} catch (IOException e) {
---------------
-------------
@@ -152,7 +152,7 @@
             throw new ConfigurationException("There is no upgrade path from " + dbVersion + " to " + currentVersion);
         }
 
-        if (Version.compare(currentVersion, upgrades[upgrades.length - 1].getUpgradedVersion()) == 0) {
+        if (Version.compare(currentVersion, upgrades[upgrades.length - 1].getUpgradedVersion()) != 0) {
             throw new ConfigurationException("The end upgrade version is actually at " + upgrades[upgrades.length - 1].getUpgradedVersion() + " but our management server code version is at " + currentVersion);
         }
         
---------------
-------------
@@ -4096,7 +4096,7 @@
             needRestart = true;
         }
 
-        List<VolumeVO> rootVols = _volsDao.findByInstance(vmId);
+        List<VolumeVO> rootVols = _volsDao.findByInstanceAndType(vmId, Volume.Type.ROOT);
         if (rootVols.isEmpty()) {
             InvalidParameterValueException ex = new InvalidParameterValueException(
                     "Can not find root volume for VM " + vm.getUuid());
---------------
-------------
@@ -63,7 +63,7 @@
 @Local(value = {NetworkElement.class, FirewallServiceProvider.class, 
         DhcpServiceProvider.class, UserDataServiceProvider.class, 
         StaticNatServiceProvider.class, LoadBalancingServiceProvider.class,
-        PortForwardingServiceProvider.class, IpDeployer.class,
+        PortForwardingServiceProvider.class, IpDeployer.class, VpcProvider.class,
         Site2SiteVpnServiceProvider.class, NetworkACLServiceProvider.class})
 public class VpcVirtualRouterElement extends VirtualRouterElement implements VpcProvider, Site2SiteVpnServiceProvider, NetworkACLServiceProvider{
     private static final Logger s_logger = Logger.getLogger(VpcVirtualRouterElement.class);
---------------
-------------
@@ -200,7 +200,7 @@
 	@Override
 	public boolean isLocalNode(String nodeId) {
 		// TODO Auto-generated method stub
-		return false;
+		return true;
 	}
 
 	@Override
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -162,9 +162,10 @@
      *            file descriptor pointing to a full snapshot of the
      *            application's data.  The application should consume every
      *            entity represented in this data stream.
-     * @param appVersionCode The
-     *            {@link android.R.styleable#AndroidManifest_versionCode android:versionCode}
-     *            value of the application that backed up this particular data set. This
+     * @param appVersionCode The value of the <a
+     * href="{@docRoot}guide/topics/manifest/manifest-element.html#vcode">{@code
+     *            android:versionCode}</a> manifest attribute,
+     *            from the application that backed up this particular data set. This
      *            makes it possible for an application's agent to distinguish among any
      *            possible older data versions when asked to perform the restore
      *            operation.
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -93,7 +93,7 @@
                     webView.addJavascriptInterface(object, name);
                     webView.getSettings().setJavaScriptEnabled(true);
                     webView.setWebViewClient(mWebViewClient);
-                    webView.loadData("<html><head></head><body></body></html>", "text/html", null);
+                    webView.loadData("<!DOCTYPE html><title></title>", "text/html", null);
                 }
             });
             mWebViewClient.waitForOnPageFinished();
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -23,7 +23,6 @@
 
     public static String[] children() {
         return new String[] {
-                StringTest.class.getName(),
                 HashMapPerformanceTest.class.getName(),
                 ArrayListPerformanceTest.class.getName(),
                 TreeMapPerformanceTest.class.getName(),
---------------
-------------
@@ -520,7 +520,7 @@
      * @param length required length of the string
      * @return
      */
-    protected boolean isHex(String input, int length) {
+    protected static boolean isHex(String input, int length) {
         Pattern p = Pattern.compile(String.format("[0-9A-Fa-f]{%d}", length));
         return p.matcher(input).matches();
     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -56,7 +56,7 @@
     static Pattern sAddressPattern = Pattern.compile(
             /* scheme    */ "(?:(http|https|file)\\:\\/\\/)?" +
             /* authority */ "(?:([-A-Za-z0-9$_.+!*'(),;?&=]+(?:\\:[-A-Za-z0-9$_.+!*'(),;?&=]+)?)@)?" +
-            /* host      */ "([-" + GOOD_IRI_CHAR + "%_]+(?:\\.[-" + GOOD_IRI_CHAR + "%_]+)*|\\[[0-9a-fA-F:\\.]+\\])?" +
+            /* host      */ "([" + GOOD_IRI_CHAR + "%_-][" + GOOD_IRI_CHAR + "%_\\.-]*|\\[[0-9a-fA-F:\\.]+\\])?" +
             /* port      */ "(?:\\:([0-9]*))?" +
             /* path      */ "(\\/?[^#]*)?" +
             /* anchor    */ ".*", Pattern.CASE_INSENSITIVE);
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -1567,6 +1567,14 @@
         // that has been collected.
         if (util.isValidNumber(pn)) {
           return false;
+        } else if ("BR".equalsIgnoreCase(defaultCountryIso) && number.length() >= 8) {
+          // This is to prevent Brazilian local numbers which start with 911 being incorrectly
+          // classified as emergency numbers. 911 is not an emergency number in Brazil; it is also
+          // not possible to append additional digits to an emergency number to dial the number in
+          // Brazil - it won't connect.
+          // TODO: Clean this up once a list of country-specific known emergency numbers is
+          // collected.
+          return false;
         }
       } catch (NumberParseException e) {
       }
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -18,7 +18,6 @@
 import android.app.DownloadManager;
 import android.app.DownloadManager.Query;
 import android.app.DownloadManager.Request;
-import android.app.DownloadManagerBaseTest;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
---------------
-------------
@@ -152,7 +152,13 @@
             concatRef.refNumber = refNumber;
             concatRef.seqNumber = i + 1;  // 1-based sequence
             concatRef.msgCount = msgCount;
-            concatRef.isEightBits = false;
+            // TODO: We currently set this to true since our messaging app will never
+            // send more than 255 parts (it converts the message to MMS well before that).
+            // However, we should support 3rd party messaging apps that might need 16-bit
+            // references
+            // Note:  It's not sufficient to just flip this bit to true; it will have
+            // ripple effects (several calculations assume 8-bit ref).
+            concatRef.isEightBits = true;
             SmsHeader smsHeader = new SmsHeader();
             smsHeader.concatRef = concatRef;
 
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -48,7 +48,7 @@
   
     public static final long PAUSE_WAIT_TIME = 3000;
     public static final long WAIT_TIME = 2000;
-    public static final long WAIT_LONG = 4000;
+    public static final long WAIT_SNAPSHOT_TIME = 5000;
   
     //Streaming Video
     public static final String VIDEO_HTTP3GP = "http://pvs.pv.com/jj/lipsync0.3gp";  
---------------
-------------
@@ -1890,7 +1890,7 @@
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden && f.mUserVisibleHint) {
+                if (f != null && !f.mHidden) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -1598,6 +1598,8 @@
                     end = query.length();
                 }
                 return decode(query.substring(equalsIndex + 1, end));
+            } else {
+                encodedKeySearchIndex = equalsIndex + 1;
             }
         }
         return null;
---------------
-------------
@@ -243,7 +243,7 @@
      */
     public long getmtime(String key) {
         try {
-            return mBinder.getmtime(key);
+            return mBinder.getmtime(key) * 1000L;
         } catch (RemoteException e) {
             Log.w(TAG, "Cannot connect to keystore", e);
             return -1L;
---------------
-------------
@@ -353,7 +353,7 @@
       addressPart = this.getAddress();
     }
 
-    if (null != this.getName() && this.getName().isEmpty()) {
+    if (null != this.getName() && !this.getName().isEmpty()) {
       return this.getName() + " <" + addressPart + ">";
     } else {
       return addressPart;
---------------
-------------
@@ -197,7 +197,7 @@
         new OutParam<ExtendedProperty>();
     if (this.tryGetProperty(propertyDefinition, extendedPropertyOut)) {
       extendedProperty = extendedPropertyOut.getParam();
-      if (cls.isAssignableFrom(propertyDefinition.getType())) {
+      if (!cls.isAssignableFrom(propertyDefinition.getType())) {
         String errorMessage = String.format(
             "Property definition type '%s' and type parameter '%s' aren't compatible.",
             propertyDefinition.getType().getSimpleName(),
---------------
-------------
@@ -353,7 +353,7 @@
       addressPart = this.getAddress();
     }
 
-    if (null != this.getName() && this.getName().isEmpty()) {
+    if (null != this.getName() && !this.getName().isEmpty()) {
       return this.getName() + " <" + addressPart + ">";
     } else {
       return addressPart;
---------------
-------------
@@ -124,7 +124,7 @@
     }
 
     public Path getChunkPath(Vector3i chunkPos) {
-        return worldsPath.resolve(getChunkFilename(chunkPos));
+        return worldPath.resolve(getChunkFilename(chunkPos));
     }
 
     public Path getChunkTempPath(Vector3i chunkPos) {
---------------
-------------
@@ -942,6 +942,7 @@
 
     protected Long requestQueueDepth(AMQDestination amqd)
     {
+        flushAcknowledgments();
         return getQpidSession().queueQuery(amqd.getQueueName()).get().getMessageCount();
     }
 
---------------
-------------
@@ -60,7 +60,7 @@
     /**
      * Priority of messages created by this producer.
      */
-    private int _messagePriority;
+    private int _messagePriority = Message.DEFAULT_PRIORITY;
 
     /**
      * Time to live of messages. Specified in milliseconds but AMQ has 1 second resolution.
---------------
-------------
@@ -140,7 +140,7 @@
         {
             try
             {
-                ConnectionURL connectionDetails = new AMQConnectionURL(_connectionDetails.toString());
+                ConnectionURL connectionDetails = new AMQConnectionURL(_connectionDetails.getURL());
                 connectionDetails.setUsername(userName);
                 connectionDetails.setPassword(password);
                 
---------------
-------------
@@ -93,7 +93,7 @@
                                  "Consuming to slow.");
 
             // Actively delete non autoDelete queues if deletePersistent is set
-            if (!q.isAutoDelete() && _configuration.deletePersistent())
+            if (!q.isAutoDelete() && (_configuration != null && _configuration.deletePersistent()))
             {
                 CurrentActor.get().message(q.getLogSubject(), TopicDeletePolicyMessages.TDP_DELETING_QUEUE());
                 q.delete();
---------------
-------------
@@ -1097,7 +1097,7 @@
         }
         
         relation.setComplex("Y".equals(nvp.get("RELATIONSHIP_IS_COMPLEX"))); //$NON-NLS-1$ //$NON-NLS-2$
-        String val = nvp.get(nvp.get("RELATIONSHIP_COMPLEX_JOIN")); //$NON-NLS-1$
+        String val = nvp.get("RELATIONSHIP_COMPLEX_JOIN"); //$NON-NLS-1$
         if (val != null) {
           relation.setComplexJoin(val);
         }
---------------
-------------
@@ -581,7 +581,7 @@
       
         String tableAlias = null;
         if (tableAliases != null) {
-          tableAlias = tableAliases.get(businessTable.getId());
+          tableAlias = tableAliases.get(businessTable);
         } else {
           tableAlias = businessTable.getId();
         }
---------------
-------------
@@ -478,7 +478,7 @@
     SQLDialectInterface dialect = SQLDialectFactory.getSQLDialect(databaseMeta);
     List<String> paramNames = null;
     String sql = dialect.generateSelectStatement(query);
-    Pattern p = Pattern.compile("___PARAM\\[(.*)\\]___"); //$NON-NLS-1$
+    Pattern p = Pattern.compile("___PARAM\\[(.*?)\\]___"); //$NON-NLS-1$
     Matcher m = p.matcher(sql);
     StringBuffer sb = new StringBuffer();
     while (m.find()) {
---------------
-------------
@@ -64,7 +64,7 @@
     if ((str == null || str.trim().length() == 0) && locale != null && locale.indexOf('_') > 0) {
       str = getLocalizedString(locale.substring(0, locale.lastIndexOf('_')));
     }
-    if (str == null || str.trim().length() == 0) {
+    if ((str == null || str.trim().length() == 0) && !DEFAULT_LOCALE.startsWith(locale)) {
       str = getLocalizedString(DEFAULT_LOCALE);
     }
     return str;
---------------
-------------
@@ -213,7 +213,7 @@
     }
 
     private long getFirstItemIdByAscDesc(boolean asc) {
-        long result = -1l;
+        long result = (asc) ? 0 : -1;
         final DBObject sortCommand = new BasicDBObject();
         sortCommand.put("_id", (asc) ? 1 : -1);
         final DBObject val;
---------------
-------------
@@ -39,6 +39,9 @@
       } else if ("value".equals(key)) {
         // this relies on nextString() being able to coerce raw numbers to strings
         fare.value = new BigDecimal(reader.nextString());
+      } else {
+        // Be forgiving of unexpected values
+        reader.skipValue();
       }
     }
     reader.endObject();
---------------
-------------
@@ -66,6 +66,6 @@
 
 	@Override
 	public String toString() {
-		return type + " " + PlainSelect.getStringList(columnsNames, true, true) + (name != null ? " " + name : "");
+		return type + (name != null ? " " + name : "") + " " + PlainSelect.getStringList(columnsNames, true, true);
 	}
 }
---------------
-------------
@@ -267,7 +267,7 @@
 	 */
 	public boolean removeTeamMember(User u)
 	{
-		if(!team.contains(u))
+		if(team.contains(u))
 		{
 			team.remove(u);
 			return true;
---------------
-------------
@@ -79,7 +79,7 @@
 		getBoxIteration().setText(displayRequirement.getIteration());
 		getBoxEstimate().setText(String.valueOf(displayRequirement.getEstimate()));
 		getBoxReleaseNum().setText(displayRequirement.getRelease());
-		getDropdownStatus().setSelectedItem(displayRequirement.getStatus());
+		getDropdownStatus().setSelectedItem(displayRequirement.getParent().getStatus());
 		getDropdownType().setSelectedItem(displayRequirement.getType());
 		
 		switch(displayRequirement.getPriority())
---------------
-------------
@@ -46,7 +46,7 @@
 		 
 		 // for all other attributes: instantiate as null, fill in if given.
 		 
-		 int idNum = deflated.getAsInt();
+		 int idNum = deflated.get("idNum").getAsInt();
 		 String username = null;
 		 String name = null;
 		 
---------------
-------------
@@ -358,7 +358,7 @@
       // catch that case here and put it back into our queue
       for (FastIDSet cluster : clusters) {
         double similarity = clusterSimilarity.getSimilarity(merged, cluster);
-        if (similarity > queue.get(queue.size() - 1).getSimilarity()) {
+        if (queue.size() > 0 && similarity > queue.get(queue.size() - 1).getSimilarity()) {
           ListIterator<ClusterClusterPair> queueIterator = queue.listIterator();
           while (queueIterator.hasNext()) {
             if (similarity > queueIterator.next().getSimilarity()) {
---------------
-------------
@@ -44,7 +44,7 @@
   @Override
   public void addToVector(String originalForm, double weight, Vector data) {
     dictionary.add(originalForm);
-    super.addToVector(originalForm, getWeight(originalForm, weight), data);
+    super.addToVector(originalForm, weight, data);
   }
 
   @Override
---------------
-------------
@@ -174,7 +174,7 @@
     return result;
   }
   
-  public static List<GenericUserSimilarity.UserUserSimilarity>getTopUserUserSimilarities(
+  public static List<GenericUserSimilarity.UserUserSimilarity> getTopUserUserSimilarities(
     int howMany, Iterator<GenericUserSimilarity.UserUserSimilarity> allSimilarities) {
     
     Queue<GenericUserSimilarity.UserUserSimilarity> topSimilarities
---------------
-------------
@@ -28,7 +28,7 @@
 
   @Override
   public void testSize() {
-    assertEquals("size", 3, getTestVector().getNumNondefaultElements());
+    assertEquals("size", 3, getTestVector().getNumNonZeroElements());
   }
 
   @Override
---------------
-------------
@@ -40,7 +40,7 @@
     double oldTotalWeight = totalWeight;
     totalWeight += weight;
     if (oldTotalWeight <= 0.0) {
-      average = datum * weight;
+    	average = datum;
     } else {
       average = average * oldTotalWeight / totalWeight + datum * weight / totalWeight;
     }
---------------
-------------
@@ -200,6 +200,7 @@
     log.info("Building average diffs...");
     try {
       buildAverageDiffsLock.writeLock().lock();
+      averageDiffs.clear();
       long averageCount = 0L;
       for (User user : dataModel.getUsers()) {
         averageCount = processOneUser(averageCount, user);
---------------
-------------
@@ -104,7 +104,7 @@
           int classIdx = lower.indexOf(ARFFType.NOMINAL.getIndicator());
           String[] classes = COMMA_PATTERN.split(line.substring(classIdx + 1, line.length() - 1));
           for (int i = 0; i < classes.length; i++) {
-            model.addNominal(label, classes[i].trim(), i);
+            model.addNominal(label, classes[i].trim(), i + 1);
           }
           
         } else if (lower.contains(ARFFType.DATE.getIndicator())) {
---------------
-------------
@@ -32,9 +32,6 @@
  * response to a feature vector.  This classifier uses 1 of n-1 coding where the 0-th category
  * is not stored explicitly.
  * <p/>
- * TODO: implement symbolic input with string, overall cooccurrence and n-gram hash encoding
- * TODO: implement reporter system to monitor progress
- *
  * Provides the based SGD based algorithm for learning a logistic regression, but omits all
  * annealing of learning rates.  Any extension of this abstract class must define the overall
  * and per-term annealing for themselves.
---------------
-------------
@@ -332,7 +332,7 @@
         result = 31 * result + (cellValue != null ? cellValue.hashCode() : 0);
         result = 31 * result + isPartitionKey.hashCode();
         result = 31 * result + isClusterKey.hashCode();
-        result = 31 * result + cellValidator.hashCode();
+        result = 31 * result + (cellValidator != null ? cellValidator.hashCode() : 0);
         return result;
     }
 
---------------
-------------
@@ -6,7 +6,7 @@
 import org.apache.streams.data.ActivitySerializer;
 import org.apache.streams.datasift.Datasift;
 import org.apache.streams.datasift.interaction.Interaction;
-import org.apache.streams.datasift.interaction.Links;
+import org.apache.streams.datasift.links.Links;
 import org.apache.streams.datasift.util.StreamsDatasiftMapper;
 import org.apache.streams.pojo.json.*;
 import org.slf4j.Logger;
---------------
-------------
@@ -33,7 +33,7 @@
 	Type getType(int paramIndex) throws SQLException {
 		checkParamIndex(paramIndex);
 		
-		return parameterTypes.get(paramIndex);
+		return parameterTypes.get(paramIndex-1);
 	}
 	
 	@Override
---------------
-------------
@@ -61,7 +61,7 @@
     private final static String ESTADO_OK = "Ok";
 
     private final static String ESTADO_ONLINE_EN_CREACION = "En Creaci&oacute;n";
-    private final static String ESTADO_ONLINE_EN_USO = " En Uso";
+    private final static String ESTADO_ONLINE_EN_USO = "En Uso";
     private final static String ESTADO_ONLINE_PARA_BORRAR = "Para Borrar";
     private final static String ESTADO_ONLINE_BORRADA = "Borrada";
     
---------------
-------------
@@ -48,7 +48,7 @@
             }
 
         });
-
+        child.add(parent);
         return parent;
     }
 
---------------
-------------
@@ -72,7 +72,7 @@
             for (Subscription _s : subscriptions) {
                 if (!_s.equals(s)) {
                     // was not in this composite
-                    if (idx == subscriptions.length) {
+                    if (idx == newSubscriptions.length) {
                         return this;
                     }
                     newSubscriptions[idx] = _s;
---------------
-------------
@@ -323,7 +323,7 @@
 
             @Override
             public void request(final long n) {
-                long c = consumerCapacity.getAndAdd(n);
+                long c = BackpressureUtils.getAndAddRequest(consumerCapacity, n);
                 Producer producer = currentProducer.get();
                 if (producer != null) {
                     producer.request(n);
---------------
-------------
@@ -115,7 +115,7 @@
         private void requestFromChild(long n) {
             // we track 'requested' so we know whether we should subscribe the next or not
             ConcatInnerSubscriber<T> actualSubscriber = currentSubscriber;
-            if (REQUESTED_UPDATER.getAndAdd(this, n) == 0) {
+            if (n > 0 && BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n) == 0) {
                 if (actualSubscriber == null && wip > 0) {
                     // this means we may be moving from one subscriber to another after having stopped processing
                     // so need to kick off the subscribe via this request notification
---------------
-------------
@@ -48,7 +48,7 @@
             }
 
         });
-
+        child.add(parent);
         return parent;
     }
 
---------------
-------------
@@ -72,7 +72,7 @@
             for (Subscription _s : subscriptions) {
                 if (!_s.equals(s)) {
                     // was not in this composite
-                    if (idx == subscriptions.length) {
+                    if (idx == newSubscriptions.length) {
                         return this;
                     }
                     newSubscriptions[idx] = _s;
---------------
-------------
@@ -323,7 +323,7 @@
 
             @Override
             public void request(final long n) {
-                long c = consumerCapacity.getAndAdd(n);
+                long c = BackpressureUtils.getAndAddRequest(consumerCapacity, n);
                 Producer producer = currentProducer.get();
                 if (producer != null) {
                     producer.request(n);
---------------
-------------
@@ -50,6 +50,7 @@
         child.add(worker);
         
         SamplerSubscriber<T> sampler = new SamplerSubscriber<T>(s);
+        child.add(sampler);
         worker.schedulePeriodically(sampler, time, time, unit);
 
         return sampler;
---------------
-------------
@@ -282,7 +282,7 @@
         }
         for (Hierarchy hierarchy : hierarchies) {
             if (hierarchy.getName() == null
-                || hierarchy.getName().equals(dimension.getName()))
+                || hierarchy.getUniqueName().equals(dimension.getUniqueName()))
             {
                 return hierarchy;
             }
---------------
-------------
@@ -55,13 +55,6 @@
 
     /**
      * Whether
-     * <a href="http://sourceforge.net/tracker/index.php?func=detail&aid=1735827&group_id=35302&atid=414613">bug 1735827, "Shared Tables and native NonEmptyCrossJoin"</a>
-     * is fixed.
-     */
-    public static final boolean Bug1735827Fixed = false;
-
-    /**
-     * Whether
      * <a href="http://sourceforge.net/tracker/index.php?func=detail&aid=1767775&group_id=35302&atid=414613">bug 1767775, "Predicate references RolapStar.Column when used in AggStar"</a>
      * is fixed.
      */
---------------
-------------
@@ -347,7 +347,7 @@
             final SortedSet<Comparable> regionValues =
                 regionColumn.getValues();
             final SortedSet<Comparable> headerValues =
-                regionColumn.getValues();
+                headerColumn.getValues();
             if (headerValues == null || regionValues == null) {
                 // This is a wildcard, so it always intersects.
                 return true;
---------------
-------------
@@ -90,6 +90,12 @@
      */
     public static final boolean Bug1888821Fixed = false;
 
+    /**
+     * Whether
+     * <a href="https://sourceforge.net/tracker/index.php?func=detail&aid=2446228&group_id=35302&atid=414613">bug 2446228, "HighCardinalityTest test cases disabled"</a>
+     * is fixed.
+     */
+    public static final boolean Bug2446228Fixed = false;
 
     /**
      * Returns whether to avoid a test because the memory monitor may cause it
---------------
-------------
@@ -47,6 +47,13 @@
     public static final boolean Bug1530543Fixed = false;
 
     /**
+     * Whether
+     * <a href="http://sourceforge.net/tracker/index.php?func=detail&aid=1530543&group_id=35302&atid=1696772">bug 1696772</a>
+     * is fixed.
+     */
+    public static final boolean Bug1696772Fixed = false;
+
+    /**
      * Returns whether to avoid a test because the memory monitor may cause it
      * to fail.
      *
---------------
-------------
@@ -356,7 +356,7 @@
                     if (exception == null) {
                         exception = (RuntimeException) value;
                     }
-                } else if (value == Util.nullValue) {
+                } else if (Util.isNull(value)) {
                     ;
                 } else {
                     values[j++] = value;
---------------
-------------
@@ -125,7 +125,6 @@
             for (Iterator<String> it = reqStationNames.iterator(); it.hasNext();) {
                 String stName = it.next();
                 if (stName.equalsIgnoreCase(n)) {
-                    System.out.println("add 'station' " + stName);
                     trajList.add(trajFeature);
 
                     double localAltMin = Double.POSITIVE_INFINITY;
---------------
-------------
@@ -103,7 +103,7 @@
         structures.put(CountryCode.DE,
                 new BbanStructure(
                         BbanStructureEntry.bankCode(8, 'n'),
-                        BbanStructureEntry.accountNumber(10, 'c')));
+                        BbanStructureEntry.accountNumber(10, 'n')));
 
         structures.put(CountryCode.HR,
                 new BbanStructure(
---------------
-------------
@@ -103,7 +103,7 @@
         structures.put(CountryCode.DE,
                 new BbanStructure(
                         BbanStructureEntry.bankCode(8, 'n'),
-                        BbanStructureEntry.accountNumber(10, 'c')));
+                        BbanStructureEntry.accountNumber(10, 'n')));
 
         structures.put(CountryCode.HR,
                 new BbanStructure(
---------------
-------------
@@ -238,7 +238,7 @@
                 states = new HashSet<String>();
                 for (ResolvedLocation location: combo) {
                     countries.add(location.getGeoname().getPrimaryCountryCode());
-                    states.add(location.getGeoname().getAdmin1Code());
+                    states.add(location.getGeoname().getPrimaryCountryCode() + location.getGeoname().getAdmin1Code());
                 }
 
                 // calculate a score for this particular combination based on commonality
---------------
-------------
@@ -1054,7 +1054,7 @@
                 placeholdersFromProps.put(placeholderName, placeholderValue);
             }
         }
-        setPlaceholders(placeholdersFromProps);
+        if (placeholdersFromProps.size() > 0) setPlaceholders(placeholdersFromProps);
     }
 
     /**
---------------
-------------
@@ -39,6 +39,7 @@
     public interface DB2 extends CommercialDB {}
     public interface Oracle extends CommercialDB {}
     public interface SQLServer extends CommercialDB {}
+    public interface GoogleCloudSQL extends CommercialDB {}
 
     public interface DB2zOS extends ContributorSupportedDB {}
     public interface Vertica extends ContributorSupportedDB {}
---------------
-------------
@@ -1054,7 +1054,7 @@
                 placeholdersFromProps.put(placeholderName, placeholderValue);
             }
         }
-        setPlaceholders(placeholdersFromProps);
+        if (placeholdersFromProps.size() > 0) setPlaceholders(placeholdersFromProps);
     }
 
     /**
---------------
-------------
@@ -84,7 +84,7 @@
 			List<TestDesc> tests,
 			Map<String, String> articles) throws IOException
 	{
-		String src = FileUtils.readFileToString(inputFile);
+		String src = FileUtils.readFileToString(inputFile, "UTF-8");
 		
 		Pattern p = Pattern.compile(
 				"(?m)^[ \t]*!![ \t]*(\\w+):?[ \t]*(?:\r\n?|\n)");
---------------
-------------
@@ -49,6 +49,7 @@
   private final ClusterCallback clusterCallback;
   private final ListeningExecutorService executorService;
   private final TaskService taskService;
+
   @Inject
   private CallbackScheduler(@Named("scheduler.id") String id,
                             @Named(Constants.Queue.CALLBACK) TrackingQueue callbackQueue,
---------------
-------------
@@ -57,7 +57,6 @@
     ImagetypesInstanceTest.class, ImagetypesTest.class, ProvidersInstanceTest.class, ProvidersTest.class,
     ServicesInstanceTest.class, ServicesTest.class, CloseDriverTest.class
 })
-
 public class SuiteOrder {
 
   static Process process;
---------------
-------------
@@ -168,7 +168,7 @@
     Assert.assertNull(queue.take("worker6"));
   }
 
-  @Test(timeout = 30000)
+  @Test(timeout = 40000)
   public void testConcurrentAccess() throws Exception {
     final ElementsTrackingQueue queue = getQueue();
 
---------------
-------------
@@ -57,7 +57,6 @@
     ImagetypesInstanceTest.class, ImagetypesTest.class, ProvidersInstanceTest.class, ProvidersTest.class,
     ServicesInstanceTest.class, ServicesTest.class, CloseDriverTest.class
 })
-
 public class SuiteOrder {
 
   static Process process;
---------------
-------------
@@ -5,7 +5,6 @@
 import java.io.*;
 import java.text.ParseException;
 import java.util.HashMap;
-import java.util.Set;
 
 public class MultiLauncher {
 
---------------
-------------
@@ -175,7 +175,7 @@
         if (!dir.exists()) {
             throw new IllegalStateException("Table doesn't exist");
         }
-        if (deleteFileRecursively(dir)) {
+        if (!deleteFileRecursively(dir)) {
             throw new RuntimeException("Unable to delete some files");
         }
         MultiFileMap table = used.remove(name);
---------------
-------------
@@ -19,7 +19,7 @@
 
     public void startCommand(TableProvider tableProvider, String commandWithArgs) throws Exception {
         String[] args = commandWithArgs.trim().split("\\s+");
-        if (args[0].equals("")) {
+        if (args[0].isEmpty()) {
             return;
         }
         if (!allCommands.containsKey(args[0])) {
---------------
-------------
@@ -6,7 +6,7 @@
  * Created by pershik on 11/8/14.
  */
 public class NameChecker {
-    static boolean checkName(String name) {
+    public static boolean checkName(String name) {
         return !(name == null || "..".equals(name) || ".".equals(name)
                 || name.contains(File.separator));
     }
---------------
-------------
@@ -85,6 +85,7 @@
                 } else {
                     assert this==TIMESTAMP || this==TTL;
                     Long time = r.getPropertyDirect(this);
+                    if (time==null) return null; //there is no timestamp or ttl
                     TimeUnit unit = r.tx().getConfiguration().getTimestampProvider().getUnit();
                     if (this==TIMESTAMP) return (O)new StandardTimestamp(time,unit);
                     else return (O)new StandardDuration(time,unit);
---------------
-------------
@@ -77,7 +77,7 @@
             }
 
             byte[] b = generateClass( name, baseClass );
-            return defineClass( name, b, 0, b.length );
+            return defineClass( name, b, 0, b.length, baseClass.getProtectionDomain() );
         }
 
         // Try the classloader of this classloader -> get classes in Qi4j such as CompositeInvoker
---------------
-------------
@@ -130,7 +130,7 @@
             File commandsFile = findConfigFile(configFile);
             if (commandsFile != null) {
                 try {
-                    preProcessedCommands.load(new FileInputStream(commandsFile));
+                    loadFromFile(preProcessedCommands, commandsFile);
                 } catch (FileNotFoundException fnfex) {
                     // in case of a file within a jar in classpath, try to open stream using url
                     InputStream stream = PropertiesUtil.openStreamFromURL(configFile);
---------------
-------------
@@ -45,7 +45,7 @@
     VersionDao _dao;
     public DatabaseUpgradeChecker() {
         _dao = ComponentLocator.inject(VersionDaoImpl.class);
-        _upgradeMap.put(new Pair<String, String>("2.1.7", "2.2.3"), new DbUpgrade[] { new Upgrade217to22(), new UpgradeSnapshot217to223()});
+        _upgradeMap.put(new Pair<String, String>("2.1.7", "2.2.3"), new DbUpgrade[] { new Upgrade217to22(), new Upgrade221to222(), new UpgradeSnapshot217to223()});
     }
     
     protected void runScript(File file) {
---------------
-------------
@@ -951,7 +951,7 @@
             if (_listenAddr != null) {
                 graphicBuilder.append(" listen='" + _listenAddr + "'");
             } else {
-                graphicBuilder.append(" listen='' ");
+                graphicBuilder.append(" listen=''");
             }
             if (_passwd != null) {
                 graphicBuilder.append(" passwd='" + _passwd + "'");
---------------
-------------
@@ -34,7 +34,7 @@
 /* holds config data for the Ovm3 Hypervisor */
 public class Ovm3Configuration {
     private static final Logger LOGGER = Logger
-             .getLogger(Ovm3Configuration.class);
+          .getLogger(Ovm3Configuration.class);
     private String agentIp;
     private Long agentZoneId;
     private Long agentPodId;
---------------
-------------
@@ -50,7 +50,7 @@
 				finputstream.close();
 				dir = props.getProperty("paths.pid");
 				if (dir == null) {
-					dir = "/var/run";
+					dir = pidDir==null?"/var/run":pidDir;
 				}
 			}
 		} catch (IOException e) {
---------------
-------------
@@ -152,7 +152,7 @@
             throw new ConfigurationException("There is no upgrade path from " + dbVersion + " to " + currentVersion);
         }
 
-        if (Version.compare(currentVersion, upgrades[upgrades.length - 1].getUpgradedVersion()) == 0) {
+        if (Version.compare(currentVersion, upgrades[upgrades.length - 1].getUpgradedVersion()) != 0) {
             throw new ConfigurationException("The end upgrade version is actually at " + upgrades[upgrades.length - 1].getUpgradedVersion() + " but our management server code version is at " + currentVersion);
         }
         
---------------
-------------
@@ -4096,7 +4096,7 @@
             needRestart = true;
         }
 
-        List<VolumeVO> rootVols = _volsDao.findByInstance(vmId);
+        List<VolumeVO> rootVols = _volsDao.findByInstanceAndType(vmId, Volume.Type.ROOT);
         if (rootVols.isEmpty()) {
             InvalidParameterValueException ex = new InvalidParameterValueException(
                     "Can not find root volume for VM " + vm.getUuid());
---------------
-------------
@@ -63,7 +63,7 @@
 @Local(value = {NetworkElement.class, FirewallServiceProvider.class, 
         DhcpServiceProvider.class, UserDataServiceProvider.class, 
         StaticNatServiceProvider.class, LoadBalancingServiceProvider.class,
-        PortForwardingServiceProvider.class, IpDeployer.class,
+        PortForwardingServiceProvider.class, IpDeployer.class, VpcProvider.class,
         Site2SiteVpnServiceProvider.class, NetworkACLServiceProvider.class})
 public class VpcVirtualRouterElement extends VirtualRouterElement implements VpcProvider, Site2SiteVpnServiceProvider, NetworkACLServiceProvider{
     private static final Logger s_logger = Logger.getLogger(VpcVirtualRouterElement.class);
---------------
-------------
@@ -248,6 +248,7 @@
             try
             {
                 if (!(originalType instanceof FixedPointType) &&
+                    !(originalType.typeSpec() instanceof ArrayTypeSpec) &&
                     !(originalType.typeSpec() instanceof StringType) &&
                     !(originalType.typeSpec() instanceof SequenceType) &&
                     ! originalTypeWasScopedName &&
---------------
-------------
@@ -722,7 +722,7 @@
                         String lab = (String) unusedCaseLabels.elementAt (i);
                         if (! lab.equals (defaultStr))
                         {
-                            pw.print (" && discriminator != " + lab);
+                            pw.print (" && _discriminator != " + lab);
                         }
                     }
                 }
---------------
-------------
@@ -812,7 +812,7 @@
                 String name = get_string();
                 if( name.equals( "prefix" ) )
                 {
-                    advance();
+                    swallow_whitespace();
                     currentPragmaPrefix = get_string();
                 }
                 else if( name.equals( "version" ) )
---------------
-------------
@@ -225,7 +225,7 @@
                 if (next == null) {
                     next = computeNext();
                 }
-                return next != end;
+                return next != null && next != end;
             }
 
             @Override
---------------
-------------
@@ -657,7 +657,7 @@
                 if (next == null) {
                     next = computeNext();
                 }
-                return next != end;
+                return next != null && next != end;
             }
 
             @Override
---------------
-------------
@@ -792,7 +792,7 @@
             if (active >= pageSize) {
                 // split page
                 Page newPage = split();
-                newPage.addAt(pageSize / 2, x, w, history);
+                newPage.addAt(newPage.active, x, w, history);
                 return newPage;
             } else {
                 addAt(active, x, w, history);
---------------
-------------
@@ -257,8 +257,9 @@
 		    // add chain if available
 		    byte[] certChain = readChain(cryptoMarker, dispatcher, handle);
 
-		    // concatenate with the certificate to use for TLS or signature creation
-		    cert = ByteUtils.concatenate(cert, certChain);
+		    // cert contains the chain (if available) only because we can't read the certificate without using
+		    // the pin
+		    cert = certChain;
 		    Pair<byte[], Boolean> certAndTLSAuth = new Pair<>(cert, false);
 		    dataSetWithCert.put(cryptoMarker.getCertificateRefs().get(0).getDataSetName(), certAndTLSAuth);
 		} else if (containsAuthenticationCertificate(cert)) {
---------------
-------------
@@ -32,7 +32,7 @@
 	public static final List<String> DEFAULT_SUPPORTED_CONTENT_TYPES = unmodifiableList(asList("text/html"));
 	public static final String ACCEPT_HEADER = "Accept";
 
-	private static final String CONTENT_TYPE_DELIMITER = ",";
+    private static final String CONTENT_TYPE_DELIMITER = ",\\s*";
 
 	private List<String> supportedContentTypes;
 	private boolean favorParameterOverAcceptHeader;
---------------
-------------
@@ -158,6 +158,7 @@
 
     if ("Safari".equals(capabilities.getBundleName())) {
       setMode(WorkingMode.Web);
+      getRemoteWebDriver().get("about:blank");
     }
 
   }
---------------
-------------
@@ -63,7 +63,7 @@
     NULL.setTeamName("NULL");
   }
 
-  public static Comparator<Team> TEAM_NUMBER_COMPARATOR = new Comparator<Team>() {
+  public static final Comparator<Team> TEAM_NUMBER_COMPARATOR = new Comparator<Team>() {
     public int compare(final Team one, final Team two) {
       final int oneNum = one.getTeamNumber();
       final int twoNum = two.getTeamNumber();
---------------
-------------
@@ -36,5 +36,5 @@
 public interface HttpClient {
 
     HttpResponse request(HttpRequest req) throws TwitterException;
-    public void shutdown();
+    void shutdown();
 }
---------------
-------------
@@ -51,7 +51,6 @@
         suite.addTestSuite(twitter4j.http.HttpClientTest.class);
         suite.addTestSuite(twitter4j.http.OAuthTest.class);
         suite.addTestSuite(twitter4j.http.PostParameterTest.class);
-        suite.addTestSuite(twitter4j.http.ResponseTest.class);
 
         suite.addTestSuite(AsyncTwitterTest.class);
         suite.addTestSuite(DAOTest.class);
---------------
-------------
@@ -71,7 +71,7 @@
                 break;
             }
             semicolonIndex = original.indexOf(";", index);
-            if (-1 != semicolonIndex && 10 > (semicolonIndex - index)) {
+            if (-1 != semicolonIndex) {
                 escaped = original.substring(index, semicolonIndex + 1);
                 entity = escapeEntityMap.get(escaped);
                 if (null != entity) {
---------------
-------------
@@ -95,7 +95,7 @@
                     if (!json.isNull ("sender")) {
                         userStreamListener.onDirectMessage (new DirectMessageJSONImpl (json));
                     } else if (!json.isNull("text")) {
-                        userStreamListener.onStatus(new StatusJSONImpl(json));
+                        listener.onStatus(new StatusJSONImpl(json));
                     } else if (!json.isNull("delete")) {
                         listener.onDeletionNotice(new StatusDeletionNoticeImpl(json));
                     } else if (!json.isNull("limit")) {
---------------
-------------
@@ -45,6 +45,7 @@
     final Authentication authentication;
     /*package*/
     Map<String, String> requestHeaders;
+    private static final long serialVersionUID = -3463594029098858381L;
 
     /**
      * @param method         Specifies the HTTP method
---------------
-------------
@@ -89,7 +89,6 @@
 
     public void testShowUser() throws Exception {
         User user = twitterAPI1.showUser(id1.name);
-        assertEquals(id1.name, user.getName());
         assertEquals(id1.name, user.getScreenName());
         assertNotNull(user.getLocation());
         assertNotNull(user.getDescription());
---------------
-------------
@@ -158,6 +158,7 @@
 
     if ("Safari".equals(capabilities.getBundleName())) {
       setMode(WorkingMode.Web);
+      getRemoteWebDriver().get("about:blank");
     }
 
   }
---------------
-------------
@@ -47,6 +47,7 @@
 import org.syncany.plugins.transfer.TransferSettings;
 import org.syncany.plugins.unreliable_local.UnreliableLocalTransferPlugin;
 import org.syncany.plugins.unreliable_local.UnreliableLocalTransferSettings;
+
 import com.google.common.collect.Lists;
 
 public class TestConfigUtil {
---------------
-------------
@@ -47,6 +47,7 @@
 import org.syncany.plugins.transfer.TransferSettings;
 import org.syncany.plugins.unreliable_local.UnreliableLocalTransferPlugin;
 import org.syncany.plugins.unreliable_local.UnreliableLocalTransferSettings;
+
 import com.google.common.collect.Lists;
 
 public class TestConfigUtil {
---------------
-------------
@@ -96,7 +96,7 @@
         to.setPzxid(stat.getPzxid());
         to.setVersion(stat.getVersion());
         to.setEphemeralOwner(stat.getEphemeralOwner());
-        to.setDataLength(data.length);
+        to.setDataLength(data == null ? 0 : data.length);
         to.setNumChildren(children.size());
     }
 
---------------
-------------
@@ -391,7 +391,7 @@
     if (obj instanceof PositionImpl) {
       PositionImpl other = (PositionImpl) obj;
       return new EqualsBuilder().append(getQuantity(), other.getQuantity())
-          .append(getSecurityKey(), getSecurityKey())
+          .append(getSecurityKey(), other.getSecurityKey())
           .append(getSecurity(), other.getSecurity())
           .append(getTrades(), other.getTrades())
           .append(getParentNodeId(), other.getParentNodeId())
---------------
-------------
@@ -10,8 +10,6 @@
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
-import org.junit.Ignore;
-
 import com.opengamma.engine.DefaultComputationTargetResolver;
 import com.opengamma.engine.function.DefaultFunctionResolver;
 import com.opengamma.engine.function.FunctionCompilationContext;
---------------
-------------
@@ -52,7 +52,7 @@
 
   @Override
   public ManageableSecurity buildObject(FudgeDeserializer deserializer, FudgeMsg msg) {
-    ManageableSecurity object = new ManageableSecurity();
+    ManageableSecurity object = new ManageableSecurity(msg.getString(SECURITY_TYPE_FIELD_NAME));
     ManageableSecurityFudgeBuilder.fromFudgeMsg(deserializer, msg, object);
     return object;
   }
---------------
-------------
@@ -42,7 +42,7 @@
   @Override
   public TimeSeriesMetaData getDefaultMetaData(IdentifierBundle identifiers) {
     TimeSeriesSearchRequest<T> searchRequest = new TimeSeriesSearchRequest<T>();
-    searchRequest.setIdentifiers(identifiers.getIdentifiers());
+    searchRequest.getIdentifiers().addAll(identifiers.getIdentifiers());
     searchRequest.setLoadTimeSeries(false);
     
     TimeSeriesSearchResult<T> searchResult = _tsMaster.searchTimeSeries(searchRequest);
---------------
-------------
@@ -56,7 +56,7 @@
 public abstract class RowStoreJdbcDao implements TimeSeriesDao {
   private static final Logger s_logger = LoggerFactory.getLogger(RowStoreJdbcDao.class);
   
-  private static final int INVALID_KEY = -1;
+  public static final int INVALID_KEY = -1;
   private static final String LOAD_TIME_SERIES = "loadTimeSeries";
   private static final String LOAD_TIME_SERIES_WITH_DATES = "loadTimeSeriesWithDates";
   private static final String SELECT_QUOTED_OBJECT_FROM_IDENTIFIERS = "selectQuotedObjectFromIdentifiers";
---------------
-------------
@@ -594,7 +594,7 @@
           }
           k >>= 1;
           if (k > 0) {
-            checkNoOverflow(b <= FLOOR_SQRT_MAX_LONG);
+            checkNoOverflow(-FLOOR_SQRT_MAX_LONG <= b && b <= FLOOR_SQRT_MAX_LONG);
             b *= b;
           }
       }
---------------
-------------
@@ -1,3 +1,11 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+
 /** Generally useful classes, not particularly tied to any other package. */
 
 package org.dspace.util;
---------------
